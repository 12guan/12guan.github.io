<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Appium基础-安装、配置、启动</title>
    <url>/2021/09/07/Appium%E5%9F%BA%E7%A1%80-%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="一、Appium简介"><a href="#一、Appium简介" class="headerlink" title="一、Appium简介"></a>一、<strong>Appium简介</strong></h2><h3 id="1-Appium介绍"><a href="#1-Appium介绍" class="headerlink" title="1. Appium介绍"></a>1. <strong>Appium介绍</strong></h3><p>Appium is an open source test automation framework for use with native, hybrid and mobile web apps. It drives iOS, Android, and Windows apps using the WebDriver protocol.</p>
<p>Appium是一个开源测试自动化框架，可用于原生，混合和移动Web应用程序测试。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。<span id="more"></span></p>
<ul>
<li><a href="http://appium.io/">Appium官网</a></li>
<li><a href="https://github.com/appium?utf8=%E2%9C%93&q=&type=source&language=">Appium github主页</a></li>
<li><a href="http://appium.io/docs/cn/about-appium/intro/">官方中文文档</a></li>
<li><a href="http://discuss.appium.io/latest">Appium官方论坛</a></li>
<li><a href="https://testerhome.com/">Testerhome中文社区</a></li>
</ul>
<h3 id="2-Appium优势"><a href="#2-Appium优势" class="headerlink" title="2. Appium优势"></a>2. <strong>Appium优势</strong></h3><ul>
<li>可以跨平台同时支持android、ios</li>
<li> 支持多种语言，java、python、php、Ruby等等</li>
<li>不用为复杂的环境发愁</li>
<li> 如果你有selenium经验，直接上手。</li>
</ul>
<h3 id="3-Appium架构原理"><a href="#3-Appium架构原理" class="headerlink" title="3. Appium架构原理"></a>3. <strong>Appium架构原理</strong></h3><p>Appium是在手机操作系统自带的测试框架基础上实现的，Android和iOS的系统上使用的工具分别如下：</p>
<ul>
<li><p>Android（版本&gt;4.3）：UIAutomator，Android 4.3之后系统自带的UI自动化测试工具。</p>
</li>
<li><p>Android（版本≤4.3）：Selendroid，基于Android Instrumentation框架实现的自动化测试工具。</p>
</li>
<li><p>iOS：UIAutomation（instruments框架里面的一个模板），iOS系统自带的UI自动化测试工具。</p>
<img src="https://pic.imgdb.cn/item/6137722b44eaada73936c4f7.jpg"> </li>
</ul>
<h4 id="1-运行原理"><a href="#1-运行原理" class="headerlink" title="1) 运行原理"></a>1) <strong>运行原理</strong></h4><p>我们的电脑（client）上运行自动化测试脚本，调用的是webdriver的接口，appium server接收到我们client上发送过来的命令后他会将这些命令转换为UIautomator认识的命令，然后由UIautomator来在设备上执行自动化。</p>
<p>Appium的架构原理如上图所示，由客户端（Appium Client）和服务器（Appium Server）两部分组成，客户端与服务器端通过JSON Wire Protocol进行通信。</p>
<h4 id="2-Appium服务器"><a href="#2-Appium服务器" class="headerlink" title="2) Appium服务器"></a>2) <strong>Appium服务器</strong></h4><p>Appium服务器是Appium框架的核心。它是一个基于Node.js实现的HTTP服务器。Appium服务器的主要功能是接受从Appium客户端发起的连接，监听从客户端发送来的命令，将命令发送给bootstrap.jar（iOS手机为bootstrap.js）执行，并将命令的执行结果通过HTTP应答反馈给Appium客户端。</p>
<h4 id="3-Boostrap-jar"><a href="#3-Boostrap-jar" class="headerlink" title="3) Boostrap.jar"></a>3) <strong>Boostrap.jar</strong></h4><p>Bootstrap.jar是在Android手机上运行的一个应用程序，它在手机上扮演TCP服务器的角色。当Appium服务器需要运行命令时，Appium服务器会与Bootstrap.jar建立TCP通信，并把命令发送给Bootstrap.jar；Bootstrap.jar负责运行测试命令。</p>
<h4 id="4-Appium客户端"><a href="#4-Appium客户端" class="headerlink" title="4) Appium客户端"></a>4) <strong>Appium客户端</strong></h4><p>它主要是指实现了Appium功能的WebDriver协议的客户端Library，它负责与Appium服务器建立连接，并将测试脚本的指令发送到Appium服务器。现有的客户端Library有多种语言的实现，包括Ruby、Python、Java、JavaScript（Node.js）、Object C、PHP和C#。Appium的测试是在这些Library的基础上进行开发的。</p>
<h2 id="二、Appium组件"><a href="#二、Appium组件" class="headerlink" title="二、Appium组件"></a>二、<strong>Appium组件</strong></h2><h3 id="1-Appium-Server"><a href="#1-Appium-Server" class="headerlink" title="1) Appium Server"></a>1) <strong>Appium Server</strong></h3><p>Appium Server就是Appium的服务端——一个web接口服务，使用Node.js实现。引用官网解释说明。</p>
<p>Appium is a server written in Node.js. It can be built and installed from source or installed directly from </p>
<h3 id="2-Appium-Desktop"><a href="#2-Appium-Desktop" class="headerlink" title="2) Appium Desktop"></a>2) <strong>Appium Desktop</strong></h3><p>Appium Desktop是一款适用于Mac，Windows和Linux的开源应用程序，它以美观而灵活的用户界面为您提供Appium自动化服务器的强大功能。 它是几个Appium相关工具的组合：</p>
<ol>
<li><p>Appium Server的图形界面。 您可以设置选项，启动/停止服务器，查看日志等…您也不需要使用Node 的NPM来安装Appium，因为Node运行时与Appium Desktop捆绑在一起。</p>
</li>
<li><p>您可以使用Inspector查看应用程序的元素，获取有关它们的基本信息，并与它们进行基本的交互。</p>
<img src="https://pic.imgdb.cn/item/6137725f44eaada739373e1a.jpg">

<img src="https://pic.imgdb.cn/item/6137726d44eaada739375f5d.jpg"></li>
</ol>
<p> 注意：</p>
<p>Appium Desktop与Appium不同。 Appium Desktop是Appium的图形前端，带有其他工具。 Appium Desktop以其自己的节奏发布，并拥有自己的版本控制系统。 就像国内很多定制的Android系统有自己版本号，但是都是基于一个Android系统版本封装的。版本号不一定与Andriod原生系统版本号一致。如：魅族的flyme6.0系统的内核是Android 5.1</p>
<h3 id="3-Appium-GUI"><a href="#3-Appium-GUI" class="headerlink" title="3) Appium GUI"></a>3) <strong>Appium GUI</strong></h3><p>Appium GUI是Appium desktop的前身。 这个也是把Appium server封装成了一个图形界面，降低使用门槛，如同最初的操作系统Dos都是敲命令，后面都是图形界面操作系统，如Windows系统。很多初学者对下面这个界面应该不陌生吧，这个就是Windows版本的Appium GUI界面。测试人员可以手动启动，配置相关server 服务，如果不用这个启动的话，需要命令启动服务。因为大部分教程都是基于这个GUI来讲解的，所以很多人一说Appium就认为是这个。</p>
<p>该产品的Windows版本在2015年的AppiumForWindows_1_4_16_1.zip之后就停止更新了。目前版本可以使用，但是封装的不是最新的Appium版本，而是1.4.16版本。如果要使用最新的桌面版需要使用Appium Desktop。 </p>
<p><a href="https://bitbucket.org/appium/appium.app/downloads/">历史版本下载</a></p>
<img src="https://pic.imgdb.cn/item/613772e244eaada739387e9e.jpg">

<h3 id="4-Appium-Clients"><a href="#4-Appium-Clients" class="headerlink" title="4) Appium Clients"></a>4) <strong>Appium Clients</strong></h3><p>因为Appium是一个C/S结构，有了服务端的肯定还有客户端，Appium Clients就是客户端，它会给服务端Appium Server发送请求会话来执行自动化任务。就像我们浏览器访问网页，浏览器是客户端，通过操作发送请求服务器来获取数据。我们可以使用不同的客户端浏览器（IE，Firefox,Chrome）访问一个网站。 Appium客户端可以使用不同的语言来实现，如Python，java等。具体详见下表：</p>
<table>
<thead>
<tr>
<th>Language/Framework</th>
<th align="left">Github Repo and Installation Instructions</th>
</tr>
</thead>
<tbody><tr>
<td>Ruby</td>
<td align="left"><a href="https://github.com/appium/ruby_lib">https://github.com/appium/ruby_lib</a></td>
</tr>
<tr>
<td>Python</td>
<td align="left"><a href="https://github.com/appium/python-client">https://github.com/appium/python-client</a></td>
</tr>
<tr>
<td>Java</td>
<td align="left"><a href="https://github.com/appium/java-client">https://github.com/appium/java-client</a></td>
</tr>
<tr>
<td>JavaScript (Node.js)</td>
<td align="left"><a href="https://github.com/admc/wd">https://github.com/admc/wd</a></td>
</tr>
<tr>
<td>Objective C</td>
<td align="left"><a href="https://github.com/appium/selenium-objective-c">https://github.com/appium/selenium-objective-c</a></td>
</tr>
<tr>
<td>PHP</td>
<td align="left"><a href="https://github.com/appium/php-client">https://github.com/appium/php-client</a></td>
</tr>
<tr>
<td>C# (.NET)</td>
<td align="left"><a href="https://github.com/appium/appium-dotnet-driver">https://github.com/appium/appium-dotnet-driver</a></td>
</tr>
<tr>
<td>RobotFramework</td>
<td align="left"><a href="https://github.com/jollychang/robotframework-appiumlibrary">https://github.com/jollychang/robotframework-appiumlibrary</a></td>
</tr>
</tbody></table>
<h2 id="三、Appium环境搭建"><a href="#三、Appium环境搭建" class="headerlink" title="三、Appium环境搭建"></a>三、<strong>Appium环境搭建</strong></h2><p>Node.js</p>
<p>Appium</p>
<p>Appium-desktop</p>
<p>Appium-doctor</p>
<p>Appium-Python-Clien</p>
<p>Python</p>
<p>JDK</p>
<p>Andriod SDK</p>
<p>环境开始搭建的时候，尽量保持版本一致。</p>
<p>在软件目录里面</p>
<img src="https://pic.imgdb.cn/item/6137731f44eaada739391309.jpg">

<h3 id="1-Node-js"><a href="#1-Node-js" class="headerlink" title="1) Node.js"></a>1) <strong>Node.js</strong></h3><p>输入如下命令进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;node -v</span><br><span class="line">v6.11.3</span><br><span class="line"></span><br><span class="line">C:\Users\admin&gt;npm -v</span><br><span class="line">3.10.10</span><br></pre></td></tr></table></figure>

<h3 id="2-Appium"><a href="#2-Appium" class="headerlink" title="2) Appium"></a>2) <strong>Appium</strong></h3><p>Appium Server其实可以通过命令 npm install -g appium来安装。不过由于众所周知的网络原因，直接使用这样安装会非常非常慢，甚至会安装失败，所以我们可以使用国内镜像来安装。</p>
<p>选用的镜像是 <a href="https://npm.taobao.org/">淘宝NPM镜像</a></p>
<p>这步server安装不上，跳过安装 appium-desktop</p>
<h4 id="镜像设置"><a href="#镜像设置" class="headerlink" title="镜像设置"></a><strong>镜像设置</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>执行完成命令看到如下提示则表示设置完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt; npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0</span><br><span class="line">C:\Users\admin\AppData\Roaming\npm\cnpm -&gt; C:\Users\admin\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm</span><br><span class="line">+ cnpm@5.2.0</span><br><span class="line">added 764 packages in 63.767s</span><br></pre></td></tr></table></figure>



<h4 id="appium-安装"><a href="#appium-安装" class="headerlink" title="appium 安装"></a><strong>appium 安装</strong></h4><p>使用如下命令来执行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装最新版本</span><br><span class="line">cnpm install -g appium</span><br><span class="line"></span><br><span class="line">#安装指定版本</span><br><span class="line">cnpm install appium@1.7.2 -g</span><br></pre></td></tr></table></figure>



<h4 id="Appium配置"><a href="#Appium配置" class="headerlink" title="Appium配置"></a><strong>Appium配置</strong></h4><p>安装完成之后可以使用如下命令查看appium的安装路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;where appium</span><br><span class="line"></span><br><span class="line">C:\Users\admin\AppData\Roaming\npm\appium</span><br><span class="line"></span><br><span class="line">C:\Users\admin\AppData\Roaming\npm\appium.cmd</span><br></pre></td></tr></table></figure>



<h4 id="appium运行"><a href="#appium运行" class="headerlink" title="appium运行"></a><strong>appium运行</strong></h4><p>在控制台输入命令 appium即可启动appium服务，appium -v查看版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;appium -v</span><br><span class="line">1.7.2</span><br><span class="line"></span><br><span class="line">C:\Users\admin&gt;appium</span><br><span class="line">[Appium] Welcome to Appium v1.7.2</span><br><span class="line">[Appium] Appium REST http interface listener started on 0.0.0.0:4723</span><br></pre></td></tr></table></figure>

<p>如果输入appium后显示：“appium不是内部或外部命令,也不是可运行的程序或批处理文件” 可以将appium安装的路径 如： “C:\Users\admin\AppData\Roaming\npm”配置到系统环境变量Path中</p>
<h4 id="退出appium"><a href="#退出appium" class="headerlink" title="退出appium"></a><strong>退出appium</strong></h4><p>按键 ctrl+c 选择y 即可退出</p>
<h3 id="3-Appium-desktop"><a href="#3-Appium-desktop" class="headerlink" title="3) Appium-desktop"></a>3) <strong>Appium-desktop</strong></h3><p>下载地址：<a href="https://github.com/appium/appium-desktop/releases">https://github.com/appium/appium-desktop/releases</a></p>
<p>上面提到的问题可以使用前面我们已经介绍了Appium Server来解决，Appium-desktop工具其实也封装了Appium server和Node.js依赖环境。</p>
<h3 id="4-Appium-Python-Client"><a href="#4-Appium-Python-Client" class="headerlink" title="4) Appium-Python-Client"></a>4) <strong>Appium-Python-Client</strong></h3><p>通过命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install Appium-Python-Client</span><br></pre></td></tr></table></figure>

<p>进行安装。 安装后可以通过如下命令来检测是否安装成功。</p>
<img src="https://pic.imgdb.cn/item/6137735e44eaada73939a849.jpg">

<p>输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br></pre></td></tr></table></figure>

<p>回车，如果控制台没有报错，则说明安装成功。 </p>
<p>注意：推荐使用python3.xx版本，另外版本不要太低了，可能导致pip指令安装不成功。</p>
<p>如果出现如下报错，则说明安装失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImportError: No module named &#x27;appium&#x27;</span><br><span class="line">ImportError: cannot import name “webdriver”</span><br></pre></td></tr></table></figure>

<p>说明：装Appium-Python-Client安装后的路径一般为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;Python 安装路径&#125;\Lib\site-packages\appium</span><br></pre></td></tr></table></figure>

<h3 id="5-Python"><a href="#5-Python" class="headerlink" title="5) Python"></a>5) <strong>Python</strong></h3><p>Python安装3XX版本,然后cmd窗口验证一下:python</p>
<h3 id="6-JDK"><a href="#6-JDK" class="headerlink" title="6) JDK"></a>6) <strong>JDK</strong></h3><p>控制台验证一下：java -version</p>
<h3 id="7-Andriod-SDK"><a href="#7-Andriod-SDK" class="headerlink" title="7) Andriod SDK"></a>7) <strong>Andriod SDK</strong></h3><p>前面章节配置好了</p>
<h3 id="8-appium-doctor"><a href="#8-appium-doctor" class="headerlink" title="8) appium-doctor"></a>8) <strong>appium-doctor</strong></h3><p>appium-doctor可以检测Appium整体依赖环境配置情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;cnpm install appium-doctor -g</span><br></pre></td></tr></table></figure>

<p>· 在控制台输入命令：appium-doctor 看到如下提示说明整体环境配置成功。</p>
<h2 id="四、Appium-desktop介绍"><a href="#四、Appium-desktop介绍" class="headerlink" title="四、Appium-desktop介绍"></a>四、<strong>Appium-desktop介绍</strong></h2><p>Appium-desktop主界面包含三个菜单Simple,Advanced、Presets</p>
<h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a><strong>Simple</strong></h3><h4 id="host"><a href="#host" class="headerlink" title="host"></a><strong>host</strong></h4><p>设置Appium server的ip地址，本地调试可以将ip地址修改为127.0.0.1</p>
<h4 id="port"><a href="#port" class="headerlink" title="port"></a><strong>port</strong></h4><p>设置端口号，默认是4723不用修改</p>
<h4 id="start-server"><a href="#start-server" class="headerlink" title="start server"></a><strong>start server</strong></h4><p>启动 Appium server</p>
<h2 id="五、Capacity配置简介"><a href="#五、Capacity配置简介" class="headerlink" title="五、Capacity配置简介"></a>五、<strong>Capacity配置简介</strong></h2><h3 id="1-什么是Capability"><a href="#1-什么是Capability" class="headerlink" title="1. 什么是Capability"></a>1. <strong>什么是Capability</strong></h3><p>desired capability的功能是配置Appium会话。他们告诉Appium服务器您想要自动化的平台和应用程序。</p>
<p>Desired Capabilities是一组设置的键值对的集合，其中键对应设置的名称，而值对应设置的值。（如：”platformName”: “Android”）Desired Capabilities主要用于通知Appium服务器建立需要的Session。</p>
<p><strong>Session</strong></p>
<p>Appium的客户端和服务端之间进行通信都必须在一个Session的上下文中进行。客户端在发起通信的时候首先会发送一个叫作“Desired Capabilities”的JSON对象给服务器。服务器收到该数据后，会创建一个session并将session的ID返回到客户端。之后客户端可以用该session的ID发送后续的命令。</p>
<h3 id="2-常用Capability配置"><a href="#2-常用Capability配置" class="headerlink" title="2. 常用Capability配置"></a>2. <strong>常用Capability配置</strong></h3><p>主要分成了三部分：公共部分、ios部分、android部分，如果你android想用ios的那是不可能的，so，老老实实去了解每个平台有哪些，他们的作用是什么。下面我们介绍一些公用常用的,红色标记的为常用的选项。</p>
<img src="https://pic.imgdb.cn/item/613773e644eaada7393aec3a.jpg">

<h3 id="3-Android独有Capability"><a href="#3-Android独有Capability" class="headerlink" title="3. Android独有Capability"></a>3. <strong>Android独有Capability</strong></h3><img src="https://pic.imgdb.cn/item/6137741444eaada7393b59d1.jpg">]]></content>
  </entry>
  <entry>
    <title>Appium基础操作</title>
    <url>/2021/09/02/Appium%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>优化：把启动app的脚本封装在一个模块，接下来的每次试验直接调用即可。</p>
 <span id="more"></span>

<p><strong>Capability.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from  appium import webdriver</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;</span><br><span class="line">desired_caps[&#x27;platforVersion&#x27;]=&#x27;7.1.2&#x27;</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=r&#x27;d:\kaoyan3.1.0.apk&#x27;</span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=&#x27;False&#x27;</span><br><span class="line">driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)</span><br><span class="line">driver.implicitly_wait(2)</span><br><span class="line"></span><br><span class="line">def check_cancelBtn():</span><br><span class="line">    print(&#x27;check cancelBtn&#x27;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        print(&#x27;no cancelBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        cancelBtn.click()</span><br><span class="line"></span><br><span class="line">def check_skipBtn():</span><br><span class="line">    print(&#x27;check skipBtn&#x27;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        skipBtn = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        print(&#x27;no skipBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        skipBtn.click()</span><br><span class="line"></span><br><span class="line">check_cancelBtn()</span><br><span class="line">check_skipBtn()</span><br></pre></td></tr></table></figure>

<h2 id="一、name定位"><a href="#一、name定位" class="headerlink" title="一、name定位"></a><strong>一、name定位</strong></h2><p>根据name进行定位，对于android来说，就是text属性</p>
<p>但是由于text稳定性不是很好，所以appium 1.5开始废弃了该方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Capability import *</span><br><span class="line">driver.find_element_by_name(&#x27;请输入用户名&#x27;).send_keys(&#x27;&#x27;)</span><br><span class="line">driver.find_element_by_name(&#x27;登录&#x27;).click()</span><br></pre></td></tr></table></figure>

<p><em>运行提示： Locator Strategy ‘name’ is not supported for this session</em></p>
<h2 id="二、classname定位"><a href="#二、classname定位" class="headerlink" title="二、classname定位"></a><strong>二、classname定位</strong></h2><p>classname定位是根据元素类型来进行定位，但是实际情况中很多元素的classname都是相同的，如上例中登录页面中的用户名和密码都是clasName属性值都是：<strong>“android.widget.EditText”</strong>因此只能定位第一个元素也就是用户名，而密码输入框就需要使用其他方式来定位，这样其实很鸡肋.一般情况下如果有id就不必使用classname定位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Capability import *</span><br><span class="line">driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;xxxxxx&#x27;)</span><br><span class="line">driver.find_element_by_class_name(&#x27;android.widget.EditText&#x27;).send_keys(&#x27;xxxxxx&#x27;)</span><br><span class="line">driver.find_element_by_class_name(&#x27;android.widget.Button&#x27;).click()</span><br></pre></td></tr></table></figure>

<h2 id="三、相对定位"><a href="#三、相对定位" class="headerlink" title="三、相对定位"></a><strong>三、相对定位</strong></h2><p>相对定位是先找到该元素的有对应属性的父元素节点，然后基于父元素进行元素定位。</p>
<p><strong>测试案例</strong></p>
<p>不使用id元素定位方式，在新用户注册界面点击添加头像按钮。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rom Capability import driver</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()</span><br><span class="line"></span><br><span class="line">root_element=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_parentlayout&#x27;)</span><br><span class="line">root_element.find_element_by_class_name(&#x27;android.widget.ImageView&#x27;).click()</span><br></pre></td></tr></table></figure>

<h2 id="四、xpath定位"><a href="#四、xpath定位" class="headerlink" title="四、xpath定位"></a><strong>四、xpath定位</strong></h2><p>xpath定位是一种路径定位方式，主要是依赖于元素绝对路径或者相关属性来定位，但是绝对路径xpath执行效率比较低（特别是元素路径比较深的时候），一般使用比较少。通常使用xpath相对路径和属性定位。</p>
<p>xpath路径表达式</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>从根节点选取。</td>
</tr>
<tr>
<td>//</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>
<tr>
<td>nodename</td>
<td>选取此节点的所有子节点。</td>
</tr>
<tr>
<td>.</td>
<td>选取当前节点。</td>
</tr>
<tr>
<td>..</td>
<td>选取当前节点的父节点。</td>
</tr>
<tr>
<td>@</td>
<td>选取属性。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任何元素节点。</td>
</tr>
<tr>
<td>@*</td>
<td>匹配任何属性节点。</td>
</tr>
<tr>
<td>node()</td>
<td>匹配任何类型的节点。</td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<p>使用xpath定位元素来进行登录操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Capability import driver</span><br><span class="line">driver.find_element_by_xpath(&#x27;//android.widget.EditText[@text=&quot;请输入用户名&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line">driver.find_element_by_xpath(&#x27;//*[@class=&quot;android.widget.EditText&quot;and @index=&quot;3&quot;]&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line">driver.find_element_by_xpath(&#x27;//android.widget.Button&#x27;).click()</span><br></pre></td></tr></table></figure>

<h2 id="五、List定位"><a href="#五、List定位" class="headerlink" title="五、List定位"></a><strong>五、List定位</strong></h2><p>前面我们提到相同的classname属性值元素无法区分定位，现在将使用List定位来解决这个问题。List定位首先是使用find_elements_by_XX 获取一组相同的class属性的元素，然后使用数组下标来区分标记不同元素进行相关操作。</p>
<p><strong>测试案例1</strong></p>
<p>在新用户注册界面点击添加头像按钮后，选择指定的图片保存作为头像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Capability import driver</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()</span><br><span class="line"></span><br><span class="line">images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)</span><br><span class="line">images[2].click()</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click()</span><br></pre></td></tr></table></figure>



<h4 id="list定位综合案例——用户注册"><a href="#list定位综合案例——用户注册" class="headerlink" title="list定位综合案例——用户注册"></a><strong>list定位综合案例——用户注册</strong></h4><h5 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h5><ol>
<li><p>进入注册界面设置头像</p>
</li>
<li><p>输入注册信息：用户名、密码、邮箱</p>
</li>
<li><p>完善院校和专业信息 （院校：上海-同济大学 专业：经济学类-统计学-经济统计学）</p>
</li>
<li><p>完成注册</p>
</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>注意：运行前记得将noRest设置为：desired_caps[‘noReset’]=’False’ 以免之前的注册残留信息干扰。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Capability import driver</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">#进入注册界面选择并设置头像</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_register_text&#x27;).click()</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_userheader&#x27;).click()</span><br><span class="line"></span><br><span class="line">images=driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/item_image&#x27;)</span><br><span class="line"></span><br><span class="line">images[2].click()</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/save&#x27;).click()</span><br><span class="line"></span><br><span class="line">#注册信息填写</span><br><span class="line">username=&#x27;Test&#x27;+&#x27;tt&#x27;+str(random.randint(1000,9000))</span><br><span class="line">print(&#x27;username: %s&#x27; %username)</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_username_edittext&#x27;).send_keys(username)</span><br><span class="line"></span><br><span class="line">password=&#x27;appium&#x27;+str(random.randint(1000,9000))</span><br><span class="line">print(&#x27;password: %s&#x27; %password)</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_password_edittext&#x27;).send_keys(password)</span><br><span class="line"></span><br><span class="line">email=&#x27;pwd&#x27;+str(random.randint(1000,9000))+&#x27;@163.com&#x27;</span><br><span class="line">print(&#x27;email: %s&#x27; %email)</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_email_edittext&#x27;).send_keys(email)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_register_register_btn&#x27;).click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#院校选择</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/perfectinfomation_edit_school_name&#x27;).click()</span><br><span class="line">#选择省份</span><br><span class="line">driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/more_forum_title&#x27;)[1].click()</span><br><span class="line">#选择具体院校--同济大学</span><br><span class="line">driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/university_search_item_name&#x27;)[1].click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#专业选择</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_major&#x27;).click()</span><br><span class="line">#选择经济学类-统计学-经济统计学</span><br><span class="line">driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_subject_title&#x27;)[1].click()</span><br><span class="line">driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_group_title&#x27;)[2].click()</span><br><span class="line">driver.find_elements_by_id(&#x27;com.tal.kaoyan:id/major_search_item_name&#x27;)[1].click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#点击“进入考研帮”按钮</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_perfectinfomation_goBtn&#x27;).click()</span><br></pre></td></tr></table></figure>

<h2 id="六、UIAutomator定位简介"><a href="#六、UIAutomator定位简介" class="headerlink" title="六、UIAutomator定位简介"></a><strong>六、UIAutomator定位简介</strong></h2><p>UIAutomator元素定位是 Android 系统原生支持的定位方式，虽然与 xpath 类似，但比它更加好用，且支持元素全部属性定位.定位原理是通过android 自带的android uiautomator的类库去查找元素。使用法  find_element_by_android_uiautomator() 可以运用UiAutomator元素定位。</p>
<h3 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h3><ul>
<li><p>id定位</p>
</li>
<li><p>text定位</p>
</li>
<li><p>class name定位</p>
</li>
</ul>
<h4 id="id定位"><a href="#id定位" class="headerlink" title="id定位"></a>id定位</h4><p>id定位是根据元素的resource-id属性来进行定位，使用 UiSelector().resourceId()方法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Capability import driver</span><br><span class="line"></span><br><span class="line">driver.find_element_by_android_uiautomator(&#x27;new UiSelector().resourceId(&quot;com.tal.kaoyan:id/login_email_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_android_uiautomator\</span><br><span class="line">    (&#x27;new UiSelector().resourceId(&quot;com.tal.kaoyan:id/login_password_edittext&quot;)&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_android_uiautomator\</span><br><span class="line">    (&#x27;new UiSelector().resourceId(&quot;com.tal.kaoyan:id/login_login_btn&quot;)&#x27;).click()</span><br></pre></td></tr></table></figure>



<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>在自动化过程中，元素出现受网络环境，设备性能等多种因素影响。因此元素加载的时间可能不一致，从而会导致元素无法定位超时报错，但是实际上元素是正常加载了的，只是出现时间晚一点而已。那么如何解决这个问题呢？</p>
<h2 id="七、元素等待作用"><a href="#七、元素等待作用" class="headerlink" title="七、元素等待作用"></a><strong>七、元素等待作用</strong></h2><p>设置元素等待可以更加灵活的制定等待定位元素的时间，从而增强脚本的健壮性，提高执行效率。</p>
<p>元素等待类型分为强制等待、隐式等待、显示等待</p>
<h4 id="强制等待"><a href="#强制等待" class="headerlink" title="强制等待"></a><strong>强制等待</strong></h4><p>设置固定的等待时间，使用sleep()方法即可实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from time import sleep</span><br><span class="line">#强制等待5秒</span><br><span class="line">sleep(5)</span><br></pre></td></tr></table></figure>



<h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a><strong>隐式等待</strong></h4><p>隐式等待是针对全部元素设置的等待时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver.implicitly_wait(20)</span><br></pre></td></tr></table></figure>



<h4 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a><strong>显式等待</strong></h4><p>显式等待是针对某个元素来设置的等待时间。</p>
<p>方法WebDriverWait格式参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line"></span><br><span class="line">WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)</span><br><span class="line">driver : WebDriver</span><br><span class="line">timeout : 最长超时时间，默认以秒为单位</span><br><span class="line">poll_frequency : 休眠时间的间隔时间，默认为0.5秒</span><br><span class="line">ignored_exceptions : 超时后的异常信息，默认情况下抛NoSuchElementException异常。</span><br></pre></td></tr></table></figure>

<p>WebDriverWait()一般和until()或until_not()方法配合使用，另外，lambda提供了一个运行时动态创建函数的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">WebDriverWait(driver,10).until(lambda x:x.find_element_by_id(&quot;elementID&quot;))</span><br></pre></td></tr></table></figure>



<h2 id="八、截图方法"><a href="#八、截图方法" class="headerlink" title="八、截图方法"></a><strong>八、截图方法</strong></h2><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a><strong>方法1</strong></h4><p>save_screenshot() 该方法直接保存当前屏幕截图到当前脚本所在文件位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver.save_screenshot(&#x27;login.png&#x27;)</span><br></pre></td></tr></table></figure>



<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a><strong>方法2</strong></h4><p>get_screenshot_as_file(self, filename)</p>
<p>将截图保留到指定文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;)</span><br></pre></td></tr></table></figure>



<h4 id="测试场景-1"><a href="#测试场景-1" class="headerlink" title="测试场景"></a><strong>测试场景</strong></h4><p>在考研帮App登录页面输入用户名和密码之后截图，分别保存到当前文件和指定的文件路径。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Capability import driver</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).clear()</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line"></span><br><span class="line">driver.save_screenshot(&#x27;login.png&#x27;)</span><br><span class="line">driver.get_screenshot_as_file(&#x27;./images/login.png&#x27;)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click()</span><br></pre></td></tr></table></figure>



<h2 id="九、滑动效果"><a href="#九、滑动效果" class="headerlink" title="九、滑动效果"></a><strong>九、滑动效果</strong></h2><p>在app应用日常使用过程中，会经常用到在屏幕滑动操作。如刷朋友圈上下滑操作、浏览图片左右滑动操作等。在自动化脚本该如何实现这些操作呢？</p>
<p>在Appium中模拟用户滑动操作需要使用swipe方法，该方法定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def swipe(self, start_x, start_y, end_x, end_y, duration=None):</span><br><span class="line">       &quot;&quot;&quot;Swipe from one point to another point, for an optional duration.</span><br><span class="line"></span><br><span class="line">       :Args:</span><br><span class="line">        - start_x - x-coordinate at which to start</span><br><span class="line">        - start_y - y-coordinate at which to start</span><br><span class="line">        - end_x - x-coordinate at which to stop</span><br><span class="line">        - end_y - y-coordinate at which to stop</span><br><span class="line">        - duration - (optional) time to take the swipe, in ms.</span><br><span class="line"></span><br><span class="line">       :Usage:</span><br><span class="line">           driver.swipe(100, 100, 100, 400)</span><br></pre></td></tr></table></figure>

<p>滑动解析</p>
<p>swipe()方法的参数说明：<br>start_x：起始横坐标<br>start_y：起始纵坐标<br>end_x：结束时横坐标<br>end_y：结束时纵坐标<br>duration：滑动持续时间，单位毫秒，默认None（一般设置500-1000毫秒比较合适）</p>
<p>滑动主要分为：</p>
<ol>
<li> 水平滑动</li>
<li> 垂直滑动</li>
<li>任意方向滑动</li>
</ol>
<p>滑动轨迹图如下：</p>
<img src="https://pic.imgdb.cn/item/6137747544eaada7393c3d54.jpg">

<p>实践应用</p>
<h4 id="测试场景-2"><a href="#测试场景-2" class="headerlink" title="测试场景"></a><strong>测试场景</strong></h4><ul>
<li><p>安装启动考研帮，手动向水平左滑动首页引导页面。</p>
</li>
<li><p>点击“立即体验”进入登录页面。</p>
</li>
</ul>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>注意：运行前记得将capablity里面的check_skipBtn()先注释掉，否则直接跳过了无法滑动引导页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from time import sleep</span><br><span class="line">from Capability import driver</span><br><span class="line"></span><br><span class="line">#获取屏幕尺寸</span><br><span class="line">def get_size():</span><br><span class="line">    x=driver.get_window_size()[&#x27;width&#x27;]</span><br><span class="line">    y=driver.get_window_size()[&#x27;height&#x27;]</span><br><span class="line">    return x,y</span><br><span class="line"></span><br><span class="line">#显示屏幕尺寸（width,height）</span><br><span class="line">l=get_size()</span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">#向左滑动</span><br><span class="line">def swipeLeft():</span><br><span class="line">    l=get_size()</span><br><span class="line">    x1=int(l[0]*0.9)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.1)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,1000)</span><br><span class="line"></span><br><span class="line">#向左滑动2次</span><br><span class="line">for i in range(2):</span><br><span class="line">    swipeLeft()</span><br><span class="line">    sleep(0.5)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_splash_guidfinish&#x27;).click()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Appium环境的搭建</title>
    <url>/2021/09/01/Appium%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ul>
<li><p>Node.js</p>
</li>
<li><p>Appium</p>
</li>
<li><p>Appium-desktop</p>
</li>
<li><p>Appium-doctor</p>
</li>
<li><p>Appium-Python-Client</p>
</li>
<li><p>Python</p>
</li>
<li><p>JDK</p>
</li>
<li><p>Andriod SDK</p>
 <span id="more"></span></li>
</ul>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>下载地址：<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入如下命令：</span><br><span class="line">C:\Users\admin&gt;node -v</span><br><span class="line">执行完之后可以看到</span><br><span class="line">v12.18.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行以下命令</span><br><span class="line">C:\Users\admin&gt;npm -v</span><br><span class="line">执行完之后可以看到</span><br><span class="line">6.14.6</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li> npm（node package manage）是node.js安装包管理工具，类似Python中的pip工具。</li>
<li> 如果显示‘npm’不是内部命令提示，则可以管理员省份运行cmd，如果还是失败，则需要检查一下环境变量是否配置，或者重新安装nodejs。</li>
</ul>
<h2 id="Appium-安装"><a href="#Appium-安装" class="headerlink" title="Appium 安装"></a>Appium 安装</h2><p>Appium Server其实可以通过命令 npm install -g appium来安装。不过由于众所周知的网络原因，直接使用这样安装会非常非常慢，甚至会安装失败，所以我们可以使用国内镜像来安装。</p>
<p>选用的镜像是 <a href="https://npm.taobao.org/">淘宝NPM镜像</a></p>
<h4 id="镜像设置"><a href="#镜像设置" class="headerlink" title="镜像设置"></a><strong>镜像设置</strong></h4><p>执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p> 执行完成命令看到如下提示则表示设置完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt; npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">npm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow  and an import issue introduced in 2.1.0</span><br><span class="line"></span><br><span class="line">C:\Users\admin\AppData\Roaming\npm\cnpm -&gt; C:\Users\admin\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm</span><br><span class="line"></span><br><span class="line">\+ cnpm@5.2.0</span><br><span class="line"></span><br><span class="line">added 764 packages in 63.767s</span><br></pre></td></tr></table></figure>



<h4 id="appium-安装"><a href="#appium-安装" class="headerlink" title="appium 安装"></a>appium 安装</h4><p>使用如下命令来执行安装：</p>
<p>安装最新版本</p>
<p>cnpm install -g appium</p>
<p>安装指定版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install appium@1.7.2 -g </span><br></pre></td></tr></table></figure>

<p>看到如下命令时则表示下载安装完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">All packages installed (565 packages installed from npm registry, used 57s, speed 835.67kB/s, json 477(6.16MB), tarball 40.58MB)</span><br><span class="line"></span><br><span class="line">[appium@1.8.0] link C:\Users\admin\AppData\Roaming\npm\appium@ -&gt; C:\Users\admin\AppData\Roaming\npm\node_modules\appium\build\lib\main.js</span><br></pre></td></tr></table></figure>

<p>npm的包安装分为本地安装（local）、全局安装（global）两种，一般我们推荐使用全局安装。</p>
<h4 id="appium配置"><a href="#appium配置" class="headerlink" title="appium配置"></a>appium配置</h4><p>安装完成之后可以使用如下命令查看appium的安装路径</p>
<p>执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;where appium </span><br></pre></td></tr></table></figure>

<p>执行完之后可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\AppData\Roaming\npm\appium</span><br><span class="line">C:\Users\admin\AppData\Roaming\npm\appium.cmd</span><br></pre></td></tr></table></figure>



<h4 id="appium运行"><a href="#appium运行" class="headerlink" title="appium运行"></a>appium运行</h4><p>在控制台输入命令 appium即可启动appium服务，appium -v查看版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令</span><br><span class="line">C:\Users\admin&gt;appium -v</span><br><span class="line"></span><br><span class="line">执行完之后可以看到</span><br><span class="line">1.7.2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令 </span><br><span class="line">C:\Users\admin&gt;appium</span><br><span class="line"></span><br><span class="line">执行完之后可以看到</span><br><span class="line">[Appium] Welcome to Appium v1.7.2</span><br><span class="line">[Appium] Appium REST http interface listener started on 0.0.0.0:4723</span><br></pre></td></tr></table></figure>

<p>如果输入appium后显示：“appium不是内部或外部命令,也不是可运行的程序或批处理文件” 可以将appium安装的路径 如： “C:\Users\admin\AppData\Roaming\npm”配置到系统环境变量Path中</p>
<h4 id="退出appium"><a href="#退出appium" class="headerlink" title="退出appium"></a>退出appium</h4><p>按键 ctrl+c 选择y 即可退出</p>
<h2 id="安装Appium-desktop"><a href="#安装Appium-desktop" class="headerlink" title="安装Appium-desktop"></a>安装Appium-desktop</h2><p>下载地址：<a href="https://github.com/appium/appium-desktop/releases">https://github.com/appium/appium-desktop/releases</a></p>
<p>上面提到的问题可以使用前面我们已经介绍了Appium Server来解决，Appium-desktop工具其实也封装了Appium server和Node.js依赖环境。</p>
<p>appium-desktop是我们初学者最容易上手的工具，后面课程首先会基于这个工具来讲解！然后再基于appium 命令来讲。</p>
<h4 id="python环境安装配置"><a href="#python环境安装配置" class="headerlink" title="python环境安装配置"></a>python环境安装配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装成功之后，执行以下命令 </span><br><span class="line">C:Users admin&gt;python --version</span><br><span class="line"></span><br><span class="line">执行完之后可以看到</span><br><span class="line">Python  3.5.0</span><br></pre></td></tr></table></figure>



<h2 id="安装Appium-Python-Client"><a href="#安装Appium-Python-Client" class="headerlink" title="安装Appium-Python-Client"></a>安装Appium-Python-Client</h2><p>通过命令pip install Appium-Python-Client 进行安装。 安装后可以通过如下命令来检测是否安装成功。</p>
<p>输入命令“from appium import webdriver” 回车，如果控制台没有报错，则说明安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入以下命令</span><br><span class="line">C:\Users\admin&gt;python</span><br><span class="line"></span><br><span class="line">执行完之后可以看到</span><br><span class="line">Python 3.5.0 (v3.5.0:374f501f4567, Sep 13 2015, 02:27:37) [MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">\&gt;&gt;&gt; &lt;u&gt;from appium import webdriver&lt;/u&gt;&lt;!--此处是输入的命令--&gt;</span><br><span class="line"></span><br><span class="line">如果出现如下报错，则说明安装失败</span><br><span class="line">ImportError: No module named &#x27;appium&#x27;</span><br><span class="line">ImportError: cannot import name  “webdriver”</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>装Appium-Python-Client安装后的路径一般为：{Python 安装路径}\Lib\site-packages\appium</p>
<h2 id="JDK安装配置"><a href="#JDK安装配置" class="headerlink" title="JDK安装配置"></a>JDK安装配置</h2><p>jdk下载地址:</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>jdk环境变量配置</p>
<p><a href="http://jingyan.baidu.com/article/624e74599e8ad834e8ba5a94.html">http://jingyan.baidu.com/article/624e74599e8ad834e8ba5a94.html</a></p>
<p>安装配置完成后，打开命令提示符窗口，然后输入如下面命令有对应提示说明安装配置成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入以下命令</span><br><span class="line">C:\Users\admin&gt;java -version</span><br><span class="line"></span><br><span class="line">执行完之后可以看到</span><br><span class="line">java version &quot;1.8.0_05&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_05-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)</span><br></pre></td></tr></table></figure>



<h2 id="Andriod-sdk-安装"><a href="#Andriod-sdk-安装" class="headerlink" title="Andriod sdk 安装"></a>Andriod sdk 安装</h2><p>下载地址： <a href="http://tools.android-studio.org/index.php/sdk">http://tools.android-studio.org/index.php/sdk</a></p>
<p>根据自己的PC平台下载对应版本即可。</p>
<p>安装完成后需要配置环境变量：ANDROID_HOME。</p>
<h2 id="安装-appium-doctor"><a href="#安装-appium-doctor" class="headerlink" title="安装 appium-doctor"></a>安装 appium-doctor</h2><p>appium-doctor可以检测Appium整体依赖环境配置情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入以下命令</span><br><span class="line">C:\Users\admin&gt;cnpm install appium-doctor -g</span><br><span class="line"></span><br><span class="line">输入以下命令，如下提示说明整体环境配置成功</span><br><span class="line">C:\Users\admin&gt;appium-doctor</span><br><span class="line"></span><br><span class="line">info AppiumDoctor Appium Doctor v.1.4.3</span><br><span class="line">info AppiumDoctor ### Diagnostic starting ###</span><br><span class="line">info AppiumDoctor  ✔ The Node.js binary was found at: D:\program files\nodejs\node.exe</span><br><span class="line">info AppiumDoctor  ✔ Node version is 6.11.3</span><br><span class="line">info AppiumDoctor  ✔ ANDROID_HOME is set to: E:\Andriod_sdk</span><br><span class="line">info AppiumDoctor  ✔ JAVA_HOME is set to: C:\Program Files\Java\jdk1.8.0_05</span><br><span class="line">info AppiumDoctor  ✔ adb exists at: E:\Andriod_sdk\platform-tools\adb.exe</span><br><span class="line">info AppiumDoctor  ✔ android exists at: E:\Andriod_sdk\tools\android.bat</span><br><span class="line">info AppiumDoctor  ✔ emulator exists at: E:\Andriod_sdk\tools\emulator.exe</span><br><span class="line">info AppiumDoctor  ✔ Bin directory of %JAVA_HOME% is set</span><br><span class="line">info AppiumDoctor ### Diagnostic completed, no fix needed. ###</span><br><span class="line">info AppiumDoctor</span><br><span class="line">info AppiumDoctor Everything looks good, bye!</span><br><span class="line">info AppiumDoctor</span><br></pre></td></tr></table></figure>



<p>如果上面某一项显示为“X”则说明相关环境没有配置好，需要重新安装配置。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p><a href="https://testerhome.com/topics/13146">https://testerhome.com/topics/13146</a></p>
]]></content>
  </entry>
  <entry>
    <title>Appium的元素定位入门</title>
    <url>/2021/09/07/Appium%E7%9A%84%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>与Web自动化测试一样，app自动化测试过程中最重要一个环节就是元素定位，只有准确定位到了元素才能进行相关元素的操作，如输入、点击、拖拽、滑动等。</p>
<p>appium提供了许多元素定位的方法，如id定位、name定位、class定位、层级定位等等.<span id="more"></span></p>
<h2 id="一、元素定位方式"><a href="#一、元素定位方式" class="headerlink" title="一、元素定位方式"></a><strong>一、元素定位方式</strong></h2><ol>
<li><p>id</p>
</li>
<li><p>name</p>
</li>
<li><p>class</p>
</li>
<li><p>List定位</p>
</li>
<li><p>相对定位</p>
</li>
<li><p>Xpath定位</p>
</li>
<li><p>H5页面元素定位</p>
</li>
<li><p>Uiautomator定位</p>
</li>
</ol>
<h2 id="二、id定位"><a href="#二、id定位" class="headerlink" title="二、id定位"></a><strong>二、id定位</strong></h2><p>Appium中可以使用 **find_element_by_id()**方法来进行id定位。</p>
<h3 id="1-测试场景"><a href="#1-测试场景" class="headerlink" title="1) 测试场景"></a><strong>1)</strong> <strong>测试场景</strong></h3><ol>
<li><p>安装考研帮kaoyan3.1.0.apk</p>
</li>
<li><p>点击升级页面取消按钮</p>
</li>
<li><p>点击引导页面的跳过按钮</p>
</li>
</ol>
<h3 id="2-脚本实现"><a href="#2-脚本实现" class="headerlink" title="2) 脚本实现"></a><strong>2)</strong> <strong>脚本实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from  appium import webdriver</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;</span><br><span class="line">desired_caps[&#x27;platforVersion&#x27;]=&#x27;5.1.1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=r&#x27;D:\kaoyan3.1.0.apk&#x27;</span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;</span><br><span class="line"></span><br><span class="line">driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)</span><br><span class="line">driver.implicitly_wait(5)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;android:id/button2&#x27;).click()</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;).click()</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、思考"><a href="#三、思考" class="headerlink" title="三、思考"></a><strong>三、思考</strong></h2><ul>
<li>如果安装的版本最新的包，或者升级到了最新的版本，则启动后没有升级弹窗元素该如何处理？</li>
<li> 跳过引导页面首次启动和非首次启动场景该如何处理？</li>
</ul>
<h3 id="方案探索1——if条件判断"><a href="#方案探索1——if条件判断" class="headerlink" title="方案探索1——if条件判断"></a><strong>方案探索1——if条件判断</strong></h3><p>你可能想到用if来做条件判断？判断元素是否存在，存在则点击，不存在则跳过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from  appium import webdriver</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;</span><br><span class="line">desired_caps[&#x27;platforVersion&#x27;]=&#x27;7.1.2&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=r&#x27;D:\kaoyan3.1.0.apk&#x27;</span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=&#x27;True&#x27;</span><br><span class="line"></span><br><span class="line">driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)</span><br><span class="line">driver.implicitly_wait(5)</span><br><span class="line">cancelBtn=driver.find_element_by_id(&#x27;android:id/button2&#x27;)</span><br><span class="line">skipBtn=driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line"></span><br><span class="line">if cancelBtn:</span><br><span class="line">    cancelBtn.click()</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;no cancelBtn&#x27;)</span><br><span class="line"></span><br><span class="line">if skipBtn:</span><br><span class="line">    skipBtn.click()</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;no skipBtn&#x27;)</span><br></pre></td></tr></table></figure>



<p>定位不到元素：</p>
<p>报异常：</p>
<p>selenium.common.exceptions.NoSuchElementException: Message: An element could not be located on the page using the given search parameters.</p>
<h3 id="方案探索2——异常捕捉"><a href="#方案探索2——异常捕捉" class="headerlink" title="方案探索2——异常捕捉"></a>方案探索2——异常捕捉</h3><p>既然上面的if语句判断无法生效，但是我们发现一个突破口，那就是捕捉NoSuchElementException异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from  appium import webdriver</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;</span><br><span class="line">desired_caps[&#x27;platforVersion&#x27;]=&#x27;7.1.2&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=r&#x27;d:\kaoyan3.1.0.apk&#x27;</span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=&#x27;True&#x27;</span><br><span class="line"></span><br><span class="line">driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)</span><br><span class="line">driver.implicitly_wait(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_cancelBtn():</span><br><span class="line">    print(&quot;check_cancelBtn&quot;)</span><br><span class="line">    try:</span><br><span class="line">        cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        print(&#x27;no CancelBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        cancelBtn.click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_skipBtn():</span><br><span class="line">    print(&quot;check_skipBtn&quot;)</span><br><span class="line">    try:</span><br><span class="line">        skipBtn = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        print(&#x27;check_skipBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        skipBtn.click()</span><br><span class="line"></span><br><span class="line">check_updateBtn()</span><br><span class="line">check_skipBtn()</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四、id定位综合实践——自动登录"><a href="#四、id定位综合实践——自动登录" class="headerlink" title="四、id定位综合实践——自动登录"></a><strong>四、id定位综合实践——自动登录</strong></h2><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a><strong>测试场景</strong></h3><ol>
<li><p>启动App，进入到登录界面</p>
</li>
<li><p>在登录页面输入用户名“xxxxxx”，密码‘xxxxxx’ 然后点击登录。</p>
</li>
</ol>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h3><ol>
<li><p>可以把启动后检测升级弹窗和引导页面的模块抽离作为独立的模块被其他模块调用，提高代码复用率。</p>
</li>
<li><p>获取用户名密码输入框和登录按钮的元素id属性,另外要考虑启动时App之前是否登录过账号，已经登录过和未登录场景流程不一样。</p>
</li>
<li><p>注意：send_keys()传入中文时需要在capability中配置如下内容：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desired_caps[&#x27;unicodeKeyboard&#x27;]=&quot;True&quot;</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;resetKeyboard&#x27;]=&quot;True&quot;</span><br></pre></td></tr></table></figure>

<p>设置之后会有Appium的输入法守护来执行输入操作</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from  appium import webdriver</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=&#x27;Android&#x27;</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=&#x27;127.0.0.1:62025&#x27;</span><br><span class="line">desired_caps[&#x27;platforVersion&#x27;]=&#x27;7.1.2&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=r&#x27;d:\kaoyan3.1.0.apk&#x27;</span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=&#x27;com.tal.kaoyan&#x27;</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=&#x27;True&#x27;</span><br><span class="line"></span><br><span class="line">driver=webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;,desired_caps)</span><br><span class="line">driver.implicitly_wait(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_cancelBtn():</span><br><span class="line">    print(&quot;check_cancelBtn&quot;)</span><br><span class="line">    try:</span><br><span class="line">        cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        print(&#x27;no CancelBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        cancelBtn.click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_skipBtn():</span><br><span class="line">    print(&quot;check_skipBtn&quot;)</span><br><span class="line">    try:</span><br><span class="line">        skipBtn = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        print(&#x27;check_skipBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        skipBtn.click()</span><br><span class="line"></span><br><span class="line">#check_updateBtn()</span><br><span class="line"></span><br><span class="line">check_skipBtn()</span><br><span class="line"></span><br><span class="line">def login():</span><br><span class="line">    driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).clear()</span><br><span class="line">    driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;xxxxxx&#x27;)</span><br><span class="line"></span><br><span class="line">    driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;xxxxxx&#x27;)</span><br><span class="line">    driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click()</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    driver.find_element_by_id(&#x27;com.tal.kaoyan:id/mainactivity_button_mysefl&#x27;)</span><br><span class="line">except NoSuchElementException:</span><br><span class="line">    login()</span><br><span class="line">else:</span><br><span class="line">    driver.find_element_by_id(&#x27;com.tal.kaoyan:id/mainactivity_button_mysefl&#x27;).click()</span><br><span class="line">    driver.find_element_by_id(&#x27;com.tal.kaoyan:id/activity_usercenter_username&#x27;).click()</span><br><span class="line">    login()</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>使用Appium做了输入操作之后，如果出现输入法无法唤起，可以在系统设置——语言和输入法——将当前输入法替换为系统输入法或者其他输入法。</p>
]]></content>
  </entry>
  <entry>
    <title>Appium简介</title>
    <url>/2021/09/07/Appium%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="一-Appium简介"><a href="#一-Appium简介" class="headerlink" title="一.Appium简介"></a><strong>一.Appium简介</strong></h1><p>Appium is an open source test automation framework for use with native, hybrid and mobile web apps. It drives iOS, Android, and Windows apps using the WebDriver protocol.</p>
<p>Appium是一个开源测试自动化框架，可用于原生，混合和移动Web应用程序测试。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。<span id="more"></span></p>
<ul>
<li><p><a href="http://appium.io/">Appium官网</a></p>
</li>
<li><p><a href="https://github.com/appium?utf8=%E2%9C%93&q=&type=source&language=">Appium github主页</a></p>
</li>
<li><p><a href="http://appium.io/docs/cn/about-appium/intro/">官方中文文档</a></p>
</li>
<li><p> <a href="http://discuss.appium.io/latest">Appium官方论坛</a></p>
</li>
<li><p> <a href="https://testerhome.com/">Testerhome中文社区</a></p>
</li>
</ul>
<h1 id="二-Appium优势"><a href="#二-Appium优势" class="headerlink" title="二.Appium优势"></a>二.Appium优势</h1><ul>
<li><p>可以跨平台同时支持android、ios</p>
</li>
<li><p>支持多种语言，java、python、php、Ruby等等</p>
</li>
<li><p>不用为复杂的环境发愁</p>
</li>
<li><p> 如果你有selenium经验，直接上手。</p>
</li>
</ul>
<h2 id="Appium架构原理"><a href="#Appium架构原理" class="headerlink" title="Appium架构原理"></a>Appium架构原理</h2><ul>
<li><p>Appium是在手机操作系统自带的测试框架基础上实现的，Android和iOS的系统上使用的工具分别如下：</p>
</li>
<li><p>Android（版本&gt;4.3）：UIAutomator，Android 4.3之后系统自带的UI自动化测试工具。</p>
</li>
<li><p>Android（版本≤4.3）：Selendroid，基于Android Instrumentation框架实现的自动化测试工具。</p>
</li>
<li><p>iOS：UIAutomation（instruments框架里面的一个模板），iOS系统自带的UI自动化测试工具。 </p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/61376a0144eaada739210646.jpg" alt="https://pic.imgdb.cn/item/61376a0144eaada739210646.jpg"></p>
<h5 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a><strong>运行原理</strong></h5><p>我们的电脑（client）上运行自动化测试脚本，调用的是webdriver的接口，appium server接收到我们client上发送过来的命令后他会将这些命令转换为UIautomator认识的命令，然后由UIautomator来在设备上执行自动化。</p>
<p>Appium的架构原理如上图所示，由客户端（Appium Client）和服务器（Appium Server）两部分组成，客户端与服务器端通过JSON Wire Protocol进行通信。</p>
<h5 id="Appium服务器"><a href="#Appium服务器" class="headerlink" title="Appium服务器"></a><strong>Appium服务器</strong></h5><p>Appium服务器是Appium框架的核心。它是一个基于Node.js实现的HTTP服务器。Appium服务器的主要功能是接受从Appium客户端发起的连接，监听从客户端发送来的命令，将命令发送给bootstrap.jar（iOS手机为bootstrap.js）执行，并将命令的执行结果通过HTTP应答反馈给Appium客户端。</p>
<h5 id="Bootstrap-jar"><a href="#Bootstrap-jar" class="headerlink" title="Bootstrap.jar"></a><strong>Bootstrap.jar</strong></h5><p>Bootstrap.jar是在Android手机上运行的一个应用程序，它在手机上扮演TCP服务器的角色。当Appium服务器需要运行命令时，Appium服务器会与Bootstrap.jar建立TCP通信，并把命令发送给Bootstrap.jar；Bootstrap.jar负责运行测试命令。</p>
<h5 id="Appium客户端"><a href="#Appium客户端" class="headerlink" title="Appium客户端"></a><strong>Appium客户端</strong></h5><p>它主要是指实现了Appium功能的WebDriver协议的客户端Library，它负责与Appium服务器建立连接，并将测试脚本的指令发送到Appium服务器。现有的客户端Library有多种语言的实现，包括Ruby、Python、Java、JavaScript（Node.js）、Object C、PHP和C#。Appium的测试是在这些Library的基础上进行开发的。</p>
<h2 id="三-Appium组件"><a href="#三-Appium组件" class="headerlink" title="三.Appium组件"></a>三.Appium组件</h2><h4 id="Appium-Server"><a href="#Appium-Server" class="headerlink" title="Appium Server"></a><strong>Appium Server</strong></h4><p>Appium Server就是Appium的服务端——一个web接口服务，使用Node.js实现。引用官网解释说明。</p>
<p>Appium is a server written in Node.js. It can be built and installed from source or installed directly from NPM:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$npm install -g appium</span><br><span class="line"></span><br><span class="line">$appium</span><br></pre></td></tr></table></figure>



<h4 id="Appium-Desktop"><a href="#Appium-Desktop" class="headerlink" title="Appium Desktop"></a><strong>Appium Desktop</strong></h4><p>Appium Desktop是一款适用于Mac，Windows和Linux的开源应用程序，它以美观而灵活的用户界面为您提供Appium自动化服务器的强大功能。 它是几个Appium相关工具的组合：</p>
<ol>
<li><p>Appium Server的图形界面。 您可以设置选项，启动/停止服务器，查看日志等…您也不需要使用Node 的NPM来安装Appium，因为Node运行时与Appium Desktop捆绑在一起。</p>
</li>
<li><p>您可以使用Inspector查看应用程序的元素，获取有关它们的基本信息，并与它们进行基本的交互。</p>
</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/61376a4d44eaada7392200e1.jpg" alt="https://pic.imgdb.cn/item/61376a4d44eaada7392200e1.jpg"> </p>
<p><img src="https://pic.imgdb.cn/item/61376a8944eaada73922bfac.jpg" alt="https://pic.imgdb.cn/item/61376a8944eaada73922bfac.jpg"> </p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h5><p>Appium Desktop与Appium不同。 Appium Desktop是Appium的图形前端，带有其他工具。 Appium Desktop以其自己的节奏发布，并拥有自己的版本控制系统。 就像国内很多定制的Android系统有自己版本号，但是都是基于一个Android系统版本封装的。版本号不一定与Andriod原生系统版本号一致。如：魅族的flyme6.0系统的内核是Android 5.1</p>
<h4 id="Appium-GUI"><a href="#Appium-GUI" class="headerlink" title="Appium GUI"></a><strong>Appium GUI</strong></h4><p>Appium GUI是Appium desktop的前身。 这个也是把Appium server封装成了一个图形界面，降低使用门槛，如同最初的操作系统Dos都是敲命令，后面都是图形界面操作系统，如Windows系统。很多初学者对下面这个界面应该不陌生吧，这个就是Windows版本的Appium GUI界面。测试人员可以手动启动，配置相关server 服务，如果不用这个启动的话，需要命令启动服务。AppiumForWindows_1_4_16_1.zip之后就停止更新了。目前版本可以使用，但是封装的不是最新的Appium版本，而是1.4.16版本。如果要使用最新的桌面版需要使用Appium Desktop。</p>
<p><a href="https://bitbucket.org/appium/appium.app/downloads/">历史版本下载</a></p>
<p> <img src="https://pic.imgdb.cn/item/61376ab044eaada7392346b7.jpg" alt="https://pic.imgdb.cn/item/61376ab044eaada7392346b7.jpg"></p>
<h4 id="Appium-Clients"><a href="#Appium-Clients" class="headerlink" title="Appium Clients"></a><strong>Appium Clients</strong></h4><p>因为Appium是一个C/S结构，有了服务端的肯定还有客户端，Appium Clients就是客户端，它会给服务端Appium Server发送请求会话来执行自动化任务。就像我们浏览器访问网页，浏览器是客户端，通过操作发送请求服务器来获取数据。我们可以使用不同的客户端浏览器（IE，Firefox,Chrome）访问一个网站。 Appium客户端可以使用不同的语言来实现，如Python，java等。具体详见下表：</p>
<table>
<thead>
<tr>
<th>Language/Framework</th>
<th>Github Repo and Installation Instructions</th>
</tr>
</thead>
<tbody><tr>
<td>Ruby</td>
<td><a href="https://github.com/appium/ruby_lib">https://github.com/appium/ruby_lib</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/appium/python-client">https://github.com/appium/python-client</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href="https://github.com/appium/java-client">https://github.com/appium/java-client</a></td>
</tr>
<tr>
<td>JavaScript (Node.js)</td>
<td><a href="https://github.com/admc/wd">https://github.com/admc/wd</a></td>
</tr>
<tr>
<td>Objective C</td>
<td><a href="https://github.com/appium/selenium-objective-c">https://github.com/appium/selenium-objective-c</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/appium/php-client">https://github.com/appium/php-client</a></td>
</tr>
<tr>
<td>C# (.NET)</td>
<td><a href="https://github.com/appium/appium-dotnet-driver">https://github.com/appium/appium-dotnet-driver</a></td>
</tr>
<tr>
<td>RobotFramework</td>
<td><a href="https://github.com/jollychang/robotframework-appiumlibrary">https://github.com/jollychang/robotframework-appiumlibrary</a></td>
</tr>
</tbody></table>
<h4 id="Appium-desktop"><a href="#Appium-desktop" class="headerlink" title="Appium-desktop"></a>Appium-desktop</h4><p>Appium-desktop主界面包含三个菜单Simple,Advanced、Presets</p>
<h2 id="四-Simple"><a href="#四-Simple" class="headerlink" title="四.Simple"></a>四.Simple</h2><h4 id="host"><a href="#host" class="headerlink" title="host"></a><strong>host</strong></h4><p>设置Appium server的ip地址，本地调试可以将ip地址修改为127.0.0.1</p>
<h4 id="port"><a href="#port" class="headerlink" title="port"></a><strong>port</strong></h4><p>设置端口号，默认是4723不用修改</p>
<h4 id="start-server"><a href="#start-server" class="headerlink" title="start server"></a><strong>start server</strong></h4><p>启动 Appium server</p>
<p><img src="https://pic.imgdb.cn/item/61376ace44eaada73923a4c0.jpg" alt="https://pic.imgdb.cn/item/61376ace44eaada73923a4c0.jpg"> </p>
<h2 id="五-Advanced"><a href="#五-Advanced" class="headerlink" title="五.Advanced"></a>五.Advanced</h2><p>高级参数配置修改，主要是一些Android和iOS设备，log路径等相关信息的配置。</p>
<p><img src="https://pic.imgdb.cn/item/61376aea44eaada73923f7db.jpg" alt="https://pic.imgdb.cn/item/61376aea44eaada73923f7db.jpg"> </p>
<p><img src="https://pic.imgdb.cn/item/61376b0044eaada7392436ee.jpg" alt="https://pic.imgdb.cn/item/61376b0044eaada7392436ee.jpg"></p>
<h2 id="六-presets"><a href="#六-presets" class="headerlink" title="六.presets"></a>六.presets</h2><p>将Advanced中的一些配置信息作为预设配置。</p>
<h2 id="七-启动Appium"><a href="#七-启动Appium" class="headerlink" title="七.启动Appium"></a>七.启动Appium</h2><p>启动后控制台提示如下信息，表示Appium启动成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Appium] Welcome to Appium v1.7.2</span><br><span class="line">[Appium] Non-default server args:</span><br><span class="line">[Appium]   address: 127.0.0.1</span><br><span class="line">[Appium] Appium REST http interface listener started on 127.0.0.1:4723</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/61376b1844eaada739247a92.jpg">

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><p><a href="https://github.com/appium/appium-desktop">https://github.com/appium/appium-desktop</a></p>
]]></content>
  </entry>
  <entry>
    <title>Package与Activity的认识</title>
    <url>/2021/09/07/Package%E4%B8%8EActivity%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h4 id="Package"><a href="#Package" class="headerlink" title="Package"></a><strong>Package</strong></h4><p>Package 包。只是在我们的app中这个Package是唯一的，就像你身份证号码一样。在我们做app自动化时，我们就需要知道他的Package，我们知道了Package那么也就知道我们需要对哪个app做自动化。 注意和.apk文件包名不同。<span id="more"></span></p>
<h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a><strong>Activity</strong></h4><p>Android中，activity是所有程序的根本，所有程序的流程都运行在activity之中，activity可以算是开发者遇到的最频繁，也是android当中最基本的模块之一。在android的程序中，activity一般代表手机屏幕的一屏。如果把手机比作一个浏览器，那么activity就相当于一个网页。在activity当中可以添加一些Button、Checkbox等控件，可以看到activity概念和网页的概念相当类似。</p>
<p>一般一个android应用是由多个activity组成的，这多个activity之间可以进行相互跳转。例如，按下一个Button按钮后，可能会跳转到其他的activity，与网页跳转稍微有点不一样的是，activity之间的跳转有可能返回值。</p>
<p>Tips：activity的生命周期：即“产生、运行、销毁”，但是这其中会调用许多方法onCreate（创建） 、onStart（激活） 、onResume（恢复） 、onPause（暂停） 、onStop（停止） 、onDestroy（销毁） 、onRestart（重启）。</p>
<h4 id="Activity获取"><a href="#Activity获取" class="headerlink" title="Activity获取"></a><strong>Activity获取</strong></h4><p>研发提供</p>
<h5 id="aapt"><a href="#aapt" class="headerlink" title="aapt"></a><strong>aapt</strong></h5><p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件。获取命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aapt dump badging xxxx.apk</span><br><span class="line">aapt dump badging xxxx.apk | find &quot;launchable-activity&quot;</span><br></pre></td></tr></table></figure>

<p>可以把appt配置到环境变量（系统变量中的Path），这样运行便捷一些，appt路径：\Andriod_SDK\build-tools{version}</p>
<h4 id="Activity页面布局元素"><a href="#Activity页面布局元素" class="headerlink" title="Activity页面布局元素"></a><strong>Activity页面布局元素</strong></h4><h5 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a><strong>FrameLayout</strong></h5><p>FrameLayout是最简单的布局了。所有放在布局里的控件，都按照层次堆叠在屏幕的左上角。后加进来的控件覆盖前面的控件。</p>
<h5 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a><strong>LinearLayout</strong></h5><p>LinearLayout按照垂直或者水平的顺序依次排列子元素，每一个子元素都位于前一个元素之后。如果是垂直排列，那么将是一个N行单列的结构，每一行只会有一个元素，而不论这个元素的宽度为多少；如果是水平排列，那么将是一个单行N列的结构。如果搭建两行两列的结构，通常的方式是先垂直排列两个元素，每一个元素里再包含一个LinearLayout进行水平排列。</p>
<h5 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a><strong>RelativeLayout</strong></h5><p>RelativeLayout相对布局允许子元素指定它们相对于其父元素或兄弟元素的位置，这是实际布局中最常用的布局方式之一。</p>
<h5 id="AbsoluteLayout"><a href="#AbsoluteLayout" class="headerlink" title="AbsoluteLayout"></a><strong>AbsoluteLayout</strong></h5><p>AbsoluteLayout是绝对位置布局。在此布局中的子元素的android:layout_x和android:layout_y属性将生效，用于描述该子元素的坐标位置。屏幕左上角为坐标原点（0,0），第一个0代表横坐标，向右移动此值增大，第二个0代表纵坐标，向下移动，此值增大。在此布局中的子元素可以相互重叠。在实际开发中，通常不采用此布局格式，</p>
<h5 id="TableLayout"><a href="#TableLayout" class="headerlink" title="TableLayout"></a><strong>TableLayout</strong></h5><p>TableLayout 为表格布局，适用于N行N列的布局格式。一个TableLayout由许多TableRow组成，一个TableRow就代表TableLayout中的一行。</p>
<h5 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a><strong>TextView</strong></h5><p>通常用于显示文字用的。</p>
<h5 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a><strong>ImageView</strong></h5><p>通常用于显示图片用的。</p>
<p>参考资料：<a href="http://www.xuebuyuan.com/1975042.html">http://www.xuebuyuan.com/1975042.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>adb命令</title>
    <url>/2021/09/05/adb%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="一、Android-调试桥"><a href="#一、Android-调试桥" class="headerlink" title="一、Android 调试桥"></a><strong>一、Android 调试桥</strong></h1><p>adb ( Android Debug Bridge)是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用。</p>
 <span id="more"></span>

<h1 id="二、adb-的工作原理"><a href="#二、adb-的工作原理" class="headerlink" title="二、adb 的工作原理"></a><strong>二、adb 的工作原理</strong></h1><p>启动一个 adb 客户端时，此客户端首先检查是否有已运行的 adb 服务器进程。如果没有，它将启动服务器进程。当服务器启动时，它与本地 TCP 端口 5037 绑定，并侦听从 adb 客户端发送的命令—所有 adb 客户端均使用端口 5037 与 adb 服务器通信</p>
<h1 id="三、adb常用命令"><a href="#三、adb常用命令" class="headerlink" title="三、adb常用命令"></a><strong>三、adb常用命令</strong></h1><h3 id="查看adb版本"><a href="#查看adb版本" class="headerlink" title="查看adb版本"></a><strong>查看adb版本</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb  version</span><br></pre></td></tr></table></figure>

<h3 id="连接夜神模拟器"><a href="#连接夜神模拟器" class="headerlink" title="连接夜神模拟器"></a><strong>连接夜神模拟器</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb connect 127.0.0.1:62001</span><br></pre></td></tr></table></figure>

<p>连接自己的安卓手机查看下方的链接：</p>
<p><a href="https://blog.csdn.net/qq_39969226/article/details/87897863">https://blog.csdn.net/qq_39969226/article/details/87897863</a></p>
<p> 夜神模拟器的端口是规律的，第一个模拟器端口是62001，第二个模拟器端口是62025，第三个是62025+1，依此类推。</p>
<h3 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a><strong>查看设备信息</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb devices </span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/61376e4f44eaada7392d1d13.jpg">

<p>如果出现如下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb server version (31) doesn&#x27;t match this client (36); killing...</span><br></pre></td></tr></table></figure>

<ul>
<li>原因： adb版本不对 ,Androd SDK的版本和模拟器的adb版本不一致</li>
<li> 解决方案：将Android SDK的 adb替换掉模拟器的adb即可。模拟器adb路径 ：{安装Path}\Nox\bin</li>
</ul>
<h3 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a><strong>adb shell</strong></h3><p>android 设备底层是 linux 系统，所以连接上设备，也可以在adb命令行中操作对应的Linux指令。</p>
<p> shell 是 linux 系统的字符交互界面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">#进入指定设备shell</span><br><span class="line">adb  -s 127.0.0.1:62001 shell</span><br><span class="line"></span><br><span class="line">#退出adb shell</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>进入adb shell后有两种状态显示：#代表有root权限，$代表没有root权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@android:/ #</span><br><span class="line"></span><br><span class="line">shell@mx4:/ $</span><br></pre></td></tr></table></figure>

<p><strong>root知识小科普</strong></p>
<p>“To err is human, but to really foul up everything, you need root password.”</p>
<p>“人非圣贤孰能无过，但是拥有root密码就真的万劫不复了。”</p>
<p>root用户是系统中唯一的超级管理员，它具有等同于操作系统的权限。一些需要root权限的应用，譬如广告阻挡，卸载系统预装App是需要root权限的。</p>
<h4 id="Adb相关命令参考"><a href="#Adb相关命令参考" class="headerlink" title="Adb相关命令参考"></a><strong>Adb相关命令参考</strong></h4><p> 下面的命令在连接夜神模拟器之后进行操作</p>
<p> 命令参考夜神模拟器官网</p>
<p><a href="https://www.yeshen.com/faqs/H15tDZ6YW">https://www.yeshen.com/faqs/H15tDZ6YW</a></p>
<h5 id="1、如何把电脑上的文件或文件夹传到模拟器里面？"><a href="#1、如何把电脑上的文件或文件夹传到模拟器里面？" class="headerlink" title="1、如何把电脑上的文件或文件夹传到模拟器里面？"></a><strong>1</strong>、如何把电脑上的文件或文件夹传到模拟器里面？</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push D:/sex.avi /mnt/avi/ </span><br></pre></td></tr></table></figure>

<h5 id="2、如何把模拟器里面的文件或文件夹传到电脑上？"><a href="#2、如何把模拟器里面的文件或文件夹传到电脑上？" class="headerlink" title="2、如何把模拟器里面的文件或文件夹传到电脑上？"></a><strong>2</strong>、如何把模拟器里面的文件或文件夹传到电脑上？</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /mnt/avi/sex.avi D:/avi/</span><br></pre></td></tr></table></figure>

<h5 id="3、安装APK"><a href="#3、安装APK" class="headerlink" title="3、安装APK"></a><strong>3</strong>、安装APK</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install d:\\qq.apk</span><br></pre></td></tr></table></figure>

<p>安装报错参考：</p>
<p><a href="https://www.cnblogs.com/lxs1314/p/6214154.html">https://www.cnblogs.com/lxs1314/p/6214154.html</a></p>
<h5 id="4、卸载APK"><a href="#4、卸载APK" class="headerlink" title="4、卸载APK"></a><strong>4</strong>、卸载APK</h5><p>adb uninstall 包名</p>
<p>比如卸载QQ：adb uninstall com.tencent.mobileqq</p>
<h5 id="5、PM包命令"><a href="#5、PM包命令" class="headerlink" title="5、PM包命令"></a><strong>5</strong>、PM包命令</h5><h6 id="1）获取模拟器所有包名"><a href="#1）获取模拟器所有包名" class="headerlink" title="1）获取模拟器所有包名"></a>1）获取模拟器所有包名</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>

<h6 id="2）获取模拟器所有包名并且包括APK路径"><a href="#2）获取模拟器所有包名并且包括APK路径" class="headerlink" title="2）获取模拟器所有包名并且包括APK路径"></a>2）获取模拟器所有包名并且包括APK路径</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -f</span><br></pre></td></tr></table></figure>

<h6 id="3）获取包名对应的APK路径"><a href="#3）获取包名对应的APK路径" class="headerlink" title="3）获取包名对应的APK路径"></a>3）获取包名对应的APK路径</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm path packageName</span><br></pre></td></tr></table></figure>

<h6 id="4）清理应用数据"><a href="#4）清理应用数据" class="headerlink" title="4）清理应用数据"></a>4）清理应用数据</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm clear packageName</span><br></pre></td></tr></table></figure>

<h5 id="6、启动应用"><a href="#6、启动应用" class="headerlink" title="6、启动应用"></a>6、启动应用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -n 包名/Activity类名</span><br></pre></td></tr></table></figure>

<p> 例子：启动应用宝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -n </span><br><span class="line"></span><br><span class="line">com.tencent.android.qqdownloader/com.tencent.assistant.activity.SplashActivity</span><br></pre></td></tr></table></figure>

<p>  例子：指定模拟器启动动应用宝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb -s 127.0.0.1:5555 shell am start -n </span><br><span class="line"></span><br><span class="line">com.tencent.android.qqdownloader/com.tencent.assistant.activity.SplashActivity</span><br></pre></td></tr></table></figure>

<h5 id="7、关闭应用"><a href="#7、关闭应用" class="headerlink" title="7、关闭应用"></a><strong>7</strong>、关闭应用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop 包名</span><br></pre></td></tr></table></figure>

<h5 id="8、模拟输入"><a href="#8、模拟输入" class="headerlink" title="8、模拟输入"></a><strong>8</strong>、模拟输入</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input text 字符串(不支持中文)</span><br></pre></td></tr></table></figure>

<h5 id="9、模拟按键"><a href="#9、模拟按键" class="headerlink" title="9、模拟按键"></a><strong>9</strong>、模拟按键</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 键值</span><br></pre></td></tr></table></figure>

<h5 id="10、模拟鼠标点击"><a href="#10、模拟鼠标点击" class="headerlink" title="10、模拟鼠标点击"></a>10、模拟鼠标点击</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input tap X Y</span><br></pre></td></tr></table></figure>

<h5 id="11、模拟鼠标滑动"><a href="#11、模拟鼠标滑动" class="headerlink" title="11、模拟鼠标滑动"></a>11、模拟鼠标滑动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input swipe X1 Y1 X2 Y2</span><br></pre></td></tr></table></figure>

<h5 id="12、截屏"><a href="#12、截屏" class="headerlink" title="12、截屏"></a>12、截屏</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/screencap.png</span><br></pre></td></tr></table></figure>

<h5 id="13、设置手机IMEI-IMSI-手机号-SIM卡序列号"><a href="#13、设置手机IMEI-IMSI-手机号-SIM卡序列号" class="headerlink" title="13、设置手机IMEI/IMSI/手机号/SIM卡序列号"></a>13、设置手机IMEI/IMSI/手机号/SIM卡序列号</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell setprop persist.nox.modem.imei 352462010682470</span><br><span class="line"></span><br><span class="line">adb shell setprop persist.nox.modem.imsi 460000000000000</span><br><span class="line"></span><br><span class="line">adb shell setprop persist.nox.modem.phonumber 15605569000</span><br><span class="line"></span><br><span class="line">adb shell setprop persist.nox.modem.serial 89860000000000000000</span><br></pre></td></tr></table></figure>

<h5 id="14、nox-adb-shell进去然后执行下面的命令修改经纬度"><a href="#14、nox-adb-shell进去然后执行下面的命令修改经纬度" class="headerlink" title="14、nox_adb shell进去然后执行下面的命令修改经纬度"></a>14、nox_adb shell进去然后执行下面的命令修改经纬度</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setprop persist.nox.gps.latitude xxx</span><br><span class="line"></span><br><span class="line">setprop persist.nox.gps.longitude xxx </span><br></pre></td></tr></table></figure>

<h5 id="15、修改mac地址"><a href="#15、修改mac地址" class="headerlink" title="15、修改mac地址"></a>15、修改mac地址</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setprop persist.nox.wifimac xxx            修改mac地址</span><br><span class="line"></span><br><span class="line">setprop persist.nox.modem.phonumber 138111111111     手机号，生成一个随机11位数字</span><br><span class="line"></span><br><span class="line">setprop persist.nox.model ABC001            手机型号，英文加数字随机</span><br><span class="line"></span><br><span class="line">setprop persist.nox.manufacturer XiaoMi        手机制造商英文随机</span><br><span class="line"></span><br><span class="line">setprop persist.nox.brand Mi             手机品牌英文随机 </span><br></pre></td></tr></table></figure>

<h5 id="16、adb-logcat"><a href="#16、adb-logcat" class="headerlink" title="16、adb logcat"></a>16、adb logcat</h5><p>打印log信息</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>adb logcat</td>
<td>打印log</td>
<td>/</td>
</tr>
<tr>
<td>adb logcat -c</td>
<td>清除手机的log buffer</td>
<td>有些手机权限控制, 不支持.</td>
</tr>
<tr>
<td>adb logcat -b <buffer></td>
<td>打印指定buffer的log信息</td>
<td>buffer有: main(主log区,默认), events(事件相关的log), radio(射频, telephony相关的log)</td>
</tr>
<tr>
<td>adb logcat -v <format></td>
<td>格式化输出log</td>
<td>常用的用adb logcat -v time显示时间</td>
</tr>
<tr>
<td>adb logcat -f <filename></td>
<td>输出log到指定文件</td>
<td></td>
</tr>
</tbody></table>
<h5 id="17、adb-start-kill-server"><a href="#17、adb-start-kill-server" class="headerlink" title="17、adb start/kill-server"></a>17、adb start/kill-server</h5><p>启动/杀死adb简介中提到的Server端进程。</p>
<p>由于adb并不稳定, 有时候莫名的问题掉线时, 可以先kill-server, 然后start-server来确保Server进程启动。往往可以解决问题。</p>
<h5 id="18、adb-shell-am"><a href="#18、adb-shell-am" class="headerlink" title="18、adb shell am"></a>18、adb shell am</h5><p>am即activity manager.<br>该命令用来执行一些系统动作, 例如启动指定activity, 结束进程, 发送广播, 更改屏幕属性等. 调试利器.</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>start <Intent></td>
<td>根据intent指向启动Activity</td>
<td>Intent可以是显示的指向activity, 也可以是ACTION方式, 并且可以添加flag, data等参数信息.</td>
</tr>
<tr>
<td>startservice <Intent></td>
<td>启动Service</td>
<td>可以添加flag, data等参数信息.</td>
</tr>
<tr>
<td>broadcast <Intent></td>
<td>发送广播</td>
<td>可以添加flag, data等参数信息.</td>
</tr>
<tr>
<td>monitor</td>
<td>启动一个Crash和ANR的监听器</td>
<td>如有Crash或ANR会在控制台输出相关信息.</td>
</tr>
<tr>
<td>force-stop <Package></td>
<td>强制停止该包相关的一切</td>
<td>传入package name.</td>
</tr>
<tr>
<td>kill <Package></td>
<td>杀死该包相关的所有进程</td>
<td>传入package name.</td>
</tr>
<tr>
<td>kill-all</td>
<td>杀死所有后台进程</td>
<td></td>
</tr>
<tr>
<td>display-size WxH</td>
<td>改变显示的分辨率</td>
<td>例如adb shell am display-size 1280x720, 手机可能不支持.</td>
</tr>
<tr>
<td>display-density <dpi></td>
<td>改变显示的density</td>
<td>例如adb shell am display-density 320, 手机可能不支持.</td>
</tr>
</tbody></table>
<h5 id="19、adb-shell-dumpsys"><a href="#19、adb-shell-dumpsys" class="headerlink" title="19、adb shell dumpsys"></a>19、adb shell dumpsys</h5><p>强大的dump工具, 可以输出很多系统信息. 例如window, activity, task/back stack信息, wifi信息等.</p>
<p>常用dumpsys:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>备注</th>
<th>细分参数</th>
</tr>
</thead>
<tbody><tr>
<td>activity</td>
<td>输出app组件相关信息</td>
<td>还可以用细分参数获得单项内容, 下同. 例如adb shell dumpsys activity activities来获取activity task/back stack信息.</td>
<td>activites, service, providers, intents, broadcasts, processes</td>
</tr>
<tr>
<td>alarm</td>
<td>输出当前系统的alarm信息</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>cpuinfo</td>
<td>输出当前的CPU使用情况</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>diskstats</td>
<td>输出当前的磁盘使用状态</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>batterystats</td>
<td>电池使用信息</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>package</td>
<td>package相关信息, 相当于pm功能的集合</td>
<td>输出诸如libs, features, packages等信息</td>
<td>/</td>
</tr>
<tr>
<td>meminfo</td>
<td>输出每个App的内存使用和系统内存状态</td>
<td>可以指定包名, 例如adb shell dumpsys meminfo com.anly.githubapp</td>
<td>/</td>
</tr>
<tr>
<td>window</td>
<td>输出当前窗口相关信息</td>
<td>/</td>
<td>policy, animator, tokens, windows</td>
</tr>
</tbody></table>
<h5 id="20-复制"><a href="#20-复制" class="headerlink" title="20.复制"></a>20.复制</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-copy:&lt;nox_id&gt; _from:&lt;nox_id&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：Nox.exe -copy:Nox_1 -from:nox</span><br><span class="line">Nox_1是新增的模拟器，复制自nox</span><br></pre></td></tr></table></figure>



<h5 id="21-删除"><a href="#21-删除" class="headerlink" title="21.删除"></a>21.删除</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-remove:&lt;nox_id&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：Nox.exe -remove:Nox_2</span><br><span class="line">删除模拟器Nox_2</span><br></pre></td></tr></table></figure>

<h5 id="22-备份"><a href="#22-备份" class="headerlink" title="22.备份"></a>22.备份</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-backup:&lt;nox_id&gt; -file:filepath</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：Nox.exe -backup:Nox_1 -file:C:\Users\xxxx\Desktop</span><br><span class="line">备份Nox_1到桌面</span><br></pre></td></tr></table></figure>

<h5 id="23-还原"><a href="#23-还原" class="headerlink" title="23.还原"></a>23.还原</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-restore:&lt;nox_id&gt; -file:filepath</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：Nox.exe -restore:Nox_1 -file:C:\xxxx\lihc\Desktop\backup20171030174008.vmdk</span><br><span class="line">[C:\Users\xxxx\Desktop\backup20171030174008.vmdk]文件还原到Nox_1</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>monkey 日志管理</title>
    <url>/2021/09/07/monkey-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="日志管理作用"><a href="#日志管理作用" class="headerlink" title="日志管理作用"></a><strong>日志管理作用</strong></h4><p>Monkey日志管理是Monkey测试中非常重要的一个环节，通过日志管理分析，可以获取当前测试对象在测试过程中是否会发生异常，以及发生的概率，同时还可以获取对应的错误信息，帮助开发定位和解决问题。<span id="more"></span></p>
<h4 id="monkey日志保存方法"><a href="#monkey日志保存方法" class="headerlink" title="monkey日志保存方法"></a><strong>monkey日志保存方法</strong></h4><ol>
<li><p>保存在PC中</p>
</li>
<li><p>保存在手机上</p>
</li>
<li><p>标准流和错误流分开保存</p>
</li>
</ol>
<h5 id="保存在PC中"><a href="#保存在PC中" class="headerlink" title="保存在PC中"></a><strong>保存在PC中</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;adb shell monkey [option] &lt;count&gt; &gt;d:\monkey.txt</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">C:\Users\admin&gt;adb shell monkey -v -v 100 &gt;d:\monkeylog.txt</span><br></pre></td></tr></table></figure>

<h5 id="保存在手机上"><a href="#保存在手机上" class="headerlink" title="保存在手机上"></a><strong>保存在手机上</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;adb shell</span><br><span class="line">monkey -v 100 &gt;/sdcard/monkeylog.log</span><br></pre></td></tr></table></figure>

<p>注意：不能写成<strong>C:\Users\admin&gt;adb shell monkey -f /sdcard/kyb.txt -v 1 &gt; /mnt/sdcard/monkey.log</strong> 否则会报错“系统找不到指定的路径”。</p>
<h5 id="标准流和错误流分开保存"><a href="#标准流和错误流分开保存" class="headerlink" title="标准流和错误流分开保存"></a><strong>标准流和错误流分开保存</strong></h5><ul>
<li>标准流与错误流分开保存，代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Monkey [option] &lt;count&gt; 1&gt;/sdcard/monkey.txt 2&gt;/sdcard/error.txt</span><br><span class="line"></span><br><span class="line">C:\Users\admin&gt;adb shell monkey -v 100 1&gt;d:\monkey.log  2&gt;d:\error.log</span><br></pre></td></tr></table></figure>

<p>执行以上命令，Monkey的运行日志和异常日志将被分开保存。此时Monkey的运行日志将被保存在monkey.txt文件中，而异常日志将被保存在D盘下的error.txt中。</p>
<h4 id="日志内容分析"><a href="#日志内容分析" class="headerlink" title="日志内容分析"></a><strong>日志内容分析</strong></h4><p>运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell monkey -v 100</span><br></pre></td></tr></table></figure>

<p>运行后log如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;adb shell monkey -v 100</span><br><span class="line">:Monkey: seed=1524595418646 count=100</span><br><span class="line">:IncludeCategory: android.intent.category.LAUNCHER</span><br><span class="line">:IncludeCategory: android.intent.category.MONKEY</span><br><span class="line">// Event percentages:</span><br><span class="line">//   0: 15.0%</span><br><span class="line">//   1: 10.0%</span><br><span class="line">//   2: 2.0%</span><br><span class="line">//   3: 15.0%</span><br><span class="line">//   4: -0.0%</span><br><span class="line">//   5: 25.0%</span><br><span class="line">//   6: 15.0%</span><br><span class="line">//   7: 2.0%</span><br><span class="line">//   8: 2.0%</span><br><span class="line">//   9: 1.0%</span><br><span class="line">//   10: 13.0%</span><br><span class="line">:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.android.settings/.Settings;end</span><br><span class="line">    // Allowing start of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.android.settings/.Settings &#125; in package com.android.settings</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(381.0,391.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(371.61426,386.54578)</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(608.0,610.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(609.2884,609.54736)</span><br><span class="line">:Sending Trackball (ACTION_MOVE): 0:(-3.0,4.0)</span><br><span class="line">:Sending Trackball (ACTION_MOVE): 0:(4.0,4.0)</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(42.0,319.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(40.672623,306.90936)</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(577.0,372.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(521.3876,386.2045)</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(59.0,762.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(92.18322,695.0543)</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(46.0,1066.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(118.78821,1042.1993)</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(525.0,696.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(557.81305,684.04376)</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(466.0,12.0)</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(453.73657,10.844121)</span><br><span class="line">:Sending Trackball (ACTION_MOVE): 0:(0.0,1.0)</span><br><span class="line">Events injected: 100</span><br><span class="line">:Sending rotation degree=0, persist=false</span><br><span class="line">:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0</span><br><span class="line">## Network stats: elapsed time=924ms (0ms mobile, 0ms wifi, 924ms not connected)</span><br><span class="line">// Monkey finished</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>monkey自定义脚本实践</title>
    <url>/2021/09/07/monkey%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h4 id="一-自定义脚本的稳定性测试"><a href="#一-自定义脚本的稳定性测试" class="headerlink" title="一.自定义脚本的稳定性测试"></a><strong>一.自定义脚本的稳定性测试</strong></h4><p>常规Monkey测试执行的是随机的事件流，但如果只是想让Monkey测试某个特定场景这时候就需要用到自定义脚本了，Monkey支持执行用户自定义脚本的测试，用户只需要按照Monkey脚本的规范编写好脚本，存放到手机上，启动Monkey通过-f 参数调用脚本即可。</p>
<span id="more"></span>

<h4 id="二-测试案例"><a href="#二-测试案例" class="headerlink" title="二.测试案例"></a><strong>二.测试案例</strong></h4><p>启动考研帮app3.1.0，然后跳过升级提示和引导页面，进入到登录界面并输入用户名密码进行登录。</p>
<h4 id="三-需求分析"><a href="#三-需求分析" class="headerlink" title="三.需求分析"></a><strong>三.需求分析</strong></h4><ul>
<li>从用户角度来思考步骤该怎样进行？</li>
<li> 要操作的元素该如何定位？</li>
<li>怎样将操作步骤转化为测试脚本？</li>
</ul>
<h5 id="获取元素坐标点位置"><a href="#获取元素坐标点位置" class="headerlink" title="获取元素坐标点位置"></a><strong>获取元素坐标点位置</strong></h5><p>Monkey脚本只能通过坐标的方式来定位点击和移动事件的屏幕位置，这里就需要提前获取坐标信息。获取坐标信息的方法很多，最简单的方法就是打开手机中的开发人员选项，打开“显示指针位置”。随后，在屏幕上的每次操作，在导航栏上都会显示坐标信息。</p>
<h5 id="Monkey脚本API简介"><a href="#Monkey脚本API简介" class="headerlink" title="Monkey脚本API简介"></a><strong>Monkey脚本API简介</strong></h5><ul>
<li>LaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。</li>
<li>Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。</li>
<li>UserWait(sleepTime)： 休眠一段时间</li>
<li>DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。</li>
<li>DispatchString(input)： 输入字符串。</li>
<li>DispatchFlip(true/false)： 打开或者关闭软键盘。</li>
<li>PressAndHold(x, y, pressDuration)： 模拟长按事件。</li>
<li>Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。</li>
<li>PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。</li>
<li>LongPress()： 长按2秒。</li>
<li>DeviceWakeUp()： 唤醒屏幕。</li>
<li>PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。</li>
<li>WriteLog()： 将电池信息写入sd卡。</li>
<li>RunCmd(cmd)： 运行shell命令。</li>
<li>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。</li>
<li>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。</li>
<li>LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。</li>
<li>DispatchTrackball： 模拟发送轨迹球事件。</li>
<li>ProfileWait： 等待5秒。</li>
<li>StartCaptureFramerate()： 获取帧率。</li>
<li>EndCaptureFramerate(input)： 结束获取帧率。</li>
</ul>
<h5 id="Monkey脚本格式"><a href="#Monkey脚本格式" class="headerlink" title="Monkey脚本格式"></a><strong>Monkey脚本格式</strong></h5><p>Monkey脚本主要包含两部分，一部分是头文件信息，一部分是具体的monkey命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type = raw events  </span><br><span class="line">count = 1  </span><br><span class="line">speed = 1.0  </span><br><span class="line">//下面为monkey命令  </span><br><span class="line">start data &gt;&gt;   </span><br><span class="line">具体的monkey脚本内容  </span><br></pre></td></tr></table></figure>



<h5 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a><strong>编写脚本</strong></h5><p>kyb.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#头文件信息</span><br><span class="line"></span><br><span class="line">type = raw events </span><br><span class="line"></span><br><span class="line">count = 1</span><br><span class="line"></span><br><span class="line">speed = 1.0</span><br><span class="line"></span><br><span class="line">#启动测试</span><br><span class="line">start data &gt;&gt;</span><br><span class="line"></span><br><span class="line">LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(624,900,1000) #点击取消升级</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(806,64,1000) #点击跳过</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(217,378,1000) #点击用户名输入框</span><br><span class="line">DispatchString(账户)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(197,461,1000) #点击密码输入框</span><br><span class="line">DispatchString(密码)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(343,637,1000) #点击登录按钮</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a><strong>执行脚本</strong></h5><p>脚本编写完成后，传到手机设备上，然后执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push C:\Users\admin\Desktop\kyb1.txt /sdcard</span><br><span class="line"></span><br><span class="line">adb shell monkey -f /sdcard/kyb1.txt -v 1</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;adb shell monkey -f /sdcard/kyb.txt -v 1</span><br><span class="line">:Monkey: seed=1524592021303 count=1</span><br><span class="line">:IncludeCategory: android.intent.category.LAUNCHER</span><br><span class="line">:IncludeCategory: android.intent.category.MONKEY</span><br><span class="line">Replaying 0 events with speed 1.0</span><br><span class="line">:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.tal.kaoyan/.ui.activity.SplashActivity;end</span><br><span class="line">    // Allowing start of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.tal.kaoyan/.ui.activity.SplashActivity &#125; in package com.tal.kaoyan</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(267.0,1233.0)</span><br><span class="line">    // Allowing start of Intent &#123; act=com.android.systemui.recent.action.TOGGLE_RECENTS cmp=com.android.systemui/.recent.RecentsActivity &#125; in package com.android.systemui</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(267.0,1233.0)</span><br><span class="line">Events injected: 5</span><br><span class="line">:Sending rotation degree=0, persist=false</span><br><span class="line">:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0</span><br><span class="line">## Network stats: elapsed time=7201ms (0ms mobile, 0ms wifi, 7201ms not connected)</span><br><span class="line">// Monkey finished</span><br></pre></td></tr></table></figure>



<h4 id="四-注意事项"><a href="#四-注意事项" class="headerlink" title="四.注意事项"></a><strong>四.注意事项</strong></h4><p>头文件代码书写注意“=”两边预留空格，否则会出现如下报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.NumberFormatException: Invalid int: &quot;&quot;</span><br></pre></td></tr></table></figure>



<h4 id="五-参考资料"><a href="#五-参考资料" class="headerlink" title="五.参考资料"></a><strong>五.参考资料</strong></h4><p><a href="https://www.cnblogs.com/mgzc-1508873480/p/7911373.html">https://www.cnblogs.com/mgzc-1508873480/p/7911373.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>安卓操作系统介绍</title>
    <url>/2021/09/07/%E5%AE%89%E5%8D%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，由Google公司和开放手机联盟领导（2007年11月，Google与84家硬件制造商、软件开发商及电信营运商组建开放手机联盟）及开发。<span id="more"></span></p>
<p>Android操作系统最初由[Andy Rubin](<a href="https://baike.baidu.com/item/Andy">https://baike.baidu.com/item/Andy</a> Rubin)开发，主要支持手机。2005年8月由Google收购注资。</p>
<p>第一部Android智能手机发布于2008年10月。Android逐渐扩展到平板电脑及其他领域上，如电视、数码相机、游戏机等。2011年第一季度，Android在全球的市场份额首次超过塞班系统，跃居全球第一。</p>
<p>2013年09月24日谷歌开发的操作系统Android在迎来了5岁生日，全世界采用这款系统的设备数量已经达到10亿台。</p>
<img src="https://pic.imgdb.cn/item/61376efb44eaada7392ed4a3.jpg">

<h4 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a><strong>发行版本</strong></h4><p>Android在正式发行之前，最开始拥有两个内部测试版本，并且以著名的机器人名称来对其进行命名，它们分别是：阿童木（AndroidBeta），发条机器人（Android 1.0）。后来由于涉及到版权问题，谷歌将其命名规则变更为用甜点作为它们系统版本的代号的命名方法。甜点命名法开始于Android 1.5发布的时候，然后按照26个字母数序</p>
<h5 id="Android-1-1-2008年9月发布的Android第一版。"><a href="#Android-1-1-2008年9月发布的Android第一版。" class="headerlink" title="Android 1.1 2008年9月发布的Android第一版。"></a><strong>Android 1.1 2008年9月发布的Android第一版。</strong></h5><h5 id="Android-1-5-Cupcake（纸杯蛋糕）：2009年4月30日发布。"><a href="#Android-1-5-Cupcake（纸杯蛋糕）：2009年4月30日发布。" class="headerlink" title="Android 1.5 Cupcake（纸杯蛋糕）：2009年4月30日发布。"></a><strong>Android 1.5 Cupcake（纸杯蛋糕）：2009年4月30日发布。</strong></h5><h5 id="Android-1-6-Donut（甜甜圈）：2009年9月15日发布。"><a href="#Android-1-6-Donut（甜甜圈）：2009年9月15日发布。" class="headerlink" title="Android 1.6 Donut（甜甜圈）：2009年9月15日发布。"></a><strong>Android 1.6 Donut（甜甜圈）：2009年9月15日发布。</strong></h5><h5 id="Android-2-0-2009年10月26日发布。"><a href="#Android-2-0-2009年10月26日发布。" class="headerlink" title="Android 2.0 2009年10月26日发布。"></a><strong>Android 2.0 2009年10月26日发布。</strong></h5><h5 id="Android-2-2-2-2-1-Froyo（冻酸奶）2010年5月20日发布。"><a href="#Android-2-2-2-2-1-Froyo（冻酸奶）2010年5月20日发布。" class="headerlink" title="Android 2.2/2.2.1 Froyo（冻酸奶）2010年5月20日发布。"></a><strong>Android 2.2/2.2.1 Froyo（冻酸奶）2010年5月20日发布。</strong></h5><p><strong>Android 2.3.x Gingerbread（姜饼） ：2010年12月7日发布。</strong></p>
<h5 id="Android-3-0-Honeycomb（蜂巢）：2011年2月2日发布。"><a href="#Android-3-0-Honeycomb（蜂巢）：2011年2月2日发布。" class="headerlink" title="Android 3.0 Honeycomb（蜂巢）：2011年2月2日发布。"></a><strong>Android 3.0 Honeycomb（蜂巢）：2011年2月2日发布。</strong></h5><h5 id="Android-4-0-Ice-Cream-Sandwich（冰激凌三明治）：2011年10月19日在香港发布。"><a href="#Android-4-0-Ice-Cream-Sandwich（冰激凌三明治）：2011年10月19日在香港发布。" class="headerlink" title="Android 4.0 Ice Cream Sandwich（冰激凌三明治）：2011年10月19日在香港发布。"></a><strong>Android 4.0 Ice Cream Sandwich（冰激凌三明治）：2011年10月19日在香港发布。</strong></h5><h5 id="Android-4-1-Jelly-Bean（果冻豆）-2012年6月28日"><a href="#Android-4-1-Jelly-Bean（果冻豆）-2012年6月28日" class="headerlink" title="Android 4.1 Jelly Bean（果冻豆）:2012年6月28日"></a><strong>Android 4.1 Jelly Bean（果冻豆）:2012年6月28日</strong></h5><h5 id="4-2-Jelly-Bean（果冻豆）-2012年10月30日"><a href="#4-2-Jelly-Bean（果冻豆）-2012年10月30日" class="headerlink" title="4.2 Jelly Bean（果冻豆）:2012年10月30日"></a><strong>4.2 Jelly Bean（果冻豆）:2012年10月30日</strong></h5><p>Android 4.2 Jelly Bean 原生系统用户界面 Android 4.2Jelly Bean（果冻豆）:2012年10月30日 Android 4.2沿用“果冻豆”这一名称，以反映这种最新操作系统与Android 4.1的相似性。</p>
<h5 id="Andriod-4-0-KitKat（奇巧巧克力）"><a href="#Andriod-4-0-KitKat（奇巧巧克力）" class="headerlink" title="Andriod 4.0 KitKat（奇巧巧克力）"></a><strong>Andriod 4.0 KitKat（奇巧巧克力）</strong></h5><p>Android 4.4KitKat（奇巧巧克力）: 2013年下半年 2013年9月4日凌晨，谷歌对外公布了Android新版本Android 4.4KitKat（奇巧巧克力），并且于2013年11月01日正式发布，新的4.4系统更加整合了自家服务，力求防止安卓系统继续碎片化、分散化。</p>
<h5 id="Android-5-0-Lollipop（棒棒糖）：2014年11月3日"><a href="#Android-5-0-Lollipop（棒棒糖）：2014年11月3日" class="headerlink" title="Android 5.0 Lollipop（棒棒糖）：2014年11月3日"></a><strong>Android 5.0 Lollipop（棒棒糖）：2014年11月3日</strong></h5><p>Android 5.0 系统使用一种新的Material Design设计风格。从图片上就能看到一些全新的设计。</p>
<h5 id="Android-6-0-Marshmallow（棉花糖）：2015年5月28日"><a href="#Android-6-0-Marshmallow（棉花糖）：2015年5月28日" class="headerlink" title="Android 6.0 Marshmallow（棉花糖）：2015年5月28日"></a><strong>Android 6.0 Marshmallow（棉花糖）：2015年5月28日</strong></h5><p>新系统的整体设计风格依然保持扁平化的MeterialDesign风格。Android6.0在对软件体验与运行性能上进行了大幅度的优化。据测试，Android6.0可使设备续航时间提升30%。</p>
<h5 id="Android-7-0-Nougat（牛轧糖）：2016年8月22日-10"><a href="#Android-7-0-Nougat（牛轧糖）：2016年8月22日-10" class="headerlink" title="Android 7.0 Nougat（牛轧糖）：2016年8月22日[10]"></a><strong>Android 7.0 Nougat（牛轧糖）：2016年8月22日[10]</strong></h5><h5 id="Android-8-0-Oreo（奥利奥）"><a href="#Android-8-0-Oreo（奥利奥）" class="headerlink" title="Android 8.0 Oreo（奥利奥）"></a><strong>Android 8.0 Oreo（奥利奥）</strong></h5><p>2017年8月22日，谷歌正式发布了Android 8.0的正式版，其正式名称为：Android Oreo（奥利奥）</p>
<h5 id="Android-9-0-Pistachio-Ice-Cream（开心果冰淇淋）"><a href="#Android-9-0-Pistachio-Ice-Cream（开心果冰淇淋）" class="headerlink" title="Android 9.0 Pistachio Ice Cream（开心果冰淇淋）"></a><strong>Android 9.0 Pistachio Ice Cream（开心果冰淇淋）</strong></h5><p>2018年2月，Android 9.0的初步代号定为Pistachio Ice Cream，中文暂译为开心果冰淇淋，预计2018年5月9日发布。</p>
<h5 id="V10-0-Android-10"><a href="#V10-0-Android-10" class="headerlink" title="V10.0_Android 10"></a><strong>V10.0_Android 10</strong></h5><p>从 Android 10 开始，Google 开始提供系统级的黑暗模式，大部分预装应用、抽屉、设置菜单和 Google Feed 资讯流等界面和按钮，都会变成以黑色为主色调，就和你在 macOS Mojave 中看到的暗色界面一样。为确保用户隐私和安全支持新的保护措施。借助高性能编解码器、更出色的生物识别技术、更快的应用启动速度、Vulkan 1.1、NNAPI 1.2、可折叠设备和 5G 等更多功能扩展！</p>
<p>谷歌宣布Android系统的重大改变，不仅换了全新的logo，命名方式也变了，2019年的Android Q的正式名称是Android 10 。</p>
<h5 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a><strong>Android 11</strong></h5><p>2019年10月11日消息，据外媒报道，2019年Android开发峰会将于本月晚些时候开幕，<a href="https://baike.baidu.com/item/%E8%B0%B7%E6%AD%8C">谷歌</a>公布了完整的会议日程。在会议日程中谷歌官方首次提到了Android 11。</p>
<p>此前外媒发现在AOSP中，谷歌已经启用了代号“Android R”。按照Android命名规则，Android R应该就是下一代Android：Android 11。</p>
<p>由于疫情原因，谷歌宣布取消线下的开发者大会，后来又取消了线上开发者大会，所以Android 11 将在2020年第三季度发布</p>
<p>Android 11 开发者预览版计划从 2020 年 2 月启动，到向 AOSP 和 OEM 提供最终的公开版本时结束，最终版本预计将于 2020 年第 3 季度发布。在开发阶段的各个关键里程碑，我们将为您的开发和测试环境提供更新。每次更新均包括 SDK 工具、系统映像、模拟器、API 参考和 API 差异。</p>
<h4 id="定制Anrdiod系统"><a href="#定制Anrdiod系统" class="headerlink" title="定制Anrdiod系统"></a><strong>定制Anrdiod系统</strong></h4><ul>
<li> <a href="http://www.miui.com/">MIUI</a></li>
<li> <a href="https://www.flyme.cn/">flyme</a></li>
<li> <a href="https://www.emui.com/cn/EMUI8.0">EMUI</a></li>
<li> <a href="#/4-x">Smartisan OS</a></li>
<li> Color os</li>
</ul>
<h4 id="Android各个系统市场占有率"><a href="#Android各个系统市场占有率" class="headerlink" title="Android各个系统市场占有率"></a><strong>Android各个系统市场占有率</strong></h4><ul>
<li> <a href="http://mta.qq.com/mta/data/device/os">http://mta.qq.com/mta/data/device/os</a></li>
<li> <a href="https://mtj.baidu.com/data/mobile/device/">https://mtj.baidu.com/data/mobile/device/</a></li>
</ul>
<p>资料来源： <a href="https://baike.baidu.com/item/Android/60243?fr=aladdin">https://baike.baidu.com/item/Android/60243?fr=aladdin</a></p>
]]></content>
  </entry>
  <entry>
    <title>Appium数据配置与日志操作</title>
    <url>/2021/09/04/Appium%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Appium的数据配置与日志收集"><a href="#Appium的数据配置与日志收集" class="headerlink" title="Appium的数据配置与日志收集"></a><strong>Appium的数据配置与日志收集</strong></h1><p>问题：</p>
<p>在我们配置Capability时，各个参数都是在代码里面写死的，比如：desired_caps[‘platformVersion’]=’7.1.2’ 一旦设备和测试的app发生改变则需要去代码里面一个个修改，要么同时根据不同设备不同App来维护多套代码，这样显示是不符合规范而且是低效的！违背了自动化的初衷，那么如何改进这样的现状呢？</p>
<p>针对这种可能频繁变动的部分，可以将数据和代码分离。将数据单独抽离出来放在配置文件里面， 代码直接从配置文件去读取数据，这样能够减少代码冗余，提高效率。PS：类似的Web前端的html标签和css分离。配置数据该如何管理？这里我们推荐使用<strong>yaml</strong>来管理配置数据。</p>
  <span id="more"></span>

<h1 id="一、yaml概述"><a href="#一、yaml概述" class="headerlink" title="一、yaml概述"></a><strong>一、yaml概述</strong></h1><h2 id="1-yaml简介"><a href="#1-yaml简介" class="headerlink" title="1 yaml简介"></a><strong>1 yaml简介</strong></h2><p>正如YAML所表示的YAML Ain’t Markup Language，YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。</p>
<p>由于实现简单，解析成本很低，YAML特别适合在脚本语言中使用。列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，JavaScript等。</p>
<p>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。比如同一段数据Josn和Yaml的表示分别如下：</p>
<p><strong>Json</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; name: &#x27;Tom Smith&#x27;,age: 37,spouse: &#123; name: &#x27;Jane Smith&#x27;, age: 25 &#125;,children: [ &#123; name: &#x27;Jimmy Smith&#x27;, age: 15 &#125;,&#123; name: &#x27;Jenny Smith&#x27;, age: 12 &#125; ] &#125;</span><br></pre></td></tr></table></figure>

<p><strong>yaml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Tom Smith</span><br><span class="line"></span><br><span class="line">age: 37</span><br><span class="line"></span><br><span class="line">spouse:</span><br><span class="line"></span><br><span class="line">  name: Jane Smith</span><br><span class="line"></span><br><span class="line">  age: 25</span><br><span class="line"></span><br><span class="line">children:</span><br><span class="line"></span><br><span class="line"> name: Jimmy Smith</span><br><span class="line"></span><br><span class="line">  age: 15</span><br><span class="line"></span><br><span class="line"> name: Jenny Smith</span><br><span class="line"></span><br><span class="line">  age: 12</span><br></pre></td></tr></table></figure>



<h2 id="2-语法特点【注意】"><a href="#2-语法特点【注意】" class="headerlink" title="2 语法特点【注意】"></a><strong>2 语法特点【注意】</strong></h2><ul>
<li><p>大小写敏感</p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p> 缩进时不允许使用Tab键，只允许使用空格。</p>
</li>
<li><p> 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
</li>
</ul>
<h2 id="3-yaml下载安装"><a href="#3-yaml下载安装" class="headerlink" title="3 yaml下载安装"></a><strong>3 yaml下载安装</strong></h2><p>官网：<a href="http://pyyaml.org/wiki/PyYAML">http://pyyaml.org/wiki/PyYAML</a></p>
<ul>
<li><p>下载安装：cmd 输入pip install pyyaml或者pip3 install pyyaml</p>
<p><img src="https://pic.imgdb.cn/item/6137758244eaada7393ec33c.jpg"></p>
</li>
<li><p>安装完成后在python引入yaml检测是否安装成功。 </p>
</li>
</ul>
<p>  <a href="https://pic.imgdb.cn/item/6137759044eaada7393ee3ed.jpg"><img src="https://pic.imgdb.cn/item/6137759044eaada7393ee3ed.jpg"></a></p>
<h1 id="二、yaml数据类型详解"><a href="#二、yaml数据类型详解" class="headerlink" title="二、yaml数据类型详解"></a>二、yaml数据类型详解</h1><h2 id="1-支持数据类型"><a href="#1-支持数据类型" class="headerlink" title="1.支持数据类型"></a>1.支持数据类型</h2><p><strong>1）.纯量</strong>（scalars）：单个的、不可再分的值</p>
<p><strong>2）.</strong> <strong>数组</strong>：一组按次序排列的值，又称为序列（sequence） / 列表（list）</p>
<p><strong>3）.</strong> <strong>对象</strong>：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</p>
<h2 id="2-纯量"><a href="#2-纯量" class="headerlink" title="2. 纯量"></a><strong>2. 纯量</strong></h2><p>数据最小的单位，不可以再分割。类似于Python中单个变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag</span><br></pre></td></tr></table></figure>



<h2 id="3-list数组"><a href="#3-list数组" class="headerlink" title="3. list数组"></a><strong>3. list数组</strong></h2><p>与Python的list结构类似，数组元素使用“-”开头，也可以根据缩进进行数组嵌套。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Jack</span><br><span class="line"></span><br><span class="line">\- Harry</span><br><span class="line"></span><br><span class="line">\- Sunny</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#也可以写成一行</span><br><span class="line">[Jack,Harry,Sunny]</span><br></pre></td></tr></table></figure>

<p> 对应到python的list写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Jack&#x27;,&#x27;Harry&#x27;,&#x27;Sunny&#x27;]</span><br></pre></td></tr></table></figure>



<h2 id="4-对象"><a href="#4-对象" class="headerlink" title="4. 对象"></a><strong>4.</strong> 对象</h2><p>对象的一组键值对，使用冒号结构表示。类似Python中的字典数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">platformName: Android</span><br><span class="line">platformVersion: 7.1.2</span><br><span class="line"></span><br><span class="line"># Yaml 也允许另一种写法，将所有键值对写成一个行内对象。</span><br><span class="line">&#123;platformName: Android,platformVersion: 7.1.2&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：冒号后面一定要有空格！对应到python字典的写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;platformName&#x27;: &#x27;Android&#x27;, &#x27;platformVersion&#x27;: &#x27;6.0.1&#x27;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-数据嵌套"><a href="#5-数据嵌套" class="headerlink" title="5.数据嵌套"></a>5.数据嵌套</h2><p>yaml数据嵌套表示可以将上面的各类数据根据实际场景进行组合嵌套。</p>
<p>数据场景：</p>
<p>Tom Smith 37岁，他有一个妻子叫 Jane Smith，35岁。 另外他有2个孩子，一个叫Jimmy Smith，15岁；另外一个叫Jenny Smith ，12岁。</p>
<p>yaml语法表示如下：</p>
<p><strong>familyInfo.yaml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Tom Smith</span><br><span class="line">age: 37</span><br><span class="line">spouse:</span><br><span class="line">    name: Jane Smith</span><br><span class="line">    age: 35</span><br><span class="line">children:</span><br><span class="line"> - name: Jimmy Smith</span><br><span class="line">   age: 15</span><br><span class="line"> - name: Jenny Smith</span><br><span class="line">   age: 12</span><br></pre></td></tr></table></figure>

<p>转化为Python的写法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;:&#x27;Tom Smith&#x27;,&#x27;age&#x27;:37,&#x27;spouse&#x27;:&#123;&#x27;name&#x27;:&#x27;Jane Smith&#x27;,&#x27;age&#x27;:25&#125;,&#x27;childern&#x27;:[&#123;&#x27;name&#x27;:&#x27;Jimmy Smith&#x27;,&#x27;age&#x27;:15&#125;,&#123;&#x27;name&#x27;:&#x27;Jenny Smith&#x27;,&#x27;age&#x27;:12&#125;]&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、yaml数据操作"><a href="#三、yaml数据操作" class="headerlink" title="三、yaml数据操作"></a>三、yaml数据操作</h1><h2 id="1-数据读取"><a href="#1-数据读取" class="headerlink" title="1. 数据读取"></a><strong>1.</strong> <strong>数据读取</strong></h2><h3 id="1-测试场景"><a href="#1-测试场景" class="headerlink" title="1) 测试场景"></a>1) 测试场景</h3><ul>
<li><p> 读取配置中的所有信息</p>
</li>
<li><p>读取yaml数据表中Tom Smith的姓名、年龄、信息</p>
</li>
<li><p>单独读取配偶的姓名和年龄信息</p>
</li>
<li><p>分别读取两个孩子的姓名、年龄信息</p>
</li>
</ul>
<h3 id="2-load方法"><a href="#2-load方法" class="headerlink" title="2) load方法"></a>2) load方法</h3><p>load(stream, Loader=Loader) 解析文件流中的第一个YAML文档并生成相应的Python对象。</p>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3) 代码实现"></a><strong>3) 代码实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import yaml&lt;!--须在设置里面添加pyaml--&gt;</span><br><span class="line">file=open(&#x27;runtest.yaml&#x27;,&#x27;r&#x27;)</span><br><span class="line">data=yaml.load(file)</span><br><span class="line"></span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">print(data[&#x27;name&#x27;])</span><br><span class="line">print(data[&#x27;age&#x27;])</span><br><span class="line"></span><br><span class="line">print(data[&#x27;spouse&#x27;])</span><br><span class="line">print(data[&#x27;spouse&#x27;][&#x27;name&#x27;])</span><br><span class="line">print(data[&#x27;spouse&#x27;][&#x27;age&#x27;])</span><br><span class="line"></span><br><span class="line">print(data[&#x27;children&#x27;])</span><br><span class="line">print(data[&#x27;children&#x27;][0][&#x27;name&#x27;])</span><br><span class="line">print(data[&#x27;children&#x27;][0][&#x27;age&#x27;])</span><br><span class="line"></span><br><span class="line">print(data[&#x27;children&#x27;][1][&#x27;name&#x27;])</span><br><span class="line">print(data[&#x27;children&#x27;][1][&#x27;age&#x27;])</span><br></pre></td></tr></table></figure>



<h2 id="2-数据修改"><a href="#2-数据修改" class="headerlink" title="2. 数据修改"></a><strong>2.</strong> <strong>数据修改</strong></h2><p>如果想改变某个数据，可以使用如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import yaml</span><br><span class="line">file=open(&#x27;runTest.yaml&#x27;,&#x27;r&#x27;)</span><br><span class="line">data=yaml.load(file)</span><br><span class="line">data[&#x27;name&#x27;]=&#x27;Test123&#x27;</span><br><span class="line">print(data[&#x27;name&#x27;])</span><br></pre></td></tr></table></figure>

<p>注意：此处只是变量类型的数据变更，不会真正修改到yaml配置表中的数据。</p>
<h2 id="3-数据转化"><a href="#3-数据转化" class="headerlink" title="3. 数据转化"></a><strong>3.</strong> <strong>数据转化</strong></h2><p>方法：dump()可以将Python对象序列化成YAML流。如果stream为None，则返回生成的字符串。</p>
<h3 id="1-测试场景-1"><a href="#1-测试场景-1" class="headerlink" title="1) 测试场景"></a>1) <strong>测试场景</strong></h3><p>将下面python数据类型转化为yaml数据类型</p>
<h3 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2) 代码实践"></a>2) <strong>代码实践</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import yaml</span><br><span class="line"></span><br><span class="line">city=[&#x27;changsha&#x27;,&#x27;wuhan&#x27;,&#x27;beijing&#x27;]</span><br><span class="line">person=&#123;&#x27;tom&#x27;:&#x27;18&#x27;&#125;</span><br><span class="line"></span><br><span class="line">#python data</span><br><span class="line">print(city)</span><br><span class="line">print(person)</span><br><span class="line">#yaml data</span><br><span class="line">print(yaml.dump(city))</span><br><span class="line">print(yaml.dump(person))</span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;changsha&#x27;, &#x27;wuhan&#x27;, &#x27;beijing&#x27;]</span><br><span class="line">&#123;&#x27;tom&#x27;: &#x27;18&#x27;&#125;</span><br><span class="line">\- changsha</span><br><span class="line">\- wuhan</span><br><span class="line">\- beijing</span><br><span class="line"></span><br><span class="line">tom: &#x27;18&#x27;</span><br></pre></td></tr></table></figure>



<h2 id="4-Capability配置数据分离"><a href="#4-Capability配置数据分离" class="headerlink" title="4. Capability配置数据分离"></a><strong>4.</strong> Capability配置数据分离</h2><h3 id="1-测试场景-2"><a href="#1-测试场景-2" class="headerlink" title="1) 测试场景"></a><strong>1) 测试场景</strong></h3><p>将capability的各项参数值与代码进行分离。</p>
<h3 id="2-场景分析"><a href="#2-场景分析" class="headerlink" title="2) 场景分析"></a><strong>2)</strong> <strong>场景分析</strong></h3><p>我们可以把之前capability中各项写死的配置信息来抽离出来，存放在一个yaml配置文件中，使用 对象数据类型来存储数据；然后调用load()方法读取数据，从而实现数据和代码的分离。</p>
<h3 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3) 代码实现"></a><strong>3)</strong> <strong>代码实现</strong></h3><ol>
<li>参数配置表：<strong>desired_caps.yaml</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">platformName: Android</span><br><span class="line">platformVersion: 7.1.2</span><br><span class="line">deviceName: 127.0.0.1:62025</span><br><span class="line">app: D\kaoyan3.1.0.apk</span><br><span class="line">noReset: False</span><br><span class="line">appPackage: com.tal.kaoyan&lt;!--#此次测试了考研帮--&gt;</span><br><span class="line">appActivity: com.tal.kaoyan.ui.activity.SplashActivity</span><br><span class="line">ip: 127.0.0.1</span><br><span class="line">port: 4723</span><br></pre></td></tr></table></figure>

<p>Python脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line">file=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)</span><br><span class="line">data=yaml.load(file)</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]</span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)</span><br></pre></td></tr></table></figure>



<p><strong>报错分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yaml.scanner.ScannerError: mapping values are not allowed here</span><br></pre></td></tr></table></figure>

<p>该报错说明map对象数据类型写法错误，一般为“：”后面没有留空格。如：platformName:Android</p>
<p> <strong>问题思考</strong></p>
<p>在自动化脚本运行过程中，IDE控制台一般都会输出运行日志。但是如果测试项目是在liunx服务器上面运行，没有IDE控制台输出log，那么我们该如何采集日志？</p>
<h1 id="四、日志概述"><a href="#四、日志概述" class="headerlink" title="四、日志概述"></a>四、日志概述</h1><h2 id="1-日志作用"><a href="#1-日志作用" class="headerlink" title="1 日志作用"></a><strong>1 日志作用</strong></h2><p>不管是在项目开发还是测试过程中，项目运行一旦出现问题日志信息就非常重要了。日志是定位问题的重要手段，就像侦探人员要根据现场留下的线索来推断案情。</p>
<h2 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2 日志级别"></a><strong>2 日志级别</strong></h2><p>脚本运行会有很多的情况，比如调试信息、报错异常信息等。日志要根据这些不同的情况来继续分级管理，不然对于排查问题的筛选会有比较大的干扰。日志一般定位的级别如下：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>何时使用</th>
</tr>
</thead>
<tbody><tr>
<td>DEBUG</td>
<td>调试信息，也是最详细的日志信息。</td>
</tr>
<tr>
<td>INFO</td>
<td>证明事情按预期工作。</td>
</tr>
<tr>
<td>WARNING</td>
<td>表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。</td>
</tr>
<tr>
<td>ERROR</td>
<td>由于更严重的问题，软件已不能执行一些功能了。</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>严重错误，表明软件已不能继续运行了。</td>
</tr>
</tbody></table>
<p>首先我们日志需要按照info、debug、error等级别来进行区分的。当然这个级别可以自己去设置。在一般的情况下我们普通的输出我们直接用info类型，调试的时候用debug类型，如果预计有错误时那么我们就需要用error类型的日志，一般情况去info级别最为合适。</p>
<h2 id="3-日志格式"><a href="#3-日志格式" class="headerlink" title="3 日志格式"></a><strong>3 日志格式</strong></h2><p>日志格式化是为了提高日志的可阅读性，比如：<strong>时间+模块+行数+日志</strong>具体信息的内容格式。如果日志信息杂乱无章的全部输出来，这样也不利于定位问题。</p>
<h2 id="4-日志位置"><a href="#4-日志位置" class="headerlink" title="4 日志位置"></a><strong>4 日志位置</strong></h2><p>一个项目中会有很多的日志采集点，而日志采集点必须结合业务属性来设置。比如在登录代码执行前可以插入“准备登录..”日志信息,如果登录完成之后，再设置登录的提示日志就会给人造成误解，无法判断到底是登录之前的问题还是登录之后的问题，因此日志采集点的位置很重要。</p>
<h1 id="五、logging模块"><a href="#五、logging模块" class="headerlink" title="五、logging模块"></a><strong>五、logging模块</strong></h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a><strong>1 简介</strong></h2><p>Python的logging模块提供了通用的日志系统，这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现方式记录日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#导入logging模块</span><br><span class="line">import logging</span><br></pre></td></tr></table></figure>



<h2 id="2-logging构成"><a href="#2-logging构成" class="headerlink" title="2 logging构成"></a><strong>2 logging构成</strong></h2><p>logging模块包括<strong>logger，Handler，Filter，Formatter</strong>四个部分。</p>
<ul>
<li><p>Logger 记录器，用于设置日志采集。</p>
</li>
<li><p>Handler 处理器，将日志记录发送至合适的路径。</p>
</li>
<li><p>Filter 过滤器，提供了更好的粒度控制，它可以决定输出哪些日志记录。</p>
</li>
<li><p> Formatter 格式化器，指明了最终输出中日志的格式。</p>
</li>
</ul>
<h2 id="3-Logger-记录器"><a href="#3-Logger-记录器" class="headerlink" title="3 Logger 记录器"></a><strong>3 Logger 记录器</strong></h2><p>Logger是一个树形层级结构，在使用接口debug，info，warn，error，critical；使用之前必须创建Logger实例，即创建一个记录器，如果没有显式的进行创建，则默认创建一个root logger，并应用默认的日志级别(WARN)，Handler和Formatter。</p>
<p><strong>方法:</strong></p>
<p>basicConfig(参数) 为日志记录系统做基本配置。</p>
<p><strong>部分参数</strong></p>
<p>filename :指定日志文件名称</p>
<p>filemode:指定打开文件的模式，如果指定了filename（如果文件模式未指定，则默认为’a）</p>
<p><strong>文件读写模式</strong>:</p>
<table>
<thead>
<tr>
<th>w</th>
<th>以写方式打开</th>
</tr>
</thead>
<tbody><tr>
<td>W</td>
<td>文件若存在，首先要清空，然后（重新）创建</td>
</tr>
<tr>
<td>a</td>
<td>以追加模式打开 (从 EOF 开始, 必要时创建新文件)</td>
</tr>
<tr>
<td>r+</td>
<td>以读写模式打开</td>
</tr>
<tr>
<td>w+</td>
<td>以读写模式打开 (参见 w )</td>
</tr>
<tr>
<td>a+</td>
<td>以读写模式打开 (参见 a )</td>
</tr>
</tbody></table>
<p><strong>format</strong>:为处理程序使用指定的格式字符串。</p>
<p><strong>datefmt</strong>: 使用指定的日期/时间格式。样式如果指定了格式字符串，则使用它来指定 格式字符串的类型.</p>
<p><strong>level</strong>:将根记录器级别设置为指定级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line">logging.debug(&#x27;debug info&#x27;)</span><br><span class="line">logging.info(&#x27;hello tom！&#x27;)</span><br><span class="line">logging.warning(&#x27;warning info&#x27;)</span><br><span class="line">logging.error(&#x27;error info&#x27;)</span><br><span class="line">logging.critical(&#x27;critical info&#x27;)</span><br></pre></td></tr></table></figure>



<h2 id="4-Handler-处理器"><a href="#4-Handler-处理器" class="headerlink" title="4 Handler 处理器"></a><strong>4 Handler 处理器</strong></h2><p>Handler 处理器，将日志记录发送至合适的路径,Handler处理器类型有很多种，比较常用的有三个：</p>
<h3 id="1-StreamHandler"><a href="#1-StreamHandler" class="headerlink" title="1).StreamHandler"></a><strong>1).StreamHandler</strong></h3><p>将日志记录输出发送到诸如sys.stdout，sys.stderr或任何类似文件流的对象。</p>
<h3 id="2-FileHandler"><a href="#2-FileHandler" class="headerlink" title="2).FileHandler"></a><strong>2).FileHandler</strong></h3><p>将日志记录输出发送到磁盘文件。 它继承了StreamHandler的输出功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(filename=&#x27;runlog.log&#x27;,level=logging.DEBUG)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="3-NullHandler"><a href="#3-NullHandler" class="headerlink" title="3).NullHandler"></a><strong>3).NullHandler</strong></h3><p>不做任何格式化或输出。 它本质上是一个开发人员使用的“无操作”处理程序。</p>
<h2 id="5-Formatter"><a href="#5-Formatter" class="headerlink" title="5 Formatter"></a><strong>5 Formatter</strong></h2><p>使用Formatter对象设置日志信息最后的规则、结构和内容，默认的时间格式为%Y-%m-%d %H:%M:%S。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%(levelno)s</td>
<td>打印日志级别的数值</td>
</tr>
<tr>
<td>%(levelname)s</td>
<td>打印日志级别名称</td>
</tr>
<tr>
<td>%(pathname)s</td>
<td>打印当前执行程序的路径</td>
</tr>
<tr>
<td>%(filename)s</td>
<td>打印当前执行程序名称</td>
</tr>
<tr>
<td>%(funcName)s</td>
<td>打印日志的当前函数</td>
</tr>
<tr>
<td>%(lineno)d</td>
<td>打印日志的当前行号</td>
</tr>
<tr>
<td>%(asctime)s</td>
<td>打印日志的时间</td>
</tr>
<tr>
<td>%(thread)d</td>
<td>打印线程id</td>
</tr>
<tr>
<td>%(threadName)s</td>
<td>打印线程名称</td>
</tr>
<tr>
<td>%(process)d</td>
<td>打印进程ID</td>
</tr>
<tr>
<td>%(message)s</td>
<td>打印日志信息</td>
</tr>
</tbody></table>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&#x27;runlog.log&#x27;,level=logging.DEBUG,</span><br><span class="line">format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;)</span><br><span class="line">logging.debug(&#x27;debug info&#x27;)</span><br><span class="line">logging.info(&#x27;hello tom！&#x27;)</span><br><span class="line">logging.warning(&#x27;warning info&#x27;)</span><br><span class="line">logging.error(&#x27;error info&#x27;)</span><br><span class="line">logging.critical(&#x27;critical info&#x27;)</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<p>2021-09-02 11:50:20,094   .py[line:5] DEBUG debug info<br>2021-09-02 11:50:41,359   .py[line:5] DEBUG debug info<br>2021-09-02 11:50:41,360   .py[line:6] INFO hello tom<br>2021-09-02 11:50:41,360   .py[line:7] WARNING warning info<br>2021-09-02 11:50:41,360   .py[line:8] ERROR error info<br>2021-09-02 11:50:41,360 </p>
<h1 id="六、Logging实践操作"><a href="#六、Logging实践操作" class="headerlink" title="六、Logging实践操作"></a><strong>六、Logging实践操作</strong></h1><h2 id="1测试场景"><a href="#1测试场景" class="headerlink" title="1测试场景"></a><strong>1测试场景</strong></h2><p>将前面所学的启动考研帮App的脚本增加log采集功能，设置指定的日志格式输出，并将日志保存到指定文件。</p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import yaml</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">file=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)</span><br><span class="line">data=yaml.load(file)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,filename=&#x27;runlog.log&#x27;,</span><br><span class="line">                    format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d]%(levelname)s%(message)s&#x27;)</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]</span><br><span class="line">desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]</span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]</span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]</span><br><span class="line"></span><br><span class="line">logging.info(&#x27;start app...&#x27;)</span><br><span class="line">driver=webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;,desired_caps)</span><br><span class="line"></span><br><span class="line">def check_cancelBtn():</span><br><span class="line">    logging.info(&#x27;check cancelBtn&#x27;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        cancelBtn = driver.find_element_by_id(&#x27;android:id/button2&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        logging.info(&#x27;no cancelBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        cancelBtn.click()</span><br><span class="line"></span><br><span class="line">def check_skipBtn():</span><br><span class="line">    logging.info(&#x27;check skipBtn&#x27;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        skipBtn = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        logging.info(&#x27;no skipBtn&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        skipBtn.click()</span><br><span class="line"></span><br><span class="line">check_cancelBtn()</span><br><span class="line">check_skipBtn()</span><br></pre></td></tr></table></figure>

<h2 id="3-问题思考"><a href="#3-问题思考" class="headerlink" title="3 问题思考"></a><strong>3 问题思考</strong></h2><p>前面我们已经实现了在代码中增添log，log也按照预期的采集到了，看似一切完美无瑕。但是该log配置的作用域也只是控制当前的脚本 。 然而一个自动化项目中通常有很多模块脚本，难道我们需要每一个脚本都这样配置吗？</p>
<h2 id="4解决思路"><a href="#4解决思路" class="headerlink" title="4解决思路"></a><strong>4解决思路</strong></h2><p>将这些日志配置的参数抽离出来，各个模块需要使用则直接引用即可。</p>
<h2 id="5日志格式配置"><a href="#5日志格式配置" class="headerlink" title="5日志格式配置"></a><strong>5日志格式配置</strong></h2><p>将log输出格式，输出路径等参数抽离出来作为一个配置表，如下所示：</p>
<p><strong>log.conf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root,infoLogger</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler,fileHandler</span><br><span class="line"></span><br><span class="line">[logger_infoLogger]</span><br><span class="line">handlers=consoleHandler,fileHandler</span><br><span class="line">qualname=infoLogger</span><br><span class="line">propagate=0</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=consoleHandler,fileHandler</span><br><span class="line"></span><br><span class="line">[handler_consoleHandler]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form02</span><br><span class="line">args=(sys.stdout,)</span><br><span class="line"></span><br><span class="line">[handler_fileHandler]</span><br><span class="line">class=FileHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form01</span><br><span class="line">args=(&#x27;runlog.log&#x27;, &#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=form01,form02</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</span><br><span class="line"></span><br><span class="line">[formatter_form02]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在需要调用的模块增加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CON_LOG=&#x27;log.conf&#x27;</span><br><span class="line">logging.config.fileConfig(CON_LOG)</span><br><span class="line">logging=logging.getLogger()</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fileConfig(fname, defaults=None, disable_existing_loggers=True)</span><br></pre></td></tr></table></figure>

<p>该放在作用是从ConfigParser格式的文件中读取日志配置，同时如果当前脚本有配置log参数，则覆盖当前log配置选项。</p>
<h2 id="6-代码实现"><a href="#6-代码实现" class="headerlink" title="6 代码实现"></a><strong>6 代码实现</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import yaml</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line"></span><br><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line"></span><br><span class="line">stream=open(&#x27;desired_caps.yaml&#x27;,&#x27;r&#x27;)</span><br><span class="line">data=yaml.load(stream)</span><br><span class="line"></span><br><span class="line">CON_LOG=&#x27;log.conf&#x27;</span><br><span class="line">logging.config.fileConfig(CON_LOG)</span><br><span class="line">logging=logging.getLogger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]</span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)</span><br><span class="line"></span><br><span class="line">def check_updateBtn():</span><br><span class="line">    logging.info(&quot;check_pdateBtn&quot;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        element = driver.find_element_by_id(&#x27;android:id/button2&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        logging.info(&#x27;update element is not found!&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        element.click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_skipBtn():</span><br><span class="line">    logging.info(&quot;check_skipBtn&quot;)</span><br><span class="line">    try:</span><br><span class="line">        element = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        logging.info(&#x27;skipBtn element is not found!&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        element.click()</span><br><span class="line"></span><br><span class="line">check_updateBtn()</span><br><span class="line">check_skipBtn()</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Appium案例整合</title>
    <url>/2021/09/09/Appium%E6%A1%88%E4%BE%8B%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="一、Pageobject-unittest"><a href="#一、Pageobject-unittest" class="headerlink" title="一、Pageobject+unittest"></a>一、<strong>Pageobject+unittest</strong></h1><p>在前面我们都是基于线性模型来编写测试脚本，而且元素定位方式和属性值都是写死的。在业务场景简单的情况下这样写无可厚非，但是一旦遇到产品需求变更，业务逻辑比较复杂需要维护的时候就非常麻烦了，那么该如何应对这种情况呢？<span id="more"></span></p>
<h2 id="1-场景案例"><a href="#1-场景案例" class="headerlink" title="1. 场景案例"></a><strong>1. 场景案例</strong></h2><p>前面我们所学，测试考研帮App登录场景，按照线性模型来构造出脚本如下： </p>
<p>考研帮登录测试场景脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import yaml</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CON_LOG=&#x27;./log/log.conf&#x27;</span><br><span class="line">logging.config.fileConfig(CON_LOG)</span><br><span class="line">logging=logging.getLogger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stream=open(&#x27;./yaml/desired_caps.yaml&#x27;,&#x27;r&#x27;)</span><br><span class="line">data=yaml.load(stream)</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]</span><br><span class="line">desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]</span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]</span><br><span class="line">desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]</span><br><span class="line">desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)</span><br><span class="line"></span><br><span class="line">def check_updateBtn():</span><br><span class="line">    logging.info(&quot;check_updateBtn&quot;)</span><br><span class="line">    try:</span><br><span class="line">        element = driver.find_element_by_id(&#x27;android:id/button2&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        logging.info(&#x27;update element is not found!&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        element.click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_skipBtn():</span><br><span class="line">    logging.info(&quot;check_skipBtn&quot;)</span><br><span class="line">    try:</span><br><span class="line">        element = driver.find_element_by_id(&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line">    except NoSuchElementException:</span><br><span class="line">        logging.info(&#x27;skipBtn element is not found!&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        element.click()</span><br><span class="line"></span><br><span class="line">check_updateBtn()</span><br><span class="line">check_skipBtn()</span><br><span class="line"></span><br><span class="line">logging.info(&#x27;start login...&#x27;)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;).send_keys(&#x27;liubo10010&#x27;)</span><br><span class="line">driver.find_element_by_id(&#x27;com.tal.kaoyan:id/login_login_btn&#x27;).click()</span><br><span class="line">logging.info(&#x27;login finished&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1) 案例分析"></a>1) <strong>案例分析</strong></h3><p>上面的脚本看似都比较完善，有了log采集，参数配置、启动时页面元素自动检测。但是也存在一些不足之处：</p>
<ul>
<li>公共模块和业务模块混合在一起显得代码冗余等</li>
<li>测试场景单一（如果要实现如下测试场景该怎么办？）</li>
<li>元素定位属性和代码混杂在一起</li>
</ul>
<p>以上这些都是需要优化的地方。</p>
<table>
<thead>
<tr>
<th><strong>测试场景</strong></th>
<th><strong>操作步骤</strong></th>
<th><strong>预期结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>多账号登录</td>
<td>不同的用户名密码来进行登录</td>
<td>能够正常登录</td>
</tr>
<tr>
<td>异常登录</td>
<td>用户名或者密码错误、或者为空进行登录，</td>
<td>登录失败，同时界面要给出相应的提示</td>
</tr>
<tr>
<td>注册</td>
<td>点击注册，然后进行注册信息填写</td>
<td>能够注册成功</td>
</tr>
</tbody></table>
<h3 id="2-重构优化思路"><a href="#2-重构优化思路" class="headerlink" title="2) 重构优化思路"></a><strong>2) 重构优化思路</strong></h3><ul>
<li>将一些公共的内容（如：check_updateBtn，check_skipBtn,capability）抽离出来。</li>
<li>元素定位方法和元素属性值与业务代码分离</li>
<li>登录功能模块封装为一个独立的模块</li>
<li>使用unittest进行用例综合管理</li>
</ul>
<h3 id="3-Page-Object"><a href="#3-Page-Object" class="headerlink" title="3) Page Object"></a><strong>3) Page Object</strong></h3><p><strong>Page Object是Selenium自动化测试项目开发实践的最佳设计模式之一，通过对界面元素的封装减少冗余代码，同时在后期维护中，若元素定位发生变化，只需要调整页面元素封装的代码，提高测试用例的可维护性。</strong></p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a><strong>2. 代码实现</strong></h2><p><strong>封装App启动配置信息</strong> </p>
<p><strong>desired_caps.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import yaml</span><br><span class="line">import logging.config</span><br><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">#把app启动封装到一个类里面</span><br><span class="line"></span><br><span class="line">CON_LOG = &#x27;../log/log.conf&#x27;</span><br><span class="line">logging.config.fileConfig(CON_LOG)</span><br><span class="line">logging = logging.getLogger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def appium_desired():</span><br><span class="line"></span><br><span class="line">    stream = open(&#x27;../yaml/desired_caps.yaml&#x27;, &#x27;r&#x27;)</span><br><span class="line">    data = yaml.load(stream)</span><br><span class="line"></span><br><span class="line">    desired_caps=&#123;&#125;</span><br><span class="line">    desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]</span><br><span class="line"></span><br><span class="line">    desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]</span><br><span class="line">    desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]</span><br><span class="line"></span><br><span class="line">    desired_caps[&#x27;app&#x27;]=data[&#x27;app&#x27;]</span><br><span class="line">    desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]</span><br><span class="line"></span><br><span class="line">    desired_caps[&#x27;unicodeKeyboard&#x27;]=data[&#x27;unicodeKeyboard&#x27;]</span><br><span class="line">    desired_caps[&#x27;resetKeyboard&#x27;]=data[&#x27;resetKeyboard&#x27;]</span><br><span class="line"></span><br><span class="line">    desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]</span><br><span class="line">    desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]</span><br><span class="line"></span><br><span class="line">    logging.info(&#x27;start run app...&#x27;)</span><br><span class="line">    driver = webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;, desired_caps)</span><br><span class="line"></span><br><span class="line">    driver.implicitly_wait(8)</span><br><span class="line">    return driver</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    appium_desired()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>记得在原来的yaml配置表desired_caps.yaml补充如下内容：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unicodeKeyboard: True </span><br><span class="line">resetKeyboard: True</span><br></pre></td></tr></table></figure>

<p><strong>封装基类</strong>:</p>
<p><strong>BaseView.py</strong></p>
<ol>
<li>初始化——获取driver</li>
<li>写一个获取所有元素的函数</li>
</ol>
<p><strong>#封装对应基类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#封装对应基类</span><br><span class="line">class BaseView(object):</span><br><span class="line">    def __init__(self,driver):</span><br><span class="line">        self.driver=driver</span><br><span class="line"></span><br><span class="line">    def find_element(self,*loc):</span><br><span class="line">        return self.driver.find_element(*loc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>封装通用公共类 common_fun.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Base_View import *</span><br><span class="line">from desired_caps import *</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">import logging</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">class Common(BaseView):</span><br><span class="line">    cancelBtn=(By.ID,&#x27;android:id/button2&#x27;)</span><br><span class="line">    skipBtn=(By.ID,&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line"></span><br><span class="line">    def check_cancelBtn(self):</span><br><span class="line">        logging.info(&#x27;==========check_cancelBtn=========&#x27;)</span><br><span class="line">        try:</span><br><span class="line">            cancelBtn = self.driver.find_element(*self.cancelBtn)</span><br><span class="line">        except NoSuchElementException:</span><br><span class="line">            logging.info(&#x27;no cancelBtn&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            cancelBtn.click()</span><br><span class="line"></span><br><span class="line">    def check_skipBtn(self):</span><br><span class="line">        logging.info(&#x27;=========check skipBtn=============&#x27;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            skipBtn = self.driver.find_element(*self.skipBtn)</span><br><span class="line">        except NoSuchElementException:</span><br><span class="line">            logging.info(&#x27;no skipBtn&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            skipBtn.click()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    driver=appium_desired()</span><br><span class="line">    com=Common(driver)</span><br><span class="line">    com.check_cancelBtn()</span><br><span class="line">    com.check_skipBtn()</span><br></pre></td></tr></table></figure>

<p><strong>封装登录操作</strong></p>
<p><strong>loginView.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">from common_fun import *</span><br><span class="line">from  desired_caps import *</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">class LoginView(Common):</span><br><span class="line"></span><br><span class="line">    username_type=(By.ID,&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;)</span><br><span class="line">    password_type=(By.ID,&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;)</span><br><span class="line">    loginBtn=(By.ID,&#x27;com.tal.kaoyan:id/login_login_btn&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def login_action(self,username,password):</span><br><span class="line">        self.check_cancelBtn()</span><br><span class="line">        self.check_skipBtn()</span><br><span class="line"></span><br><span class="line">        logging.info(&#x27;===============login===============&#x27;)</span><br><span class="line">        logging.info(&#x27;input username:%s&#x27;%username)</span><br><span class="line">        self.driver.find_element(*self.username_type).send_keys(username)</span><br><span class="line"></span><br><span class="line">        logging.info(&#x27;input password:%s&#x27;%password)</span><br><span class="line">        self.driver.find_element(*self.password_type).send_keys(password)</span><br><span class="line"></span><br><span class="line">        logging.info(&#x27;click loginBtn.&#x27;)</span><br><span class="line">        self.driver.find_element(*self.loginBtn).click()</span><br><span class="line">        logging.info(&#x27;login finished &#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    driver=appium_desired()</span><br><span class="line">    l=LoginView(driver)</span><br><span class="line">    l.login_action(&#x27;xx&#x27;,&#x27;aa&#x27;)</span><br></pre></td></tr></table></figure>



<h2 id="3-unittest用例封装"><a href="#3-unittest用例封装" class="headerlink" title="3. unittest用例封装"></a>3. unittest用例封装</h2><p><strong>测试场景：使用如下账号进行分别登录测试</strong></p>
<table>
<thead>
<tr>
<th><strong>用户名</strong></th>
<th><strong>密码</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>xxxx</strong></td>
<td><strong>aaaa</strong></td>
</tr>
<tr>
<td><strong>666</strong></td>
<td><strong>222</strong></td>
</tr>
</tbody></table>
<p><strong>1.封装用例启动、结束时的配置：</strong></p>
<p><strong>myunit.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from appium_Test4.page_object.desired_caps import appium_desired</span><br><span class="line">import logging</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">#unitTest创建与销毁</span><br><span class="line">class StartEnd(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        logging.info(&#x27;=====setUp====&#x27;)</span><br><span class="line">        self.driver=appium_desired()</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        logging.info(&#x27;====tearDown====&#x27;)</span><br><span class="line">        sleep(5)</span><br><span class="line">        self.driver.close_app()</span><br></pre></td></tr></table></figure>

<p><strong>2. 用例封装</strong></p>
<p><strong>test_login.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from  appium_Test4.unitTest.myunit import StartEnd</span><br><span class="line">from appium_Test4.page_object.loginView import LoginView</span><br><span class="line">import unittest</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">class TestLogin(StartEnd):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def test_login_xx(self):</span><br><span class="line">        logging.info(&#x27;=========test_login_xx============&#x27;)</span><br><span class="line">        l=LoginView(self.driver)</span><br><span class="line">        l.login_action(&#x27;xxxx&#x27;,&#x27;aaaa&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def test_login_error(self):</span><br><span class="line">        logging.info(&#x27;=======test_login_error=========&#x27;)</span><br><span class="line">        l=LoginView(self.driver)</span><br><span class="line">        l.login_action(&#x27;666&#x27;,&#x27;222&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<p>项目代码结构：</p>
<p><img src="https://pic.imgdb.cn/item/6139d59344eaada739043265.jpg"></p>
<h1 id="二、自动化测试框架综合案例"><a href="#二、自动化测试框架综合案例" class="headerlink" title="二、自动化测试框架综合案例"></a><strong>二、自动化测试框架综合案例</strong></h1><h2 id="1-框架功能"><a href="#1-框架功能" class="headerlink" title="1. 框架功能"></a><strong>1. 框架功能</strong></h2><p><strong>1) 业务功能的封装</strong></p>
<p><strong>2) 测试用例封装</strong></p>
<p><strong>3) 测试包管理</strong></p>
<p><strong>4) 截图处理</strong></p>
<p><strong>5) 断言处理</strong></p>
<p><strong>6) 日志获取</strong></p>
<p><strong>7) 测试报告生成</strong></p>
<p><strong>8) 配置参数</strong></p>
<h2 id="2-测试案例"><a href="#2-测试案例" class="headerlink" title="2. 测试案例"></a><strong>2. 测试案例</strong></h2><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a><strong>测试环境</strong></h4><ul>
<li>ppium-desktop 1.5.0</li>
<li>考研帮App Android版3.1.0</li>
<li>夜神模拟器 Android 7.1.2</li>
<li>Win 10 64位</li>
</ul>
<h4 id="覆盖用例"><a href="#覆盖用例" class="headerlink" title="覆盖用例"></a><strong>覆盖用例</strong></h4><p><strong>1.登录场景</strong></p>
<table>
<thead>
<tr>
<th><strong>用户名</strong></th>
<th><strong>密码</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>cccc</strong></td>
<td><strong>cccc</strong></td>
</tr>
<tr>
<td><strong>666</strong></td>
<td><strong>222</strong></td>
</tr>
</tbody></table>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a><strong>3. 代码实现</strong></h2><h3 id="1-driver配置封装"><a href="#1-driver配置封装" class="headerlink" title="1) driver配置封装"></a><strong>1) driver配置封装</strong></h3><p><strong>kyb_caps.yaml</strong> 配置表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">platformName: Android</span><br><span class="line">platformVersion: 7.1.2</span><br><span class="line">deviceName: 127.0.0.1:62025</span><br><span class="line">appname: kaoyan3.1.0.apk</span><br><span class="line">noReset: False</span><br><span class="line">unicodeKeyboard: True</span><br><span class="line">resetKeyboard: True</span><br><span class="line">appPackage: com.tal.kaoyan</span><br><span class="line">appActivity: com.tal.kaoyan.ui.activity.SplashActivity</span><br><span class="line">ip: 127.0.0.1</span><br><span class="line">port: 4723</span><br></pre></td></tr></table></figure>

<p><strong>desired_caps.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import yaml</span><br><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">CON_LOG=&#x27;../config/log.conf&#x27;</span><br><span class="line">logging.config.fileConfig(CON_LOG)</span><br><span class="line">logging=logging.getLogger()</span><br><span class="line"></span><br><span class="line">def appium_desired():</span><br><span class="line">    with open(&#x27;../config/kyb_caps.yaml&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file:</span><br><span class="line">        data=yaml.load(file)</span><br><span class="line"></span><br><span class="line">    desired_caps=&#123;&#125;</span><br><span class="line">    desired_caps[&#x27;platformName&#x27;]=data[&#x27;platformName&#x27;]</span><br><span class="line">    desired_caps[&#x27;platformVersion&#x27;]=data[&#x27;platformVersion&#x27;]</span><br><span class="line">    desired_caps[&#x27;deviceName&#x27;]=data[&#x27;deviceName&#x27;]</span><br><span class="line"></span><br><span class="line">    base_dir = os.path.dirname(os.path.dirname(__file__))</span><br><span class="line">    app_path = os.path.join(base_dir, &#x27;app&#x27;, data[&#x27;appname&#x27;])</span><br><span class="line">    desired_caps[&#x27;app&#x27;]=app_path</span><br><span class="line"></span><br><span class="line">    desired_caps[&#x27;appPackage&#x27;]=data[&#x27;appPackage&#x27;]</span><br><span class="line">    desired_caps[&#x27;appActivity&#x27;]=data[&#x27;appActivity&#x27;]</span><br><span class="line">    desired_caps[&#x27;noReset&#x27;]=data[&#x27;noReset&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    desired_caps[&#x27;unicodeKeyboard&#x27;]=data[&#x27;unicodeKeyboard&#x27;]</span><br><span class="line">    desired_caps[&#x27;resetKeyboard&#x27;]=data[&#x27;resetKeyboard&#x27;]</span><br><span class="line"></span><br><span class="line">    logging.info(&#x27;start app...&#x27;)</span><br><span class="line">    driver=webdriver.Remote(&#x27;http://&#x27;+str(data[&#x27;ip&#x27;])+&#x27;:&#x27;+str(data[&#x27;port&#x27;])+&#x27;/wd/hub&#x27;,desired_caps)</span><br><span class="line">    driver.implicitly_wait(8)</span><br><span class="line">    return driver</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    appium_desired()</span><br></pre></td></tr></table></figure>

<p><strong>相对路径符号含义</strong></p>
<p><strong>1. “.”表示当前目录</strong></p>
<p><strong>2. “..” 表示当前目录的上一级目录。</strong></p>
<p><strong>3. “./”表示当前目录下的某个文件或文件夹，视后面跟着的名字而定</strong></p>
<p><strong>4. “../”表示当前目录上一级目录的文件或文件夹，视后面跟着的名字而定。</strong></p>
<h3 id="2-基类封装"><a href="#2-基类封装" class="headerlink" title="2) 基类封装"></a><strong>2) 基类封装</strong></h3><p><strong>baseView.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BaseView(object):</span><br><span class="line">    def __init__(self,driver):</span><br><span class="line">        self.driver=driver</span><br><span class="line"></span><br><span class="line">    def find_element(self,*loc):</span><br><span class="line">        return self.driver.find_element(*loc)</span><br><span class="line"></span><br><span class="line">    def find_elements(self,*loc):</span><br><span class="line">        return self.driver.find_elements(*loc)</span><br></pre></td></tr></table></figure>



<h3 id="3-common公共模块封装"><a href="#3-common公共模块封装" class="headerlink" title="3) common公共模块封装"></a><strong>3) common公共模块封装</strong></h3><p><strong>公共方法封装 :</strong></p>
<p><strong>common_fun.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from baseView.baseView import BaseView</span><br><span class="line">from common.desired_caps import appium_desired</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">import logging</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time,os</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">class Common(BaseView):</span><br><span class="line">    cancelBtn=(By.ID,&#x27;android:id/button2&#x27;)</span><br><span class="line">    skipBtn=(By.ID,&#x27;com.tal.kaoyan:id/tv_skip&#x27;)</span><br><span class="line">    wemedia_cacel=(By.ID,&#x27;com.tal.kaoyan:id/view_wemedia_cacel&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def check_cancelBtn(self):</span><br><span class="line">        logging.info(&#x27;==========check_cancelBtn=========&#x27;)</span><br><span class="line">        try:</span><br><span class="line">            cancelBtn = self.driver.find_element(*self.cancelBtn)</span><br><span class="line">        except NoSuchElementException:</span><br><span class="line">            logging.info(&#x27;no cancelBtn&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            cancelBtn.click()</span><br><span class="line"></span><br><span class="line">    def check_skipBtn(self):</span><br><span class="line">        logging.info(&#x27;=========check skipBtn=============&#x27;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            skipBtn = self.driver.find_element(*self.skipBtn)</span><br><span class="line">        except NoSuchElementException:</span><br><span class="line">            logging.info(&#x27;no skipBtn&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            skipBtn.click()</span><br><span class="line">   </span><br><span class="line">    def getTime(self):</span><br><span class="line">        self.now=time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)</span><br><span class="line">        return self.now</span><br><span class="line"></span><br><span class="line">    def getScreenShot(self,module):</span><br><span class="line">        time=self.getTime()</span><br><span class="line">        image_file=os.path.dirname(os.path.dirname(__file__))+&#x27;/screenshots/%s_%s.png&#x27; %(module,time)</span><br><span class="line"></span><br><span class="line">        logging.info(&#x27;get %s screenshot&#x27; %module)</span><br><span class="line">        self.driver.get_screenshot_as_file(image_file)</span><br><span class="line"></span><br><span class="line">    def check_market_ad(self):</span><br><span class="line">        logging.info(&#x27;====check_market_ad====&#x27;)</span><br><span class="line">        try:</span><br><span class="line">            element=self.driver.find_element(*self.wemedia_cacel)</span><br><span class="line">        except NoSuchElementException:</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            logging.info(&#x27;close market ad&#x27;)</span><br><span class="line">            element.click()</span><br><span class="line"></span><br><span class="line">    def get_csv_data(self,csv_file,line):</span><br><span class="line">        logging.info(&#x27;=====get_csv_data======&#x27;)</span><br><span class="line">        with open(csv_file,&#x27;r&#x27;,encoding=&#x27;utf-8-sig&#x27;) as file:</span><br><span class="line">            reader=csv.reader(file)</span><br><span class="line">            for index,row in enumerate(reader,1):</span><br><span class="line">                if index==line:</span><br><span class="line">                    return row</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    driver = appium_desired()</span><br><span class="line">    c=Common(driver)</span><br><span class="line">    c.check_cancelBtn()</span><br><span class="line">    # # c.check_skipBtn()</span><br><span class="line">    # c.swipeLef()</span><br><span class="line">    # c.swipeLef()</span><br><span class="line">    # c.getScreenShot(&quot;startApp&quot;)</span><br></pre></td></tr></table></figure>



<h3 id="4-业务模块封装"><a href="#4-业务模块封装" class="headerlink" title="4) 业务模块封装"></a><strong>4) 业务模块封装</strong></h3><h4 id="1-登录页面业务逻辑模块"><a href="#1-登录页面业务逻辑模块" class="headerlink" title="1. 登录页面业务逻辑模块"></a><strong>1. 登录页面业务逻辑模块</strong></h4><p><strong>loginView.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">from common.common_fun import Common,NoSuchElementException</span><br><span class="line">from common.desired_caps import appium_desired</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">class LoginView(Common):</span><br><span class="line">    username_type=(By.ID,&#x27;com.tal.kaoyan:id/login_email_edittext&#x27;)</span><br><span class="line">    password_type=(By.ID,&#x27;com.tal.kaoyan:id/login_password_edittext&#x27;)</span><br><span class="line">    loginBtn=(By.ID,&#x27;com.tal.kaoyan:id/login_login_btn&#x27;)</span><br><span class="line"></span><br><span class="line">    tip_commit=(By.ID,&#x27;com.tal.kaoyan:id/tip_commit&#x27;)</span><br><span class="line"></span><br><span class="line">    button_mysefl=(By.ID,&#x27;com.tal.kaoyan:id/mainactivity_button_mysefl&#x27;)</span><br><span class="line">    username=(By.ID,&#x27;com.tal.kaoyan:id/activity_usercenter_username&#x27;)</span><br><span class="line"></span><br><span class="line">    RightButton=(By.ID,&#x27;com.tal.kaoyan:id/myapptitle_RightButton_textview&#x27;)</span><br><span class="line">    logoutBtn=(By.ID,&#x27;com.tal.kaoyan:id/setting_logout_text&#x27;)</span><br><span class="line"></span><br><span class="line">   def login_action(self,username,password):</span><br><span class="line">        self.check_cancelBtn()</span><br><span class="line">        self.check_skipBtn()</span><br><span class="line"></span><br><span class="line">        logging.info(&#x27;============login_action==============&#x27;)</span><br><span class="line">        logging.info(&#x27;username is:%s&#x27; %username)</span><br><span class="line">        self.driver.find_element(*self.username_type).send_keys(username)</span><br><span class="line"></span><br><span class="line">        logging.info(&#x27;password is:%s&#x27;%password)</span><br><span class="line">        self.driver.find_element(*self.password_type).send_keys(password)</span><br><span class="line"></span><br><span class="line">        logging.info(&#x27;click loginBtn&#x27;)</span><br><span class="line">        self.driver.find_element(*self.loginBtn).click()</span><br><span class="line">        logging.info(&#x27;login finished!&#x27;)</span><br><span class="line"></span><br><span class="line">    def check_account_alert(self):</span><br><span class="line">        logging.info(&#x27;=====check_account_alert====&#x27;)</span><br><span class="line">        try:</span><br><span class="line">            element=self.driver.find_element(*self.tip_commit)</span><br><span class="line">        except NoSuchElementException:</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            logging.info(&#x27;close tip_commit&#x27;)</span><br><span class="line">            element.click()</span><br><span class="line"></span><br><span class="line">    def check_loginStatus(self):</span><br><span class="line">        logging.info(&#x27;====check_loginStatus======&#x27;)</span><br><span class="line">        self.check_market_ad()</span><br><span class="line">        self.check_account_alert()</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line"></span><br><span class="line">            self.driver.find_element(*self.button_mysefl).click()</span><br><span class="line">            self.driver.find_element(*self.username)</span><br><span class="line">        except NoSuchElementException:</span><br><span class="line">            logging.error(&#x27;login Fail!&#x27;)</span><br><span class="line">            self.getScreenShot(&#x27;login fail&#x27;)</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            logging.info(&#x27;login success!&#x27;)</span><br><span class="line">            self.logout_action()</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">    def logout_action(self):</span><br><span class="line">        logging.info(&#x27;=====logout_action======&#x27;)</span><br><span class="line">        self.driver.find_element(*self.RightButton).click()</span><br><span class="line">        self.driver.find_element(*self.logoutBtn).click()</span><br><span class="line">        self.driver.find_element(*self.tip_commit).click()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    driver=appium_desired()</span><br><span class="line">    l=LoginView(driver)</span><br><span class="line">    l.login_action(&#x27;cccc&#x27;,&#x27;cccc&#x27;)</span><br><span class="line"></span><br><span class="line">    l.check_loginStatus()</span><br></pre></td></tr></table></figure>



<h4 id="2-data数据封装"><a href="#2-data数据封装" class="headerlink" title="2. data数据封装"></a><strong>2. data数据封装</strong></h4><h5 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h5><p><strong>在实际项目过程中，我们的数据可能是存储在一个数据文件中，如txt,excel、csv文件类型。我们可以封装一些方法来读取文件中的数据来实现数据驱动。</strong></p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p><strong>将测试账号存储在account.csv文件，内容如下：</strong></p>
<table>
<thead>
<tr>
<th><strong>用户名</strong></th>
<th><strong>密码</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Dddd1</strong></td>
<td><strong>Dddd1</strong></td>
</tr>
<tr>
<td><strong>666</strong></td>
<td><strong>222</strong></td>
</tr>
</tbody></table>
<h5 id="enumerate-简介"><a href="#enumerate-简介" class="headerlink" title="enumerate()简介"></a><strong>enumerate()简介</strong></h5><p><strong>enumerate()是python的内置函数</strong></p>
<ul>
<li>enumerate在字典上是枚举、列举的意思</li>
<li> 对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值</li>
<li>enumerate多用于在for循环中得到计数。</li>
</ul>
<h5 id="enumerate-使用"><a href="#enumerate-使用" class="headerlink" title="enumerate()使用"></a>enumerate()使用</h5><p><strong>如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;,&quot;数据&quot;]</span><br><span class="line">    for i in range(len(list)):</span><br><span class="line">        print(i,list[i])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0 这</span><br><span class="line">1 是</span><br><span class="line">2 一个</span><br><span class="line">3 测试</span><br><span class="line">4 数据</span><br></pre></td></tr></table></figure>

<p><strong>上述方法有些累赘，利用enumerate()会更加直接和优美：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;,&quot;数据&quot;]</span><br><span class="line">    for index, item in enumerate(list1):</span><br><span class="line">        print(index,item)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0 这</span><br><span class="line">1 是</span><br><span class="line">2 一个</span><br><span class="line">3 测试</span><br><span class="line">4 数据</span><br></pre></td></tr></table></figure>

<h5 id="数据读取方法封装"><a href="#数据读取方法封装" class="headerlink" title="数据读取方法封装"></a><strong>数据读取方法封装</strong></h5><p><strong>import csv</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">     def get_csv_data(csv_file,line):</span><br><span class="line">        with open(csv_file, &#x27;r&#x27;, encoding=&#x27;utf-8-sig&#x27;) as file:</span><br><span class="line">            reader=csv.reader(file)</span><br><span class="line">            for index, row in enumerate(reader,1):</span><br><span class="line">                if index == line:</span><br><span class="line">                    return row</span><br><span class="line"></span><br><span class="line">    csv_file=&#x27;../data/account.csv&#x27;</span><br><span class="line">    data=get_csv_data(csv_file,3)</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>

<h5 id="utf-8与utf-8-sig两种编码格式的区别"><a href="#utf-8与utf-8-sig两种编码格式的区别" class="headerlink" title="utf-8与utf-8-sig两种编码格式的区别:"></a>utf-8与utf-8-sig两种编码格式的区别:</h5><p>UTF-8以字节为编码单元，它的字节顺序在所有系统中都是一样的，没有字节序的问题，也因此它实际上并不需要BOM(“ByteOrder Mark”)。</p>
<p>但是UTF-8 with BOM即utf-8-sig需要提供BOM。</p>
<h4 id="3-config文件配置"><a href="#3-config文件配置" class="headerlink" title="3. config文件配置"></a><strong>3. config文件配置</strong></h4><p>日志文件配置 </p>
<p><strong>log.config</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root,infoLogger</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler,fileHandler</span><br><span class="line"></span><br><span class="line">[logger_infoLogger]</span><br><span class="line">handlers=consoleHandler,fileHandler</span><br><span class="line">qualname=infoLogger</span><br><span class="line">propagate=0</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=consoleHandler,fileHandler</span><br><span class="line"></span><br><span class="line">[handler_consoleHandler]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form02</span><br><span class="line">args=(sys.stderr,)</span><br><span class="line"></span><br><span class="line">[handler_fileHandler]</span><br><span class="line">class=FileHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form01</span><br><span class="line">args=(&#x27;../logs/runlog.log&#x27;, &#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=form01,form02</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</span><br><span class="line"></span><br><span class="line">[formatter_form02]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</span><br></pre></td></tr></table></figure>

<h4 id="4-测试用例封装"><a href="#4-测试用例封装" class="headerlink" title="4. 测试用例封装"></a><strong>4. 测试用例封装</strong></h4><ol>
<li><p>测试用例执行开始结束操作封装 </p>
<p><strong>myunit.py</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from common.desired_caps import appium_desired</span><br><span class="line">import logging</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">class StartEnd(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        logging.info(&#x27;=====setUp====&#x27;)</span><br><span class="line">        self.driver=appium_desired()</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        logging.info(&#x27;====tearDown====&#x27;)</span><br><span class="line">        sleep(5)</span><br><span class="line">        self.driver.close_app()</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>登录用例：</p>
<p><strong>test_login.py</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from common.myunit import StartEnd</span><br><span class="line">from businessView.loginView import LoginView</span><br><span class="line">import unittest</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">class TestLogin(StartEnd):</span><br><span class="line">    csv_file=&#x27;../data/account.csv&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def test_login_dd(self):</span><br><span class="line">        logging.info(&#x27;======test_login_dd=====&#x27;)</span><br><span class="line">        l=LoginView(self.driver)</span><br><span class="line">        data=l.get_csv_data(self.csv_file,2)</span><br><span class="line">        l.login_action(data[0],data[1])</span><br><span class="line">        self.assertTrue(l.check_loginStatus())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @unittest.skip(&#x27;test_login_error&#x27;)</span><br><span class="line">    def test_login_error(self):</span><br><span class="line">        logging.info(&#x27;======test_login_error=====&#x27;)</span><br><span class="line">        l = LoginView(self.driver)</span><br><span class="line">        data = l.get_csv_data(self.csv_file, 3)</span><br><span class="line"></span><br><span class="line">        l.login_action(data[0], data[1])</span><br><span class="line">        self.assertTrue(l.check_loginStatus(),msg=&#x27;login fail!&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<h4 id="5-执行测试用例-amp-报告生成"><a href="#5-执行测试用例-amp-报告生成" class="headerlink" title="5. 执行测试用例&amp;报告生成"></a><strong>5. 执行测试用例&amp;报告生成</strong></h4><p><strong>run.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from  BSTestRunner import BSTestRunner</span><br><span class="line">import time,logging</span><br><span class="line">import sys</span><br><span class="line">path=&#x27;D:\\kyb_testProject\\&#x27;</span><br><span class="line">sys.path.append(path)</span><br><span class="line"></span><br><span class="line">test_dir=&#x27;../test_case&#x27;</span><br><span class="line">report_dir=&#x27;../reports&#x27;</span><br><span class="line"></span><br><span class="line">discover=unittest.defaultTestLoader.discover(test_dir,pattern=&#x27;test_login.py&#x27;)</span><br><span class="line"></span><br><span class="line">now=time.strftime(&#x27;%Y-%m-%d %H_%M_%S&#x27;)</span><br><span class="line">report_name=report_dir+&#x27;/&#x27;+now+&#x27; test_report.html&#x27;</span><br><span class="line"></span><br><span class="line">with open(report_name,&#x27;wb&#x27;) as f:</span><br><span class="line">    runner=BSTestRunner(stream=f,title=&#x27;Kyb Test Report&#x27;,description=&#x27;kyb Android app test report&#x27;)</span><br><span class="line">    logging.info(&#x27;start run test case...&#x27;)</span><br><span class="line">    runner.run(discover)</span><br></pre></td></tr></table></figure>

<h4 id="6-实现邮件发送-把这个生成测试报告与邮件发送的代码封装成函数"><a href="#6-实现邮件发送-把这个生成测试报告与邮件发送的代码封装成函数" class="headerlink" title="6.实现邮件发送,把这个生成测试报告与邮件发送的代码封装成函数"></a><strong>6.实现邮件发送,把这个生成测试报告与邮件发送的代码封装成函数</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import unittest</span><br><span class="line">import os</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from BSTestRunner import BSTestRunner</span><br><span class="line">from email.mime.text import MIMEText #定义邮件内容</span><br><span class="line">from email.header import Header #定义邮件标题</span><br><span class="line">import smtplib #发送邮件模块</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">#截图的函数</span><br><span class="line">def insert_img(driver,filename):</span><br><span class="line">    #获取当前模块所在的路径</span><br><span class="line">    func_path=os.path.dirname(__file__)</span><br><span class="line">    #获取其上一级的目录</span><br><span class="line">    base_dir=os.path.dirname(func_path)</span><br><span class="line">    #把上一级目录转换为字符串</span><br><span class="line">    base_dir=str(base_dir)</span><br><span class="line">    #使用替换的方法</span><br><span class="line">    base_dir=base_dir.replace(&#x27;\\&#x27;,&#x27;/&#x27;)</span><br><span class="line">    base=base_dir.split(&#x27;/Website&#x27;)[0]</span><br><span class="line">    filepath = base + &#x27;/Website/test_report/screenshot/&#x27; + filename</span><br><span class="line">    driver.get_screenshot_as_file(filepath)</span><br><span class="line"></span><br><span class="line">#完善搜素最新报表的函数</span><br><span class="line">def latest_report(report_dir):  #传入整个报表的路径</span><br><span class="line">    lists = os.listdir(report_dir)</span><br><span class="line">    # 按时间顺序对该目录文件夹下面的文件进行排序</span><br><span class="line">  lists.sort(key=lambdafn:os.path.getatime(report_dir + &#x27;\\&#x27; + fn))</span><br><span class="line">    print((&quot;new report is :&quot; + lists[-1]))</span><br><span class="line"></span><br><span class="line">    file = os.path.join(report_dir, lists[-1])</span><br><span class="line">    print(file)#最新报表 ./2021-8-17  11-32-00 ...Html  路径</span><br><span class="line">    return file  #返回路径——最新报表</span><br><span class="line"></span><br><span class="line">#实现发邮件的函数</span><br><span class="line">def send_mail(latest_report):</span><br><span class="line">    # 读取传进来  最新报表的  内容</span><br><span class="line">    f = open(latest_report,&#x27;rb&#x27;)</span><br><span class="line">    mail_content = f.read()  # 存入 mail_content</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">smtpserver=&#x27;邮箱地址&#x27;</span><br><span class="line">user=&#x27;发送人邮箱&#x27;</span><br><span class="line">password=&#x27;HTTP授权码&#x27;</span><br><span class="line"></span><br><span class="line">sender=&#x27;发送人邮箱&#x27;</span><br><span class="line">receives=&#x27;接收人邮箱&#x27;</span><br><span class="line"></span><br><span class="line">subject = &#x27;Web Selenium 自动化测试报告&#x27;</span><br><span class="line">content = &#x27;&lt;html&gt;&lt;h1 style=&quot;color:red&quot;&gt;邮件内容&lt;/h1&gt;&lt;/html&gt;&#x27;</span><br><span class="line"></span><br><span class="line">    msg = MIMEText(content, &#x27;html&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line">    msg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;)</span><br><span class="line">msg[&#x27;From&#x27;]=&#x27;发送人邮箱&#x27;</span><br><span class="line">msg[&#x27;To&#x27;]=&#x27;接收人邮箱&#x27;</span><br><span class="line"></span><br><span class="line">smtp=smtplib.SMTP_SSL(smtpserver, 465)</span><br><span class="line">smtp.helo(smtpserver)</span><br><span class="line">smtp.ehlo(smtpserver)</span><br><span class="line">smtp.login(user,password)</span><br><span class="line">print(&quot;Start send Email...&quot;)</span><br><span class="line">smtp.sendmail(sender,receives,msg.as_string())</span><br><span class="line">smtp.quit()</span><br><span class="line">print(&quot;Start  Email end!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    test_dir = &#x27;../test_case&#x27;</span><br><span class="line">    report_dir = &#x27;../reports&#x27;</span><br><span class="line"></span><br><span class="line">    discover = unittest.defaultTestLoader.discover(test_dir, pattern=&#x27;test*.py&#x27;)</span><br><span class="line"></span><br><span class="line">    now = time.strftime(&#x27;%Y-%m-%d %H_%M_%S&#x27;)</span><br><span class="line">    report_name = report_dir + &#x27;/&#x27; + now + &#x27; test_report.html&#x27;</span><br><span class="line"></span><br><span class="line">    with open(report_name, &#x27;wb&#x27;) as f:</span><br><span class="line">        runner = BSTestRunner(stream=f, title=&#x27;Kyb Test Report&#x27;, description=&#x27;kyb Android app test report&#x27;)</span><br><span class="line">        # logging.info(&#x27;start run test case...&#x27;)</span><br><span class="line">        runner.run(discover)</span><br><span class="line">    f.close()</span><br><span class="line">    latest_report = latest_report(report_dir)</span><br><span class="line">    send_mail(latest_report)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Jmeter的基础操作</title>
    <url>/2021/09/08/Jmeter%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="一、JMeter-的介绍"><a href="#一、JMeter-的介绍" class="headerlink" title="一、JMeter 的介绍"></a><strong>一、JMeter 的介绍</strong></h1><h2 id="1-JMeter-是什么？"><a href="#1-JMeter-是什么？" class="headerlink" title="1. JMeter 是什么？"></a><strong>1. JMeter</strong> <strong>是什么？</strong></h2><p>JMeter 也称为“Apache JMeter”，它是一个开源的，100%基于 Java 的应用程序， 带有图形界面。 它旨在分析和衡量 Web 应用程序和各种服务的性能和负载功能行为。<span id="more"></span> </p>
<p>JMeter 主要用于测试 Web 应用程序或 FTP 应用程序，但目前，它适用于功能测试， JDBC 数据库连接，Web 服务，通用 TCP 连接和 OS 本机进程。  您可以执行各种测试活动，如性能，负载，压力，回归和功能测试，以便针对您的 Web 服务器获得准确的性能指标。 </p>
<p>JMeter 不是一个浏览器，它不像任何浏览器那样呈现 html 页面，而是在协议级别上 </p>
<p>运行。 </p>
<p><strong>以下是 JMeter 支持的协议列表:</strong> </p>
<p>Web Services - SOAP / XML-RPCWeb - HTTP, </p>
<p>HTTPS sites ‘web 1.0’ web 2.0 (ajax, flex 和 flex-ws-amf) </p>
<p>通过 JDBC 驱动程序的数据库目录 - LDAP </p>
<p>通过 JMS 面向消息传递的服务 </p>
<p>服务——POP3, IMAP, SMTP </p>
<h2 id="2-JMeter-的特性"><a href="#2-JMeter-的特性" class="headerlink" title="2. JMeter 的特性"></a><strong>2. JMeter</strong> <strong>的特性</strong></h2><p>**开源应用程序:**JMeter 是一个免费的开源应用程序，可以帮助用户或开发人员使用源代码开 发其他应用程序。 </p>
<p>**支持各种测试方法:**JMeter 支持各种测试方法，如负载测试，分布式测试和功能测试等。 </p>
<ul>
<li>Web: HTTP, HTTPS, SOAP </li>
<li>数据库: JDBC, LDAP, JMS </li>
<li>Mail: POP3 </li>
</ul>
<p>**支持多协议:**JMeter 支持 HTTP，JDBC，LDAP，SOAP，JMS 和 FTP 等协议。 </p>
<p>**模拟:**JMeter 可以使用虚拟用户或唯一用户模拟多个用户，以便对正在测试的 Web 应用程  序产生大量负载。 </p>
<p>**测试结果可视化:**测试结果可以以不同的格式查看，如图形，表格，树型和报告等。 </p>
<h2 id="3-JMeter-的工作流程"><a href="#3-JMeter-的工作流程" class="headerlink" title="3. JMeter 的工作流程"></a><strong>3. JMeter</strong> <strong>的工作流程</strong></h2><p>JMeter 通过模拟一组用户将请求发送到目标服务器。 随后，收集数据以通过各种格式 计算目标服务器的统计和显示性能度量。 </p>
<p>如下图所示：</p>
<p> <img src="https://pic.imgdb.cn/item/6138d2ac44eaada7398aa85b.png"></p>
<h2 id="4-JMeter-的安装"><a href="#4-JMeter-的安装" class="headerlink" title="4. JMeter 的安装"></a><strong>4. JMeter</strong> <strong>的安装</strong></h2><p>注意：安装 Jmeter 需要安装配置好对应的 java 环境  </p>
<p><img src="https://pic.imgdb.cn/item/6138d2cf44eaada7398afbc5.png"></p>
<p>JMeter 下载、安装教程参考： </p>
<p><a href="https://blog.csdn.net/qq_39706570/article/details/91447382">https://blog.csdn.net/qq_39706570/article/details/91447382</a> </p>
<h2 id="5-构建-JMeter-的测试计划"><a href="#5-构建-JMeter-的测试计划" class="headerlink" title="5. 构建 JMeter 的测试计划"></a><strong>5.</strong> <strong>构建</strong> <strong>JMeter</strong> <strong>的测试计划</strong></h2><p>可以将测试计划可视化为用于运行测试的 JMeter 脚本。测试计划由测试元素组成，例 </p>
<p>如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。 -))</p>
<p>每个测试计划中至少应有一个线程组。 我们可以根据要求添加或删除元素。 </p>
<p>让我们按照以下简单步骤开始构建测试计划: </p>
<h3 id="1）-启动-JMeter-窗口"><a href="#1）-启动-JMeter-窗口" class="headerlink" title="1）. 启动 JMeter 窗口"></a><strong>1）. 启动 JMeter 窗口</strong></h3><p>双击文件夹里面 bin 目录里面的 Jmeter.bat，出现如下画面 </p>
<p><img src="https://pic.imgdb.cn/item/6138d2f244eaada7398b4a55.png"></p>
<p>默认的 JMeter 界面包含一个测试计划节点，其中保留了真实的测试计划。 </p>
<p><strong>测试计划(Test plan)：</strong>节点包含测试计划的名称和用户定义的变量。当您在测试计划的多 个部分中有重复值时，可使用用户定义变量，它提供了灵活性。 </p>
<p>提示：汉化一下：  </p>
<p><img src="https://pic.imgdb.cn/item/6138d30e44eaada7398b883b.png"></p>
<h3 id="2）-添加、删除测试计划元素"><a href="#2）-添加、删除测试计划元素" class="headerlink" title="2）. 添加、删除测试计划元素"></a><strong>2）.</strong> <strong>添加、删除测试计划元素</strong></h3><ol>
<li>为 JMeter 创建测试计划后，下一步是向 JMeter 测试计划添加和删除元素。 </li>
<li>选择测试计划节点，然后右键单击所选项目。 </li>
<li>鼠标悬停在“Add”选项上，然后将显示元素列表。 </li>
<li>鼠标悬停在所需的列表元素上，然后单击选择所需的选项 </li>
</ol>
<p><strong>下图显示了如何在测试计划中添加线程组元素</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6138d3dd44eaada7398d5cb8.png"></p>
<p>要删除元素，请选择所需的元素。 </p>
<p>右键单击元素，然后选择“Remove”选项。  </p>
<p><strong>下图显示了如何删除测试计划中的线程组元素:</strong> <img src="https://pic.imgdb.cn/item/6138d40a44eaada7398dc358.png" style="zoom:67%;" /></p>
<h3 id="3）-加载并且保存测试计划元素"><a href="#3）-加载并且保存测试计划元素" class="headerlink" title="3）. 加载并且保存测试计划元素"></a><strong>3）.</strong> <strong>加载并且保存测试计划元素</strong></h3><ol>
<li><p>要将元素加载到 JMeter 测试计划树，请选择并右键单击要添加已加载元素的任何树元 素。 </p>
</li>
<li><p>选择“Merge”选项。 </p>
</li>
<li><p>选择保存元素的.jmx 文件。 </p>
</li>
<li><p>元素将合并到 JMeter 测试计划树中。 </p>
<img src="https://pic.imgdb.cn/item/6138d43144eaada7398e1867.png" style="zoom:67%;" /> </li>
</ol>
<p>要保存树元素，请右键单击元素。 </p>
<p>选择“Save Selection As”选项。将文件保存在所需位置。</p>
<img src="https://pic.imgdb.cn/item/6138d45744eaada7398e6cf4.png" style="zoom: 80%;" />  

<h3 id="4）-配置树元素"><a href="#4）-配置树元素" class="headerlink" title="4）. 配置树元素"></a><strong>4）.</strong> <strong>配置树元素</strong></h3><p>可以使用 JMeter 右侧框架上的控件配置测试计划中的元素。 这些控件允许您配置所 </p>
<p>选元素的行为。 例如，可以通过以下方式配置线程组: </p>
<ol>
<li>元素的名称。 </li>
<li>线程数(正在测试的用户数)。 </li>
<li>加速时间(希望允许线程组从 0 到 3 个用户的时间)。 </li>
<li>循环计数(应该循环测试的次数)。 <img src="https://pic.imgdb.cn/item/6138d50944eaada739900145.png"></li>
</ol>
<h3 id="5-保存-JMeter-测试计划"><a href="#5-保存-JMeter-测试计划" class="headerlink" title="5). 保存 JMeter 测试计划"></a><strong>5).</strong> <strong>保存</strong> <strong>JMeter</strong> <strong>测试计划</strong></h3><p>到目前为止，我们已经完成了创建测试计划，添加元素和配置树。现在，您可以通过从 </p>
<p>文件菜单中选择“Save” 或“Save Test Plan As”来保存整个测试计划。 </p>
 <img src="https://pic.imgdb.cn/item/6138d5e844eaada739920525.png" style="zoom:67%;" />

<h3 id="6-运行-Jmeter-测试计划"><a href="#6-运行-Jmeter-测试计划" class="headerlink" title="6). 运行 Jmeter 测试计划"></a><strong>6).</strong> <strong>运行</strong> <strong>Jmeter</strong> <strong>测试计划</strong></h3><p>可以通过单击菜单项中的“Start(Ctrl + r)”来运行测试计划，也可以单击绿色播放按 </p>
<p>钮。下图显示了如何运行测试计划。 </p>
<p><img src="https://pic.imgdb.cn/item/6138d61644eaada73992719c.png"></p>
<h3 id="7-停止-JMeter-测试计划"><a href="#7-停止-JMeter-测试计划" class="headerlink" title="7). 停止 JMeter 测试计划"></a><strong>7).</strong> <strong>停止</strong> <strong>JMeter</strong> <strong>测试计划</strong></h3><p>可以使用 Stop(Control +’.’)停止测试计划 - 如果可能，它会立即停止线程。您还 </p>
<p>可以使用 Shutdown(Control +’，’) - 它请求线程在任何正在进行的任务结束时停止 </p>
<h3 id="8-检查-JMeter-测试计划执行日志"><a href="#8-检查-JMeter-测试计划执行日志" class="headerlink" title="8). 检查 JMeter 测试计划执行日志"></a><strong>8).</strong> <strong>检查</strong> <strong>JMeter</strong> <strong>测试计划执行日志</strong></h3><p>JMeter 将测试运行详细信息，警告和错误存储到 jmeter.log 文件中。您可以通过单击菜单 栏正下方部分右侧的惊叹号来访问 JMeter 日志。下图显示了如何访问 JMeter 日志： <img src="https://pic.imgdb.cn/item/6138d62d44eaada73992a78c.png"></p>
<h1 id="二、JMeter的测试计划-认识组件"><a href="#二、JMeter的测试计划-认识组件" class="headerlink" title="二、JMeter的测试计划(认识组件)"></a><strong>二、JMeter的测试计划(认识组件)</strong></h1><h2 id="1-JMeter-测试计划元素"><a href="#1-JMeter-测试计划元素" class="headerlink" title="1. JMeter 测试计划元素"></a><strong>1. JMeter</strong> <strong>测试计划元素</strong></h2><p>JMeter 包含各种相互关联但为不同目的而设计的元素。在开始使用 JMeter 之前，最 </p>
<p>好先了解一下 JMeter 的一些主要元素，并详细说明。 </p>
<p><strong>注意:测试计划包含至少一个线程组。</strong> </p>
<p>以下是 JMeter 的主要的几个组件 </p>
<ol>
<li><p>测试计划(Test Plan) </p>
</li>
<li><p>线程组(Thread Group) </p>
</li>
<li><p>控制器(Controllers) </p>
</li>
<li><p>监听器(Listeners) </p>
</li>
<li><p>计时器(Timers) </p>
</li>
<li><p>配置元素(Configuration Elements)  </p>
</li>
<li><p>预处理器元素(Pre-Processor Elements) </p>
</li>
<li><p>后处理器元素(Post-Processor Elements) </p>
</li>
</ol>
<p><strong>每个组件与 JMeter 特定模块之间的关系</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6138d64844eaada73992e9e7.png"></p>
<h2 id="2-JMeter-测试计划"><a href="#2-JMeter-测试计划" class="headerlink" title="2. JMeter 测试计划"></a><strong>2. JMeter</strong> <strong>测试计划</strong></h2><p>可以将测试计划可视化为用于运行测试的 JMeter 脚本。 </p>
<p>测试计划由测试元素组成，例如线程组，逻辑控制器，样本生成控制器，监听器，定时 </p>
<p>器，断言和配置元素。 </p>
<p>下图给出了测试计划的目录级别。</p>
  <img src="https://pic.imgdb.cn/item/6138d6bd44eaada73993eca5.png" style="zoom: 50%;" />

<p>运行整个测试计划之前，应保存测试计划。JMeter 文件或测试计划以.JMX 扩展文件的 </p>
<p>形式保存。JMX 是一种基于开放测试的格式，它使测试计划能够在文本编辑器中启动。您 还可以将测试计划的一部分保存为不同的选择。 </p>
<p>例如，如果要使用侦听器保存 HTTP 请求采样器，可以将其保存为测试片段，以便它也 </p>
<p>可以在其他测试场景中使用。 </p>
<h2 id="3-JMeter-的线程组"><a href="#3-JMeter-的线程组" class="headerlink" title="3. JMeter 的线程组"></a><strong>3. JMeter</strong> <strong>的线程组</strong></h2><p>线程组顾名思义，线程组表示 JMeter 在测试期间将使用的线程组。 线程组元素是任 </p>
<p>何测试计划的起点。 线程组提供的控件允许:  </p>
<ol>
<li><p>设置线程数。 </p>
</li>
<li><p>设置加速期。 </p>
</li>
<li><p>设置执行测试的次数。 </p>
</li>
</ol>
<p>前面已在“添加/删除测试元素”部分中说明了在测试计划中添加线程组的步骤。下图 </p>
<p>显示了线程组的控制面板部分。</p>
 <img src="https://pic.imgdb.cn/item/6138d74344eaada739951bca.png" style="zoom: 50%;" />

<p>线程组控制面板包括: </p>
<ol>
<li><p>线程组名称。 </p>
</li>
<li><p>线程数(您正在测试的用户数)。 </p>
</li>
<li><p>加速时间(您希望允许线程组从 0 到 3 个用户的时间)。 </p>
</li>
<li><p>循环计数(应该循环测试的次数)。 </p>
</li>
<li><p>调度程序复选框(“线程组”面板底部的复选框用于启用/禁用额外字段，您可以在其 </p>
</li>
</ol>
<p>中输入测试持续时间，启动延迟，运行的开始和结束时间)。  </p>
<h2 id="4-JMeter-的控制器"><a href="#4-JMeter-的控制器" class="headerlink" title="4. JMeter 的控制器"></a><strong>4. JMeter</strong> <strong>的控制器</strong></h2><p>控制器可分为两大类: </p>
<ul>
<li>采样器 </li>
<li>逻辑控制器 </li>
</ul>
<h3 id="1-采样器"><a href="#1-采样器" class="headerlink" title="1) 采样器"></a><strong>1)</strong> <strong>采样器</strong></h3><p>采样器是允许 JMeter 将特定类型的请求发送到服务器的组件。它模拟用户对目标服务 </p>
<p>器的页面的请求。 </p>
<p>采样器是必须将组件添加到测试计划中的，因为它只能让 JMeter 知道需要将哪种类型 </p>
<p>的请求发送到服务器。 请求可以是 HTTP，HTTP(s)，FTP，TCP，SMTP，SOAP 等。 </p>
<p><strong>下面给出了 JMeter 采样器服务的请求列表:</strong> </p>
<ol>
<li> FTP 请求 </li>
<li>HTTP 请求(也可用于 SOAP 或 REST Web 服务) </li>
<li> JDBC 请求 </li>
<li> Java 对象请求 </li>
<li>JMS 请求 </li>
<li>JUnit 测试请求 </li>
<li>操作系统进程请求 </li>
<li>TCP 请求  </li>
</ol>
<p><strong>JMeter 采样器只能通过下图所示的方法添加到线程组中</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6138d7b544eaada7399614c7.png"></p>
<p><strong>2)</strong> <strong>取样器</strong> </p>
<p>逻辑控制器可帮助您控制线程中采样器处理顺序的流程。 它还可以更改来自其子元素 </p>
<p>的请求的顺序。 </p>
<p><strong>以下是 JMeter 中所有逻辑控制器的列表：</strong> </p>
<ol start="3">
<li><p>运行时控制器 </p>
</li>
<li><p>IF 控制器事务控制器 </p>
</li>
<li><p>录制控制器 </p>
</li>
<li><p>简单控制器 </p>
</li>
<li><p>while 控制器 </p>
</li>
<li><p>Switch 控制器 </p>
</li>
<li><p>ForEach 控制器 </p>
</li>
<li><p>模块控制器 </p>
</li>
<li><p>包括控制器循环控制器 </p>
</li>
<li><p>仅一次控制器  </p>
</li>
<li><p>交错控制器 </p>
</li>
<li><p>随机控制器 </p>
</li>
<li><p>随机顺序控制器 </p>
</li>
<li><p>吞吐量控制器 </p>
</li>
</ol>
<h2 id="5-JMeter-的监听器"><a href="#5-JMeter-的监听器" class="headerlink" title="5. JMeter 的监听器"></a><strong>5. JMeter</strong> <strong>的监听器</strong></h2><p>性能测试就是以各种形式分析服务器响应，然后将其呈现给客户端。 </p>
<p>当 JMeter 的采样器组件被执行时，监听器提供 JMeter 收集的关于那些测试用例的数据的 图形表示。 </p>
<p>它便于用户在某些日志文件中以表格，图形，树或简单文本的形式查看采样器结果。 </p>
<p>监听器可以在测试的任何地方进行调整，直接包括在测试计划下。 </p>
<p>JMeter 提供了大约 15 个监听器，但主要使用的是表，树和图形。 </p>
<p>以下是 JMeter 中所有监听器的列表： </p>
<ul>
<li>图表结果 </li>
<li>样条曲线可视化器 </li>
<li>断言结果 </li>
<li>简单的数据编写者 </li>
<li>监控结果 </li>
<li>分布图(alpha) </li>
<li>聚合图 </li>
<li>梅勒展示台 </li>
<li>BeanShell 监听器 </li>
<li>总结报告 </li>
<li>示例结果保存配置 </li>
<li>图表完整结果 </li>
<li>查看结果树  </li>
<li>汇总报告 </li>
<li>查看表格中的结果 </li>
</ul>
<p>下图显示如何在 Jmeter 中添加监听器： </p>
<p><img src="https://pic.imgdb.cn/item/6138d82444eaada739970586.png"></p>
<h2 id="6-JMeter-的计时器"><a href="#6-JMeter-的计时器" class="headerlink" title="6. JMeter 的计时器"></a><strong>6. JMeter</strong> <strong>的计时器</strong></h2><p>当您在网站或应用程序上执行任何操作时，它们自然会有暂停和延迟。 这 </p>
<p>些可以使用计时器(Timers)进行模拟。 </p>
<p>JMeter 发送请求时不会在每个采样器/请求之间应用延迟。 如果在服务器上执 </p>
<p>行负载/压力测试没有指定延迟，它将会超载。 这可能不完全是我们想要的。可 </p>
<p>以添加一个计时器元素，该元素允许您定义在每个请求到达时间等待的终止。 </p>
<p>下面给出了 JMeter 提供的所有计时器元素的列表： </p>
<p>同步定时器 </p>
<p>JSR223 时间 </p>
<p>BeanShell 时间 </p>
<p>高斯随机定时器  </p>
<p>统一随机定时器 </p>
<p>恒定吞吐量计时器 </p>
<p>BSF 时间 </p>
<p>泊松随机时间 </p>
<p>下图显示了一个固定定时器控制面板： <img src="https://pic.imgdb.cn/item/6138d86144eaada739979303.png" style="zoom: 50%;" /></p>
<h2 id="7-JMeter-的配置元素"><a href="#7-JMeter-的配置元素" class="headerlink" title="7. JMeter 的配置元素"></a><strong>7. JMeter</strong> <strong>的配置元素</strong></h2><p>配置元素的工作与采样器的工作类似。但是，它不发送请求，但它允许修改采样器发出 </p>
<p>的请求。</p>
<p>这是一个简单的元素，您可以在其中收集所有采样器的关联配置值，如 webserver 的 </p>
<p>主机名或数据库 URL 等。 </p>
<p>配置元素只能从放置元素的分支内部访问。</p>
  <img src="https://pic.imgdb.cn/item/6138d8aa44eaada739982fd1.png" style="zoom:50%;" />

<h2 id="8-JMeter-预处理元素"><a href="#8-JMeter-预处理元素" class="headerlink" title="8. JMeter 预处理元素"></a><strong>8. JMeter</strong> <strong>预处理元素</strong></h2><p>预处理器元素在采样器发出请求之前执行，如果预处理器附加到采样器元 </p>
<p>素，那么它将在该采样器元素运行之前执行。 </p>
<p>预处理器元素用于在运行之前修改样本请求的设置，或更新未从响应文本中提取 </p>
<p>的变量。 </p>
<p>以下是 JMeter 提供的所有预处理器元素的列表: </p>
<ol>
<li><p>JDBC 预处理器 </p>
</li>
<li><p>JSR223 预处理器 </p>
</li>
<li><p>RegEx 用户参数 </p>
</li>
<li><p>BeanShell 预处理器 </p>
</li>
<li><p>BSF 预处理器 </p>
</li>
<li><p>HTML 链接解析器  </p>
</li>
<li><p>HTTP URL 重写修饰符 </p>
</li>
<li><p>HTTP 用户参数修饰符 </p>
</li>
<li><p>用户参数 </p>
</li>
</ol>
<p>下图显示了如何将预处理器元素添加到测试计划中</p>
<p> <img src="https://pic.imgdb.cn/item/6138d8db44eaada739989c83.png"></p>
<h2 id="9-JMeter-的后处理元素"><a href="#9-JMeter-的后处理元素" class="headerlink" title="9. JMeter 的后处理元素"></a><strong>9. JMeter</strong> <strong>的后处理元素</strong></h2><p>在发出采样器请求之后执行后处理器元素。 如果后处理器连接到 Sampler 元素，那么 </p>
<p>它将在该 sampler 元素运行之后执行。 </p>
<p>后处理器最常用于处理响应数据，例如，为了将来目的而提取特定值。 </p>
<p>下面给出了 JMeter 提供的所有后处理器元素的列表： </p>
<ol>
<li><p>CSS/JQuery 抽取器 </p>
</li>
<li><p>BeanShell 后处理器  </p>
</li>
<li><p>JSR223 后处理器 </p>
</li>
<li><p>JDBC 后处理器 </p>
</li>
<li><p>调试后处理器 </p>
</li>
<li><p>正则表达式提取器 </p>
</li>
<li><p>XPath 抽取器 </p>
</li>
<li><p>结果状态操作处理程序 </p>
</li>
<li><p>BSF 后处理器 </p>
</li>
</ol>
<p>下图显示了如何将后处理器元素添加到测试计划中 -</p>
<p><img src="https://pic.imgdb.cn/item/6138d93e44eaada739998f71.png"></p>
<h2 id="10-JMeter-的函数"><a href="#10-JMeter-的函数" class="headerlink" title="10.JMeter 的函数"></a><strong>10.JMeter</strong> <strong>的函数</strong></h2><p>JMeter 函数可以称为特殊值，可以填充测试树中任何 Sampler 或其他元素的字段。 </p>
<p>JMeter 中函数的语法:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;__functionName(var1,var2,var3)&#125; , </span><br></pre></td></tr></table></figure>

<p>这里__ functionName 匹配函数的名称，圆括号围绕发送给函数的参数。 </p>
<p>如果函数参数包含逗号，那么请务必使用“\”对其进行转义，否则 JMeter 会将其 </p>
<p>视为参数分隔符。 </p>
<p>例如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;__time(EEE\, d MMM yyyy)&#125; </span><br></pre></td></tr></table></figure>

<h3 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a><strong>函数列表</strong></h3><table>
<thead>
<tr>
<th><strong>函数类型</strong></th>
<th><strong>名称</strong></th>
<th><strong>名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td>信息</td>
<td>threadNum</td>
<td>获取线程号</td>
</tr>
<tr>
<td>信息</td>
<td>samplerName</td>
<td>获取采样器名称(标签)。</td>
</tr>
<tr>
<td>信息</td>
<td>log</td>
<td>记录(或显示)消息(并返回值)。</td>
</tr>
<tr>
<td>信息</td>
<td>machineName</td>
<td>获取本地计算机名称。</td>
</tr>
<tr>
<td>输入</td>
<td>StringFromFile</td>
<td>从文件中读取一行。</td>
</tr>
<tr>
<td>输入</td>
<td>FileToString</td>
<td>读取整个文件。</td>
</tr>
<tr>
<td>输入</td>
<td>CSVRead</td>
<td>从 CSV 分隔文件中读取。</td>
</tr>
<tr>
<td>输入</td>
<td>XPath</td>
<td>使用 XPath 表达式从文件中读取。</td>
</tr>
<tr>
<td>计算</td>
<td>Counter</td>
<td>生成递增数字。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>函数类型</strong></th>
<th align="left"><strong>名称</strong></th>
<th><strong>注解</strong></th>
</tr>
</thead>
<tbody><tr>
<td>计算</td>
<td align="left">intSum</td>
<td>相加 int 数字。</td>
</tr>
<tr>
<td>计算</td>
<td align="left">longSum</td>
<td>相加 long 数字。</td>
</tr>
<tr>
<td>计算</td>
<td align="left">Random</td>
<td>生成一个随机数。</td>
</tr>
<tr>
<td>计算</td>
<td align="left">RandomString</td>
<td>生成随机字符串。</td>
</tr>
<tr>
<td>脚本</td>
<td align="left">BeanShell</td>
<td>运行 BeanShell 脚本。</td>
</tr>
<tr>
<td>脚本</td>
<td align="left">javaScript</td>
<td>运行 javaScript 脚本。</td>
</tr>
<tr>
<td>脚本</td>
<td align="left">jexl, jexl2</td>
<td>评估 Commons Jexl 表达式。</td>
</tr>
<tr>
<td>属性</td>
<td align="left">Property</td>
<td>读取 property 文件。</td>
</tr>
<tr>
<td>属性</td>
<td align="left">P</td>
<td>读取一个属性(速记方法)。</td>
</tr>
<tr>
<td>变量</td>
<td align="left">Split</td>
<td>将字符串拆分为变量。</td>
</tr>
<tr>
<td>变量</td>
<td align="left">eval</td>
<td>评估变量表达式。</td>
</tr>
<tr>
<td>字符串</td>
<td align="left">regexFunction</td>
<td>使用正则表达式解析先前的响应。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>函数类型</strong></th>
<th><strong>名称</strong></th>
<th><strong>注解</strong></th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>escapeOroRegexpChars</td>
<td>引用 ORO 正则表达式使用的元字符。</td>
</tr>
<tr>
<td>字符串</td>
<td>Char</td>
<td>从数字列表生成 Unicode char 值。</td>
</tr>
<tr>
<td>字符串</td>
<td>Unescape</td>
<td>包含 Java 转义的进程字符串(例如\n＆\t)。</td>
</tr>
<tr>
<td>字符串</td>
<td>unescapeHtml</td>
<td>解码 HTML 编码的字符串。</td>
</tr>
<tr>
<td>字符串</td>
<td>escapeHtml</td>
<td>使用 HTML 编码对字符串进行编码。</td>
</tr>
<tr>
<td>字符串</td>
<td>TestPlanName</td>
<td>返回当前测试计划的名称。</td>
</tr>
</tbody></table>
<p><strong>注意：JMeter 函数和变量始终区分大小写。</strong> </p>
<p>让我们考虑一个 Log Function 的例子来理解 JMeter 中函数的使用。 </p>
<p>JMeter 日志函数的语法： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;__log(&quot;message&quot;)&#125; </span><br></pre></td></tr></table></figure>

<p>首先，我们将使用 HTTP 请求采样器创建一个简单的测试计划。 </p>
<h3 id="创建-JMeter-测试计划"><a href="#创建-JMeter-测试计划" class="headerlink" title="创建 JMeter 测试计划"></a><strong>创建</strong> <strong>JMeter</strong> <strong>测试计划</strong></h3><ul>
<li>进入到 JMeter/bin 文件夹并双击 jmeter.bat 文件以启动 JMeter 界面。 </li>
<li>选择测试计划节点，然后右键单击所选项目。 </li>
<li>鼠标悬停在<strong>“Add”</strong>选项上，然后将显示元素列表。 </li>
<li>选择<strong>“Threads (Users)”</strong> &gt; <strong>“Thread Grou”</strong>。 </li>
<li>将此线程组重命名为 <strong>Thread Group 1</strong>。 </li>
</ul>
<h3 id="添加采样器"><a href="#添加采样器" class="headerlink" title="添加采样器"></a><strong>添加采样器</strong></h3><p>我们必须在线程组中添加一个 HTTP 请求采样器。 </p>
<ul>
<li>选择<strong>“Thread Group”</strong>，然后右键单击所选项。 </li>
<li>鼠标悬停在<strong>“Add”</strong>选项上，然后将显示元素列表。 </li>
<li>选择 <strong>Sampler</strong> &gt; <strong>HTTP</strong> <strong>请求</strong>选项。 </li>
<li>它将添加一个空的 HTTP 请求采样器。  <img src="https://pic.imgdb.cn/item/6138dde744eaada739a5e75b.png"></li>
</ul>
<p>将 HTTP Request Sampler 的字段配置为 - </p>
<ul>
<li><p>Name - HTTP 请求采样器 1。 </p>
</li>
<li><p>Server 名称或 IP - 在示例中，Web 服务器名称将为 - <a href="http://www.baidu.com/">www.baidu.com</a> </p>
</li>
<li><p>Protocol - 此字段保持不变。 </p>
</li>
<li><p>Path - 我们将其写为“/”(斜杠)。 它表示我们想要服务器的根页面 </p>
<p><img src="https://pic.imgdb.cn/item/6138de1944eaada739a655ec.png"></p>
</li>
</ul>
<p>现在，复制整个<strong>线程组 1</strong> 并将其粘贴在测试计划中三次。 </p>
<p>将其他线程组分别重命名为线程组 2 和线程组 3。 </p>
<p>将其他采样器分别重命名为 HTTP 请求采样器 2 和 HTTP 请求采样器 3。  </p>
<p><img src="https://pic.imgdb.cn/item/6138de3944eaada739a6bb41.png"></p>
<h3 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a><strong>添加监听器</strong></h3><ul>
<li>选择<strong>“Test Plan”</strong>节点，然后右键单击所选项目。 </li>
<li>鼠标悬停在<strong>“Add”</strong>选项上，然后将显示元素列表。 </li>
<li>选择 <strong>Listener</strong> -&gt; <strong>Summary Report</strong>。</li>
</ul>
<p> <img src="https://pic.imgdb.cn/item/6138de5244eaada739a72af3.png"></p>
<h3 id="保存并执行测试计划"><a href="#保存并执行测试计划" class="headerlink" title="保存并执行测试计划"></a><strong>保存并执行测试计划</strong></h3><p>单击文件 -&gt; 将测试计划另存为。 </p>
<p>将整个测试计划保存为 Function_test.jmx。 </p>
<p>然后单击“Run” -&gt; “Start” 以执行测试计划。  </p>
<h3 id="验证输出"><a href="#验证输出" class="headerlink" title="验证输出"></a><strong>验证输出</strong></h3><p><img src="https://pic.imgdb.cn/item/6138deca44eaada739a8f1fe.png"></p>
<p>因此，已经成功执行了测试计划。 现在，我们将使用 log 函数作为第一个 HTTP </p>
<p>Request Sampler 的名称。 </p>
<p><img src="https://pic.imgdb.cn/item/6138df1344eaada739a9af5e.png"></p>
<p>您可以看到日志功能已打印<strong>“Hello World”</strong>而不是完整的采样器名称。 让我们来 </p>
<p>看看一个时间函数的例子，将再次使用它作为第二个 HTTP 采样器的名称。 </p>
<p>时间函数的语法： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;__time(dd MM YYYY HH mm ss)&#125;  </span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/6138df3444eaada739a9ff04.png"></p>
<p>单击 <strong>Run</strong> &gt; <strong>Start</strong> 以执行测试计划。 </p>
<p><img src="https://pic.imgdb.cn/item/6138df4544eaada739aa2774.png"></p>
<p>可以看到时间函数已打印确切的时间和日期，而不是完整的采样器名称。 </p>
<h1 id="三、JMeter的实战"><a href="#三、JMeter的实战" class="headerlink" title="三、JMeter的实战"></a><strong>三、JMeter的实战</strong></h1><h2 id="1-JMeter-数据库测试计划"><a href="#1-JMeter-数据库测试计划" class="headerlink" title="1. JMeter 数据库测试计划"></a><strong>1. JMeter</strong> <strong>数据库测试计划</strong></h2><p><strong>准备表数据</strong> </p>
<p>为了我们的测试目的，这里将创建一个数据库。 </p>
<ul>
<li><p>创建名为 <strong>testdb</strong> 的数据库。 </p>
</li>
<li><p>创建表 - tb_user。 </p>
</li>
<li><p>将记录插入到 tb_user 表中。  </p>
<img src="https://pic.imgdb.cn/item/6138df7444eaada739aa9d8e.png" style="zoom:50%;" /></li>
</ul>
<p><strong>注意:</strong></p>
<p><strong>您需要将相应的 JDBC 驱动程序复制到 jmeter 的文件夹里面“lib”目录中</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6138dfc044eaada739ab6f3a.png">就是这个 </p>
<p><strong>下方链接：如何去下载 JDBC 的驱动包</strong> </p>
<p><strong><a href="https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-j">https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-j</a></strong> </p>
<p><strong>ava-5.1.47.zip</strong> </p>
<p><strong>重启 JMeter</strong> </p>
<p><strong>创建</strong> <strong>Jmeter</strong> <strong>测试计划</strong> </p>
<ul>
<li><p>进入到安装的 apache-jmeter-4.0\bin文件夹，双击 jmeter.bat文件以启动 JMeter </p>
</li>
<li><p>界面。 </p>
</li>
<li><p>选择测试计划节点，然后右键单击所选项目。 </p>
</li>
<li><p>鼠标悬停在<strong>“Add”</strong>选项上，然后将显示元素列表。 </p>
</li>
<li><p>选择“**线程(用户)**” -&gt; <strong>“Thread Group”</strong>。 </p>
</li>
<li><p>将此线程组重命名为:<strong>JDBC Users</strong>。 </p>
</li>
<li><p>线程组的默认属性保持不变。  </p>
<p><img src="https://pic.imgdb.cn/item/6138e01c44eaada739ac4726.png"></p>
</li>
</ul>
<p><strong>创建</strong> <strong>JDBC</strong> <strong>请求</strong> </p>
<ul>
<li><p>右键单击 JDBC users 元素。 </p>
</li>
<li><p>鼠标悬停在<strong>“Add”</strong> 选项上，然后将显示元素列表。 </p>
</li>
<li><p>选择 <strong>Config Element</strong> -&gt; <strong>JDBC Connection Configuration</strong> 。</p>
<p><img src="https://pic.imgdb.cn/item/6138e05f44eaada739acd599.png"> </p>
</li>
</ul>
<p>需要设置一些重要的字段，这些字段将决定数据库和 JMeter 之间的正确连接。 这些 </p>
<p>字段包括 </p>
<ul>
<li><p>绑定到池的变量名称 - 它唯一地标识配置。 JDBC Sampler 将进一步使用此名称来标识 </p>
</li>
<li><p>要使用的配置。这里将其命名为test。</p>
</li>
<li><p>数据库 URL： jdbc:mysql://localhost:3306/数据库名 </p>
</li>
<li><p>JDBC 驱动程序类： com.mysql.jdbc.Driver </p>
</li>
<li><p>用户名 ：数据库用户名（一般 root） </p>
</li>
<li><p>密码 : root 用户的密码。 </p>
</li>
<li><p>其他字段保持不变。  </p>
<img src="https://pic.imgdb.cn/item/6138e0c044eaada739ada6be.png" style="zoom:50%;" /></li>
<li><p>右键单击 JDBC users 元素。 </p>
</li>
<li><p>鼠标悬停在<strong>“Add”</strong>选项上，然后将显示元素列表。 </p>
</li>
<li><p>选择 <strong>Sampler</strong> -&gt; <strong>JDBC request</strong>。 </p>
</li>
<li><p>选择此新元素以查看其控制面板。 </p>
<p><img src="https://pic.imgdb.cn/item/6138e0e344eaada739adf044.png"></p>
</li>
</ul>
<p>需要设置一些重要的字段。 JDBC 请求控制面板包括 </p>
<ul>
<li><p>名字 - JDBC Request。 </p>
</li>
<li><p>输入池名称 - 测试(与配置元素中的相同)。 </p>
</li>
<li><p>查询类型 - 选择语句。 </p>
</li>
<li><p>查询 - 输入 SQL 查询字符串字段。 </p>
<p> <img src="https://pic.imgdb.cn/item/6138e10d44eaada739ae4270.png"></p>
</li>
</ul>
<p><strong>创建监听器</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6138e12144eaada739ae69be.png"></p>
<p><strong>验证输出</strong> </p>
<p>执行看监听器的结果 </p>
<p><img src="https://pic.imgdb.cn/item/6138e14044eaada739aea27a.png"></p>
<h2 id="2-JMeter-web-测试计划"><a href="#2-JMeter-web-测试计划" class="headerlink" title="2. JMeter web 测试计划"></a><strong>2. JMeter web</strong> <strong>测试计划</strong></h2><p>现在我们学习如何去创建测试网页的基本的测试计划。  </p>
<p>本次演示的目标网址：<a href="https://svnbucket.com/">https://svnbucket.com/</a> </p>
<h3 id="1-创建测试计划"><a href="#1-创建测试计划" class="headerlink" title="1) 创建测试计划"></a><strong>1) 创建测试计划</strong></h3><ul>
<li><p>单击<strong>“Test Plan”</strong>节点。 </p>
</li>
<li><p>将测试计划重命名为 <em>Demo Test</em>。 </p>
</li>
<li><p>选择 Demo Test 节点并右键单击所选项目。 </p>
</li>
<li><p>鼠标悬停在<strong>“Add”</strong>选项上，然后将显示元素列表。 </p>
</li>
<li><p>选择 <strong>Threads (Users)</strong> -&gt; <strong>Thread Group</strong>。 </p>
</li>
<li><p>将此线程组重命名为 <strong>Users</strong>。 </p>
</li>
<li><p>对于此测试，Users 元素表示访问网站主页的用户数。</p>
</li>
</ul>
<p> <img src="https://pic.imgdb.cn/item/6138e15a44eaada739aed3e2.png"></p>
<h3 id="2-添加采样器"><a href="#2-添加采样器" class="headerlink" title="2) 添加采样器"></a><strong>2)</strong> 添加采样器</h3><ul>
<li>我们必须在 <strong>Users</strong> 元素(线程组)中添加一个采样器。 </li>
<li>选择 Users 元素(线程组)，然后右键单击所选项。 </li>
<li>鼠标悬停在“Add”选项上，然后将显示元素列表。 </li>
<li>选择 <strong>Sampler</strong> -&gt; <strong>HTTP request</strong> 选项。 </li>
<li>它将添加一个空的 HTTP 请求采样器。 </li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6138e17244eaada739af02ff.png"></p>
<p>现在，配置 <strong>HTTP Request Sampler</strong> 的字段。它包括:  </p>
<ul>
<li>名称 - 访问易百网站主页(<a href="https://svnbucket.com/">https://svnbucket.com</a> )。 </li>
<li>服务器名称或 IP - 在这个示例中，Web 服务器名称是: svnbucket.com </li>
<li>协议 - 此字段保持不变。 路径 - 将其写为/(斜杠)。 它表示想要服务器的根页面。 </li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6138e18a44eaada739af3202.png"></p>
<h3 id="3-添加监听器"><a href="#3-添加监听器" class="headerlink" title="3) 添加监听器"></a><strong>3) 添加监听器</strong></h3><ul>
<li>选择 <strong>Users</strong> 元素。 </li>
<li>鼠标悬停在<strong>“Add”</strong>选项上，然后将显示元素列表。 </li>
<li>选择 <strong>Listener</strong> -&gt; <strong>View Results Tree</strong> 选项。 </li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6138e2e044eaada739b1e3bf.png"></p>
<h3 id="4-验证输出"><a href="#4-验证输出" class="headerlink" title="4) 验证输出"></a><strong>4) 验证输出</strong></h3><p>因为，我们将 Users 元素(线程组)的设置保留为单线程(一个用户)并循环 1 次(仅运行 1 </p>
<p>次)。 因此，在 <strong>View Result Tree Listener</strong> 中将结果作为单个用户请求获取。  </p>
<p>此测试计划仅适用于一个请求。 但是 JMeter 能够发送相同的请求，就好像许多用户正在 发送它一样。 要测试具有多个用户的 Web 服务器，需要更改 Users 元素(线程组)设置。 </p>
<p><strong>“View Result Tree”</strong> 面板的第一个选项卡是<strong>“Sampler result”</strong>。 </p>
<p>它显示了 JMeter 数据以及 Web 服务器返回的数据。 </p>
<p><strong>“ Sampler result ”</strong> 选 项 卡 显 示 Web 服 务 器 发 送 的 所 有 响 应 标 头 。 </p>
<p><img src="https://pic.imgdb.cn/item/6138e30144eaada739b221f2.png"></p>
<p>“Sampler result”面板的第二个选项卡是“请求”，它显示作为请求的一部分发送到 Web </p>
<p>服务器的所有数据。 </p>
<p> <img src="https://pic.imgdb.cn/item/6138e33044eaada739b289fd.png"></p>
<p><strong>“Sampler result”</strong>面板的最后一个选项卡是<strong>响应数据</strong>。 它以文本格式显示从服务器接收 的数据。</p>
<p> <img src="https://pic.imgdb.cn/item/6138e36a44eaada739b2f98e.png"></p>
<h2 id="3-JMeter-服务器代理方式"><a href="#3-JMeter-服务器代理方式" class="headerlink" title="3. JMeter 服务器代理方式"></a>3. JMeter 服务器代理方式</h2><h4 id="1-在-pc-端，通过服务器代理方式录制脚本步骤："><a href="#1-在-pc-端，通过服务器代理方式录制脚本步骤：" class="headerlink" title="(1) 在 pc 端，通过服务器代理方式录制脚本步骤："></a>(1) 在 pc 端，通过服务器代理方式录制脚本步骤：</h4><p><strong>准备：IE 浏览器：</strong> </p>
<p>1：工具—Internet 选项 </p>
<p>2：连接—-局域网设置 </p>
<p>3：勾选为 lan 代理……  </p>
<p>4：设置地址：localhost      端口：8080（用完记得关闭） </p>
<p><strong>JMeter 中操作:</strong> </p>
<p>1：添加线程组 </p>
<p>2：选择线程组—》逻辑控制器—》录制控制器 </p>
<p>3：右击 testplan—》非测试元件—-》http 代理服务器 </p>
<p>4：进入 http 代理服务器设置： </p>
<p>  A:端口号与你的浏览器局域网设置当中为 LAN….设置的端口一致（前提 </p>
<p>是端口不能被占用）</p>
<p><img src="https://pic.imgdb.cn/item/6138e3af44eaada739b37dad.png"></p>
<p>B:选择目标控制器，要求与你新建的录制控制器结构顺序一致，选择分租 为——每一个组放一个控制器。</p>
<p> <img src="https://pic.imgdb.cn/item/6138e3b044eaada739b37dba.png"></p>
<p>C:最后配置好了之后，点击启动，如果报错，常见的问题就是一个端口占用问题， </p>
<p>继续回去设置端口。出现以下界面，则配置 ok.  </p>
<p><img src="https://pic.imgdb.cn/item/6138e3b044eaada739b37dc8.png"></p>
<h2 id="4-启动禅道，观察-JMeter-里面的录制控制器。"><a href="#4-启动禅道，观察-JMeter-里面的录制控制器。" class="headerlink" title="4:启动禅道，观察 JMeter 里面的录制控制器。"></a><strong>4:启动禅道，观察 JMeter 里面的录制控制器。</strong></h2><img src="https://pic.imgdb.cn/item/6138e3b044eaada739b37ddf.png" style="zoom: 67%;" />

<h2 id="5：清除记录"><a href="#5：清除记录" class="headerlink" title="5：清除记录"></a><strong>5：清除记录</strong></h2><p><img src="https://pic.imgdb.cn/item/6138e3b044eaada739b37deb.png"></p>
<h4 id="2-在移动端，通过服务器代理方式录制脚本"><a href="#2-在移动端，通过服务器代理方式录制脚本" class="headerlink" title="(2) 在移动端，通过服务器代理方式录制脚本"></a>(2) 在移动端，通过服务器代理方式录制脚本</h4><p>实现的效果： </p>
<p>通过 JMter 一个连接，然后你在手机操作你的 APP，JMter 它会有记录 </p>
<p>它的准备工作： </p>
<p>手机+电脑+必须同一个 wifi 情况下（手机开热点是不行的） </p>
<p>步骤：</p>
<p>设备连接到同一个网络 </p>
<p>在本地查看一下你的 ip 地址（命令：ipconfig） </p>
<p><img src="https://pic.imgdb.cn/item/6138e40e44eaada739b42b12.png"></p>
<p><strong>一般安卓手机(如何设置手机的代理模式)</strong> </p>
<p>进入手机设置—进入 wifi 设置 长按住（点击后面叹号）你已经连接上那个 wifi,会弹出一个界面，点击该界面中的代 </p>
<p>理（有些能够直接看到高级设置同理）然后设置为手动，会提示你输入主机名：要求与你本 地 ip 在同一个默认网关的 ip。 </p>
<p>还有端口号：必须与你 JMeter 端口号一致。 </p>
<p>启动服务，然后自己可以在手机上去模拟用户对 app 的操作,然后再到 JMeter 中的录 </p>
<p>制控制器去观察结果。 </p>
<p>最后一步，请用完了，记得关闭服务。  </p>
<p><strong>手动配置主机名：</strong> </p>
<p>作用：常用与移动 App 测试当中，用来模拟用户的一个操作，如果仅凭肉眼来观察， </p>
<p>它是没有一个可靠的步骤和记录的。</p>
]]></content>
  </entry>
  <entry>
    <title>App自动化测试概述</title>
    <url>/2021/09/04/App%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、应用背景"><a href="#一、应用背景" class="headerlink" title="一、应用背景"></a><strong>一、应用背景</strong></h2><p>随着移动互联网和智能设备越来越普及，移动App已经渗透到了我们的生活方方面面，比如出行、饮食、旅行、社交、金融、短视频等。</p>
<p>用户对App产品的质量和用户体验要求越来越高。因此很多互联网企业也因此开始对移动端产品质量越来越重视。但是App产品不断迭代更新，给测试人员也增加了测试工作量，特别是大量繁琐的回归测试。</p>
<p>自动化测试是应对产品不断迭代更新的辅助测试手段（主要是针对回归测试），最终目的是为了保证产品质量。 <span id="more"></span></p>
<h2 id="二、移动端操作系统与app类型"><a href="#二、移动端操作系统与app类型" class="headerlink" title="二、移动端操作系统与app类型"></a><strong>二、移动端操作系统与app类型</strong></h2><h3 id="主流"><a href="#主流" class="headerlink" title="主流"></a><strong>主流</strong></h3><p>Andriod、iOS</p>
<h3 id="非主流"><a href="#非主流" class="headerlink" title="非主流"></a><strong>非主流</strong></h3><p>Winphone、黑莓、塞班、ubuntu、Asha、Tizen、Jolla、Firefox OS、鸿蒙os</p>
<h3 id="非智能机"><a href="#非智能机" class="headerlink" title="非智能机"></a><strong>非智能机</strong></h3><p>MTK平台、S40平台</p>
<h3 id="Andriod"><a href="#Andriod" class="headerlink" title="Andriod"></a><strong>Andriod</strong></h3><p>Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，由Google公司和开放手机联盟领导及开发。</p>
<img src="https://pic.imgdb.cn/item/61376beb44eaada73926a6b3.jpg">

<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a><strong>iOS</strong></h3><p>iOS是由苹果公司开发的移动操作系统 。苹果公司最早于2007年1月9日的Macworld大会上公布这个系统，最初是设计给iPhone使用的，后来陆续套用到iPod touch、iPad以及Apple TV等产品上。iOS与苹果的Mac OS X操作系统一样，属于类Unix的商业操作系统。</p>
<h2 id="三、app测试框架介绍"><a href="#三、app测试框架介绍" class="headerlink" title="三、app测试框架介绍"></a><strong>三、app测试框架介绍</strong></h2><h3 id="1-Andriod："><a href="#1-Andriod：" class="headerlink" title="1. Andriod："></a><strong>1. Andriod：</strong></h3><h4 id="Monkey"><a href="#Monkey" class="headerlink" title="Monkey"></a><strong>Monkey</strong></h4><p>​    Monkey是一个程序，运行在您的模拟器或设备上，并生成伪随机的用户事件流，如点击，触摸或手势，以及一些系统级事件。 您可以使用Monkey以随机但可重复的方式对您正在开发的应用程序进行压力测试。</p>
<h4 id="MonkeyRunner"><a href="#MonkeyRunner" class="headerlink" title="MonkeyRunner"></a><strong>MonkeyRunner</strong></h4><p>​    MonkeyRunner工具是使用Jython(使用Java编程语言实现的Python)写出来的，它提供了多个API，通过monkeyrunner API 可以写一个Python的程序来模拟操作控制Android设备app,测试其稳定性并通过截屏可以方便地记录出现的问题。</p>
<h4 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><strong>Instrumentation</strong></h4><p>​    Instrumentaion 是Android自带的一个测试框架，是很多其它测试框架的基础，可以在同进程中加载被测组件。它有很多丰富的高层封装，使用者可以使用基于instrumentation的其他框架，避免过多二次开发量。但Instrumentation不支持跨应用,导致基于instrumentation的框架都继承了这个缺点。</p>
<h4 id="Robotium-基于Instrumentation"><a href="#Robotium-基于Instrumentation" class="headerlink" title="Robotium(基于Instrumentation)"></a><strong>Robotium(基于Instrumentation)</strong></h4><p>​    Robotium是基于Instrumentation框架开发的一个更强的框架. 对常用的操作进行了易用性的封装. 用于开发功能性、系统和验收测试场景。它运行时绑定到GUI组件。它安装了一个测试用例套件作为在Android设备或仿真器上的应用程序，并提供用于执行测试的真实环境。</p>
<h4 id="Robolectric"><a href="#Robolectric" class="headerlink" title="Robolectric"></a><strong>Robolectric</strong></h4><p>​    支持单元测试；Robolectric允许用户做大部分真实设备上可以做的事情，且可以在常规的JVM持续集成环境中运行，不需要通过模拟器，因此可以摆脱模拟器启动慢的问题。</p>
<h4 id="UIAutomator"><a href="#UIAutomator" class="headerlink" title="UIAutomator"></a><strong>UIAutomator</strong></h4><p>​    Android 4.3发布的时候包含了一种新的测试工具–uiautomator，uiautomator是用来做UI测试的。也就是普通的手工测试，点击每个控件元素 看看输出的结果是否符合预期。比如 登陆界面 分别输入正确和错误的用户名密码然后点击登陆按钮看看是否能否登陆以及是否有错误提示等。</p>
<h4 id="Selendroid"><a href="#Selendroid" class="headerlink" title="Selendroid"></a><strong>Selendroid</strong></h4><p>​    Selendroid 是一个基于Instrumentation的一个框架. 完全兼容Webdriver协议。 Selendroid 可以在模拟器和实际设备上使用，也可以集成网格节点作为缩放和并行测试。</p>
<h4 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a><strong>Espresso</strong></h4><p>​    Espresso是Google的开源自动化测试框架。相对于Robotium和UIAutomator，它的特点是规模更小、更简洁，API更加精确，编写测试代码简单，容易快速上手。因为是基于Instrumentation的，所以不能跨App。</p>
<h4 id="Calabash"><a href="#Calabash" class="headerlink" title="Calabash"></a><strong>Calabash</strong></h4><p>​    Calabash是一个适用于iOS和Android开发者的跨平台app测试框架，可用来测试屏幕截图、手势和实际功能代码。</p>
<h4 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a><strong>Appium</strong></h4><p>​    Appium是一个开源的、跨平台的自动化测试工具，支持IOS、Android和FirefoxOS平台。 通过Appium，开发者无需重新编译app或者做任何调整，就可以测试移动应用，可以使测试代码访问后端API和数据库。</p>
<p>​    它是通过驱动苹果的UIAutomation和Android的UiAutomator框架来实现的双平台支持，同时绑定了Selenium WebDriver用于老的Android平台测试。开发者可以使用WebDriver兼容的任何语言编写测试脚本，如Java， OC， JS， PHP，Python， Ruby， C#，Clojure 和Perl语言。</p>
<h4 id="Macaca"><a href="#Macaca" class="headerlink" title="Macaca"></a><strong>Macaca</strong></h4><p>​    Macaca 是一套面向用户端软件的测试解决方案，提供了自动化驱动，环境配套，周边工具，集成方案，旨在解决终端上的测试、自动化、性能等方面的问题。</p>
<h4 id="Cafe"><a href="#Cafe" class="headerlink" title="Cafe"></a><strong>Cafe</strong></h4><p>​    基于hook录制体系</p>
<p>​    遍历测试</p>
<p>​    跨app测试</p>
<p>​    pc agent设计</p>
<p>​    使用android漏洞提权</p>
<h3 id="2-iOS"><a href="#2-iOS" class="headerlink" title="2. iOS"></a>2. <strong>iOS</strong></h3><h4 id="XCTest"><a href="#XCTest" class="headerlink" title="XCTest"></a><strong>XCTest</strong></h4><p>​        XCTest是苹果在iOS 7和Xcode5引入的一个简单而强大的测试框架，它的测试编写起来非常简单，并且遵循xUnit风格。XCTest的优点是与Xcode深度集成，有专门的Test导航栏，但因为受限于官方测试API，因此功能不是很丰富。</p>
<h4 id="UIAutomation"><a href="#UIAutomation" class="headerlink" title="UIAutomation"></a><strong>UIAutomation</strong></h4><p>​        UIAutomation是苹果提供的UI自动化测试框架，使用Javascript编写。基于UIAutomation有扩展型的工具框架和驱动型的框架。</p>
<p>​        扩展型框架以JavaScript扩展库方法提供了很多好用js工具，注入式的框架通常会提供一些Lib或者是Framework，要求测试人员在待测应用的代码工程中导入这些内容，框架可以通过他们完成对app的驱动。</p>
<p>​        驱动型UI Automation 在自动化测试底层使用了UI Automation库，通过TCP通信的方式驱动UI Automation来完成自动化测试，通过这种方式，编辑脚本的语言不再局限于JavaScript。</p>
<h4 id="Appium-1"><a href="#Appium-1" class="headerlink" title="Appium"></a><strong>Appium</strong></h4><p>​        它是通过驱动苹果的UIAutomation来执行自动化</p>
<h4 id="Frank"><a href="#Frank" class="headerlink" title="Frank"></a><strong>Frank</strong></h4><p>​        Frank是iOS平台一款非常受欢迎的app测试框架，它使用Cucumber语言来编写测试用例， Frank包含一个强大的“app inspector”–Symbiote，可以用它来获得运行中app的详细信息，便于开发者将来进行测试回顾。</p>
<p>​        优点： 测试场景是在Cucumber的帮助下，用可理解的英语句子写的。</p>
<p>强大的Symbiote实时检查工具。 活跃的社区支持。 不断扩大中的库。</p>
<p>​        缺点： 对手势的支持有限。 在设备上运行测试有点难。 修改配置文件需要在实际设备上运行。 记录功能不可用。</p>
<h4 id="KIF"><a href="#KIF" class="headerlink" title="KIF"></a><strong>KIF</strong></h4><p>​        KIF是Keep It Functional项目的缩写，是一款iOS app功能性测试框架，使用Objective-C语言编写，对苹果开发者来说非常容易上手，更是一款开发者广为推荐的测试工具。KIF tester使用私有API来了解App中的视图层级。但缺点是运行较慢。</p>
<h4 id="Calabash-1"><a href="#Calabash-1" class="headerlink" title="Calabash"></a><strong>Calabash</strong></h4><p>​        Calabash是一个适用于iOS和Android开发者的跨平台app测试框架，可用来测试屏幕截图、手势和实际功能代码。</p>
<h4 id="Subliminal"><a href="#Subliminal" class="headerlink" title="Subliminal"></a><strong>Subliminal</strong></h4><p>​        Subliminal是另一款与XCTest集成的框架。与KIF不同的是，它基于UIAutomation编写，旨在对开发者隐藏UIAutomation中一些复杂的细节。</p>
<h4 id="Kiwi"><a href="#Kiwi" class="headerlink" title="Kiwi"></a><strong>Kiwi</strong></h4><p>​        Kiwi是对XCTest的一个完整替代，使用xSpec风格编写测试。 Kiwi带有自己的一套工具集，包括expectations、mocks、stubs，甚至还支持异步测试。它是一个适用于iOS 开发的Behavior Driven Development（BDD）库，优点在于其简洁的接口和可用性，易于设置和使用，非常适合新手开发者。Kiwi使用Objective-C语言编写，易于IOS开发人员上手。</p>
<h4 id="Appecker"><a href="#Appecker" class="headerlink" title="Appecker"></a><strong>Appecker</strong></h4><p>​        Appecker是一款用于iOS系列系统的自动化测试框架，是腾讯的一个开源项目。Appecker采用Objective C为测试用例的开发语言, 完整支持iOS上的UI功能测试、单元测试并且可以良好地支持自动化运行。</p>
<h2 id="四、Android-app类型"><a href="#四、Android-app类型" class="headerlink" title="四、Android app类型"></a>四、<strong>Android</strong> <strong>app类型</strong></h2><h3 id="1-原生应用程序：（Native-App）"><a href="#1-原生应用程序：（Native-App）" class="headerlink" title="1. 原生应用程序：（Native App）"></a>1. <strong>原生应用程序：（Native App）</strong></h3><p>原生APP是什么？原生APP就是利用Android、iOS平台官方的开发语言、开发类库、工具进行开发。比如安卓的java语言，iOS的object-c 语言。在应用性能上和交互体验上应该是最好的。</p>
<p>优点：</p>
<p>1、可访问手机所有功能、可实现功能最齐全；</p>
<p>2、运行速度快、性能高，绝佳的用户体验；</p>
<p>3、支持大量图形和动画。不卡，反应快。</p>
<p>4、比较快捷地使用设备端提供的接口，处理速度上有优势。</p>
<p>缺点：</p>
<ol>
<li><p>在过去主要是成本高、周期长，Android和iOS都需要单独开发。</p>
</li>
<li><p>更新版本需要重新下载安装包。</p>
</li>
</ol>
<h3 id="2-混合应用程序（Hybrid-App）"><a href="#2-混合应用程序（Hybrid-App）" class="headerlink" title="2. 混合应用程序（Hybrid App）"></a>2. <strong>混合应用程序（Hybrid App）</strong></h3><p>即利用了原生APP的开发技术还应用了HTML5开发技术，是原生和HTML5技术的混合应用。混合比例不限。</p>
<p>优点：</p>
<p>1、开发周期短；</p>
<p>2、功能更新发布快；</p>
<p>缺点：</p>
<p>1、用户体验不如本地应用；</p>
<p>2、性能稍慢（需要连接网络）；</p>
<h3 id="3-Web版APP-（Web-App）"><a href="#3-Web版APP-（Web-App）" class="headerlink" title="3. Web版APP （Web App）"></a>3. <strong>Web版APP （Web App）</strong></h3><p>本质就是浏览器功能的叠加，用普通Web开发语言开发的，通过浏览器运行。</p>
<p>优势：</p>
<p>1、支持范围广；</p>
<p>2、开发成本低、周期短。</p>
<p>缺点：</p>
<p>1、对联网要求高，离线不能做任何操作；</p>
<p>2、功能有限；</p>
<p>3、运行速度慢，页面不能承载太多东西；</p>
<p>4、图片和动画支持性不高；</p>
<p>5、如果用户使用更多的新型浏览器，那么就会出现运行问题。</p>
<h3 id="4-Web-App、Hybrid-App、Native-App-技术特性"><a href="#4-Web-App、Hybrid-App、Native-App-技术特性" class="headerlink" title="4.Web App、Hybrid App、Native App 技术特性"></a><strong>4.Web App、Hybrid App、Native App 技术特性</strong></h3><img src="https://pic.imgdb.cn/item/61376c7044eaada73928096f.jpg">

<h3 id="5-手游app与手机App"><a href="#5-手游app与手机App" class="headerlink" title="5. 手游app与手机App"></a>5. <strong>手游app与手机App</strong></h3><p>手游一般使用引擎开发，现在著名的有cocos2d和unity3d。两者都是使用引擎自带的语言进行开发，主流的分别是c++和c#，虽然在开发过程中也有按钮等控件的概念，但当运行时由引擎渲染后就变成了一副简单的图片：</p>
<p>手机App一般使用Android SDK开发，使用Java编写。通过Android提供的服务，我们可以获取App当前窗口的视图信息，进而查找和操作按钮等控件，以完成自动化测试，如Uiautomator。这个过程是标准化的，从技术上来说没有任何难度，因此各个公司各个App自动化测试的方法都大同小异。</p>
<h2 id="五、Android-SDK介绍"><a href="#五、Android-SDK介绍" class="headerlink" title="五、Android    SDK介绍"></a>五、<strong>Android</strong>    <strong>SDK介绍</strong></h2><p>SDK：（software development kit）软件开发工具包。被软件开发工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。</p>
<p>因此，Android SDK 指的是Android专属的软件开发工具包。</p>
<h2 id="六、Android-SDK环境搭建"><a href="#六、Android-SDK环境搭建" class="headerlink" title="六、Android SDK环境搭建"></a>六、<strong>Android SDK环境搭建</strong></h2><h3 id="1-配置jdk环境"><a href="#1-配置jdk环境" class="headerlink" title="1.配置jdk环境"></a><strong>1.配置jdk环境</strong></h3><p>因为安卓用Java语言开发，所以安装安卓环境——首先需要安装配置好jdk环境(<a href="https://jingyan.baidu.com/article/3c343ff70bc6ea0d377963df.html">https://jingyan.baidu.com/article/3c343ff70bc6ea0d377963df.html</a>)</p>
<p>推荐使用 jdk 8以上的版本</p>
<h3 id="2-SDK下载"><a href="#2-SDK下载" class="headerlink" title="2.SDK下载"></a><strong>2.SDK下载</strong></h3><p>Android SDK包下载</p>
<p>· 官网下载：<a href="https://android-sdk.en.softonic.com/download">https://android-sdk.en.softonic.com/download</a></p>
<p>· 网盘下载： <a href="http://tools.android-studio.org/index.php/sdk">http://tools.android-studio.org/index.php/sdk</a></p>
<p>安装后启动 SDK Manager.exe程序就可以看到Android SDK Mannerger的主界面。</p>
<img src="https://pic.imgdb.cn/item/61376cde44eaada739294c74.jpg">

<h4 id="Tools目录："><a href="#Tools目录：" class="headerlink" title="Tools目录："></a><strong>Tools目录：</strong></h4><img src="https://pic.imgdb.cn/item/61376cf544eaada739298e69.jpg">

<p><strong>Android SDK Tools</strong>（必须，只需下载一个版本，一般选最新版本）：基础工具包，版本号带rc字样的是预览版。</p>
<p><strong>Android SDK Platform-tools必须</strong>，只需下载一个版本，一般选最新版本）：从android2.3开始划出此目录，存放公用开发工具，比如adb、sqlite3等，被划分到了这里。</p>
<p><strong>Android SDK Build-tools</strong>（必须，可以安装多个版本）：Android项目构建工具。</p>
<p><strong>Android xxx（API xx）</strong>目录（可选的各平台开发工具）</p>
<img src="https://pic.imgdb.cn/item/61376d0d44eaada73929d3b5.jpg">

<ul>
<li><p> Documentation for AndroidSdk（可选）：安卓开发者官网的一些离线文档，不过下载下来打开也很慢，后面会提供另外一个离线版。</p>
</li>
<li><p>SDK Platform** (必须）：对应平台的开发工具，需要在哪个版本的平台下开发就下载哪个。</p>
</li>
<li><p>Samples for SDK（可选)，此项在高版本tools中已不提供，需要在IDE里通过Import Sample引入，当然也可以下载离线版）：内置的安卓示例程序，推荐安装。</p>
</li>
<li><p>Sources for Android SDK（可选）：安卓API的源代码，推荐安装。</p>
</li>
<li><p> ARM /Intel xxxx Image（可选）：各个以Image结尾的东西是支持相应平台的模拟器，我们就把它想象成一个刷机包吧。（使用真机调试或使用其它模拟器的话不需要安装）</p>
</li>
</ul>
<p><strong>Extras</strong>目录(可选的扩展）</p>
<img src="https://pic.imgdb.cn/item/61376d1f44eaada7392a0bf1.jpg">

<ul>
<li><p>Android Support Repository（可选）：主要是方便在gradle中使用Android Support Libraries，因为Google并没有把这些库发布到maven center或者jcenter去，而是使用了Google自己的maven仓库。</p>
</li>
<li><p> Intel x86 Emulator Accelerator(HAXM installer)（可选）：windows平台的Intel x86模拟器加速工具，配合Intel x86 atom/atom_64 System Image使用可加快模拟器的运行速度。</p>
</li>
</ul>
<h3 id="3-Android-SDK文件目录"><a href="#3-Android-SDK文件目录" class="headerlink" title="3.Android SDK文件目录"></a><strong>3.Android SDK文件目录</strong></h3><img src="https://pic.imgdb.cn/item/61376d3944eaada7392a5721.jpg">

<h4 id="add-ons"><a href="#add-ons" class="headerlink" title="add-ons"></a><strong>add-ons</strong></h4><p>这里面保存着附加库，第三方公司为android 平台开发的附加功能系统。比如GoogleMaps，当然你如果安装了OphoneSDK，这里也会有一些类库在里面。</p>
<h4 id="docs"><a href="#docs" class="headerlink" title="docs"></a><strong>docs</strong></h4><p>这里面是Android SDKAPI参考文档，所有的API都可以在这里查到。</p>
<h4 id="extras"><a href="#extras" class="headerlink" title="extras"></a><strong>extras</strong></h4><p>该文件夹下存放了Android support v4，v7，v13，v17包； 还有google提供额USB驱动、Intel提供的硬件加速等附加工具包， 和market_licensing作为AndroidMarket版权保护组件，一般发布付费应用到电子市场可以用它来反盗版。</p>
<h4 id="platforms"><a href="#platforms" class="headerlink" title="platforms"></a><strong>platforms</strong></h4><p>是每个平台的SDK真正的文件，存放了不同版本的android系统。里面会根据APILevel划分的SDK版本。</p>
<h4 id="samples"><a href="#samples" class="headerlink" title="samples"></a><strong>samples</strong></h4><p>是Android SDK自带的默认示例工程，里面的apidemos强烈推荐初学者运行学 习，对于SQLite数据库操作可以查看NotePad这个例子，对于游戏开发Snake、LunarLander都是不错的例子，对于Android主 题开发Home则是androidm5时代的主题设计原理。</p>
<h4 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a><strong>环境变量设置</strong></h4><ul>
<li><p> 系统变量里面添加变量名 ANDROID_HOME 路径为实际存放SDk的路径</p>
</li>
<li><img src="https://pic.imgdb.cn/item/61376d6744eaada7392ad601.jpg"></li>
<li><p>其他几个路径配置到系统环境Path中如下图所示：</p>
<img src="https://pic.imgdb.cn/item/61376db144eaada7392b9aab.jpg"></li>
</ul>
<h2 id="七-配置检测"><a href="#七-配置检测" class="headerlink" title="七.配置检测"></a><strong>七.配置检测</strong></h2><p>在cmd界面输入“adb” 和”appt”来判断安装是否成功。</p>
<p>adb命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Shuqing&gt;adb</span><br><span class="line">Android Debug Bridge version 1.0.39</span><br><span class="line">Revision 3db08f2c6889-android</span><br><span class="line">Installed as E:\Andriod_sdk\platform-tools\adb.exe</span><br><span class="line">global options:</span><br><span class="line"> -a         listen on all network interfaces, not just localhost</span><br><span class="line"> -d         use USB device (error if multiple devices connected)</span><br><span class="line"> -e         use TCP/IP device (error if multiple TCP/IP devices available)</span><br><span class="line"> -s SERIAL</span><br><span class="line">     use device with given serial number (overrides $ANDROID_SERIAL)</span><br><span class="line"> -p PRODUCT</span><br><span class="line">     name or path (&#x27;angler&#x27;/&#x27;out/target/product/angler&#x27;);</span><br><span class="line">     default $ANDROID_PRODUCT_OUT</span><br><span class="line"> -H         name of adb server host [default=localhost]</span><br><span class="line"> -P         port of adb server [default=5037]</span><br><span class="line"> -L SOCKET  listen on given socket for adb server [default=tcp:localhost:5037]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> aapt命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Shuqing&gt;aapt</span><br><span class="line">Android Asset Packaging Tool</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> aapt l[ist] [-v] [-a] file.&#123;zip,jar,apk&#125;</span><br><span class="line">   List contents of Zip-compatible archive.</span><br><span class="line"></span><br><span class="line"> aapt d[ump] [--values] [--include-meta-data] WHAT file.&#123;apk&#125; [asset [asset ...]]</span><br><span class="line">   strings          Print the contents of the resource table string pool in the APK.</span><br><span class="line">   badging          Print the label and icon for the app declared in APK.</span><br><span class="line">   permissions      Print the permissions from the APK.</span><br><span class="line">   resources        Print the resource table from the APK.</span><br><span class="line">   configurations   Print the configurations in the APK.</span><br><span class="line">   xmltree          Print the compiled xmls in the given assets.</span><br><span class="line">   xmlstrings       Print the strings of the given compiled xml assets.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h4><p>· <a href="#m2">http://www.cnblogs.com/kangjianwei101/p/5621238.html#m2</a></p>
<p>· <a href="http://blog.csdn.net/aiynmimi/article/details/51028499">http://blog.csdn.net/aiynmimi/article/details/51028499</a></p>
]]></content>
  </entry>
  <entry>
    <title>monkey</title>
    <url>/2021/09/05/monkey/</url>
    <content><![CDATA[<h2 id="一、Monkey简介"><a href="#一、Monkey简介" class="headerlink" title="一、Monkey简介"></a>一、<strong>Monkey简介</strong></h2><p>在Android的官方自动化测试领域有一只非常著名的“猴子”叫Monkey，这只“猴子”一旦启动，就会让被测的Android应用程序像猴子一样活蹦乱跳，到处乱跑。人们常用这只“猴子”来对被测程序进行压力测试，检查和评估被测程序的稳定性。</p>
<span id="more"></span>

<p>Android官方对这只“猴子”的描述是这样的：</p>
<p>The Monkey is a program that runs on your emulator or device and generates pseudo-random streams of user events such as clicks, touches, or gestures, as well as a number of system-level events. You can use the Monkey to stress-test applications that you are developing, in a random yet repeatable manner.</p>
<p>Monkey是一个程序，运行在您的模拟器或设备上，并生成伪随机的用户事件流，如点击，触摸或手势，以及一些系统级事件。 您可以使用Monkey以随机但可重复的方式对您正在开发的应用程序进行压力测试。</p>
<p>monkey官方文档：<a href="http://www.android-doc.com/tools/help/monkey.html">http://www.android-doc.com/tools/help/monkey.html</a></p>
<h2 id="二、Moneky-路径"><a href="#二、Moneky-路径" class="headerlink" title="二、Moneky 路径"></a>二、<strong>Moneky 路径</strong></h2><p>Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的Monkey文件，其jar包是位于Android系统的/system/framework目录的Monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。同时，Monkey还会对测试系统进行监测，当出现以下三种情况时会进行特殊处理：</p>
<ul>
<li> 如限定了Monkey运行在特定包上，当监测到试图转到其他包的操作，将对其进行阻止。</li>
<li> 如应用程序崩溃或接收到任何失控异常，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</li>
<li> 如果应用程序发生了程序无响应（application not responding）的错误，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</li>
<li> 按照选定的不同级别的反馈信息，在Monkey中还可以看到其执行过程报告和生成的事件。</li>
</ul>
<h2 id="三、Monkey启动步骤"><a href="#三、Monkey启动步骤" class="headerlink" title="三、Monkey启动步骤"></a>三、<strong>Monkey启动步骤</strong></h2><ol>
<li> 连接模拟器</li>
<li> 连接成功后输入命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb  shell</span><br></pre></td></tr></table></figure>



<h2 id="四、进入到指定目录"><a href="#四、进入到指定目录" class="headerlink" title="四、进入到指定目录"></a>四、<strong>进入到指定目录</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /system/bin</span><br></pre></td></tr></table></figure>

<ol>
<li><p>输入 monkey命令看到如下提示则说明启动成功。</p>
<img src="https://pic.imgdb.cn/item/6137704644eaada73931f0ea.jpg"></li>
</ol>
<h2 id="五、强制关闭monkey"><a href="#五、强制关闭monkey" class="headerlink" title="五、强制关闭monkey"></a>五、<strong>强制关闭monkey</strong></h2><ol>
<li><p>adb shell ps 查看全部在运行的进程</p>
</li>
<li><p>查找出com.android.commands.monkey 进程PID</p>
</li>
<li><p>adb shell kill pid 杀掉monkey进程</p>
</li>
</ol>
<h2 id="六、monkey-命令"><a href="#六、monkey-命令" class="headerlink" title="六、monkey 命令"></a>六、<strong>monkey 命令</strong></h2><p>monkey命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey [options] &lt;event-count&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>[options]是指monkey可传入的参数，是可选项（如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包）</li>
<li><event-count>是指随机发送事件数。如：输入100就是执行100个伪随机事件，为必选项。</li>
</ul>
<h2 id="七、操作事件简介"><a href="#七、操作事件简介" class="headerlink" title="七、操作事件简介"></a>七、<strong>操作事件简介</strong></h2><p>Monkey所执行的随机事件流中包含11大事件，分别是触摸事件、手势事件、二指缩放事件、轨迹事件、屏幕旋转事件、基本导航事件、主要导航事件、系统按键事件、启动Activity事件、键盘事件、其他类型事件。Monkey通过这11大事件来模拟用户的常规操作，对手机App进行稳定性测试。下面让我们来详细了解这11大事件。</p>
<h3 id="1-触摸事件"><a href="#1-触摸事件" class="headerlink" title="1.触摸事件"></a><strong>1.触摸事件</strong></h3><p>触摸事件是指在屏幕某处按下并抬起的操作，可通过**–pct-touch**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到。 </p>
<p>该事件由一组Touch（ACTION_DOWN）和Touch（ACTION_UP）事件组成，在手机上看到实际操作类似于点击。</p>
<h3 id="2-手势事件"><a href="#2-手势事件" class="headerlink" title="2.手势事件"></a><strong>2.手势事件</strong></h3><p>手势事件是指在屏幕某处的按下、随机移动、抬起的操作，即直线滑动操作。可通过**–pct-motion**参数来配置其事件百分比。</p>
<p>该事件是由一个ACTION_DOWN事件、一系列ACTION_MOVE事件和一个ACTION_UP事件组成的，在手机上看到的实际操作是一个没有拐弯的直线滑动操作。</p>
<h3 id="3-二指缩放事件"><a href="#3-二指缩放事件" class="headerlink" title="3.二指缩放事件"></a><strong>3.二指缩放事件</strong></h3><p>二指缩放事件是指在屏幕上的两处同时按下，并同时移动，最后同时抬起的操作，即智能机上的放大缩小手势操作。可通过**–pct-pinchzoom**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p>该事件起始是一个ACTION_DOWN事件和一个ACTION_POINTER_DOWN事件，即模拟两个手指同时点下；中间是一系列的ACTION_MOVE事件，即两个手指同时在屏幕上直线滑动；结束是由一个ACTION_POINTER_UP事件和一个ACTION_UP事件组成的，即两个手指同时放开。</p>
<h3 id="4-轨迹事件"><a href="#4-轨迹事件" class="headerlink" title="4.轨迹事件"></a><strong>4.轨迹事件</strong></h3><p>轨迹事件是由一个或多个随机的移动组成的，有时会伴随着点击。很早之前的Android手机带有轨迹球，这个事件就是模拟的轨迹球的操作。现在的手机几乎都没有轨迹球，但轨迹球事件中包含曲线滑动操作，如果被测程序需要曲线滑动时可以选用此参数。可通过**–pct-trackball**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p>该事件是由一系列的Trackball（ACTION_MOVE）事件组成的，观察手机上的操作，即为一系列的曲线滑动操作。</p>
<h3 id="5-屏幕旋转事件"><a href="#5-屏幕旋转事件" class="headerlink" title="5.屏幕旋转事件"></a><strong>5.屏幕旋转事件</strong></h3><p>屏幕旋转事件是一个隐藏事件，在Android官方文档中并没有记录这个事件。它其实是模拟的Android手机的横屏和竖屏切换。可通过**–pct-rotation**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p> [代码] 该事件由一个rotation事件组成，其中degree表示的是旋转方向，顺时针旋转，0表示旋转90度的方向，1表示旋转180度的方向，2表示旋转270度的方向，3表示旋转360度的方向。在执行过程中，可以看到手机屏幕在横竖屏之间不断地切换。</p>
<h3 id="6-基本导航事件"><a href="#6-基本导航事件" class="headerlink" title="6.基本导航事件"></a><strong>6.基本导航事件</strong></h3><p>基本导航事件是指点击方向输入设备的上、下、左、右按键的操作，现在手机上很少有上、下、左、右按键，这种事件一般用得比较少。可通过**–pct-nav**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p>该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上、下、左、右四个方向按键。</p>
<h3 id="7-主要导航事件"><a href="#7-主要导航事件" class="headerlink" title="7.主要导航事件"></a><strong>7.主要导航事件</strong></h3><p>主要导航事件是指点击“主要导航”按键的操作，这些按键通常会导致UI界面中的动作，如键盘的中间键、回退按键、菜单按键。可通过**–pct-majornav**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p> [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是中间键和菜单键。</p>
<h3 id="8-系统按键事件"><a href="#8-系统按键事件" class="headerlink" title="8.系统按键事件"></a><strong>8.系统按键事件</strong></h3><p>系统按键事件是指点击系统保留使用的按键的操作，如点击Home键、返回键、音量调节键等。可通过**–pct-syskeys**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： </p>
<p>[代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上面说到的几个系统按键。</p>
<h3 id="9-启动Activity事件"><a href="#9-启动Activity事件" class="headerlink" title="9.启动Activity事件"></a><strong>9.启动Activity事件</strong></h3><p>启动Activity事件是指在手机上启动一个Activity的操作。在随机的时间间隔中，Monkey将执行一个startActivity（）方法，作为最大限度上覆盖被测包中全部Activity的一种方法。可通过-<strong>-pct-appswitch</strong>参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p> [代码] 该事件是由一个Switch操作组成的，从手机上看，上面的操作实际是打开了com.android.settings这个应用的一个com.android.settings.Settings的Activity界面。</p>
<h3 id="10-键盘事件"><a href="#10-键盘事件" class="headerlink" title="10.键盘事件"></a><strong>10.键盘事件</strong></h3><p>键盘事件主要是一些与键盘相关的操作。比如点击输入框、键盘弹起、点击输入框以外区域、键盘收回等。可通过-<strong>-pct-flip</strong>参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： </p>
<p>[代码] 如日志所示，这里主要是键盘的打开和关闭操作。</p>
<h3 id="11-其他类型事件"><a href="#11-其他类型事件" class="headerlink" title="11.其他类型事件"></a><strong>11.其他类型事件</strong></h3><p>其他类型事件包括了除前面提到的10种事件外其他所有的事件，如按键、其他不常用的设备上的按钮等。可通过**–pct-anyevent**参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p> [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是其他的一些系统按键，如字母按键、数字按键等。因为现在手机很少带字母按键或数字按键，所以这个事件一般使用得比较少。</p>
<h2 id="八、monkey-参数"><a href="#八、monkey-参数" class="headerlink" title="八、monkey 参数"></a>八、<strong>monkey 参数</strong></h2><h3 id="1-参数分类"><a href="#1-参数分类" class="headerlink" title="1. 参数分类"></a>1. <strong>参数分类</strong></h3><ul>
<li> 常规类参数</li>
<li>事件类参数</li>
<li>约束类参数</li>
<li>调试类参数</li>
</ul>
<h3 id="2-常规类参数"><a href="#2-常规类参数" class="headerlink" title="2. 常规类参数"></a>2. <strong>常规类参数</strong></h3><p>常规类参数包括帮助参数和日志信息参数。帮助参数用于输出Monkey命令使用指导；日志信息参数将日志分为三个级别，级别越高，日志的信息越详细。</p>
<p>1.帮助类参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monkey -h</span><br></pre></td></tr></table></figure>

<p>2.日志级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey -v &lt;event-count&gt;</span><br></pre></td></tr></table></figure>

<p>-v：打印出日志信息，每个-v将增加反馈信息的级别。-v越多日志信息越详细，不过目前最多支持3个-v：</p>
<img src="https://pic.imgdb.cn/item/6137707a44eaada739328274.jpg">

<img src="https://pic.imgdb.cn/item/6137708b44eaada73932acb8.jpg">

<h3 id="3-事件类参数"><a href="#3-事件类参数" class="headerlink" title="3.事件类参数"></a>3.事件类参数</h3><p>类参数的作用是对随机事件进行调控，从而使其遵照设定运行，如设置各种事件的百分比、设置事件生成所使用的种子值等。频率参数主要限制事件执行的时间间隔。</p>
<p>1.执行指定脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey -f &lt;scriptfile&gt; &lt;event-count&gt;</span><br><span class="line">eg：</span><br><span class="line">$ adb shell monkey -f /mnt/sdcard/test1</span><br></pre></td></tr></table></figure>

<p>2.伪随机数生成种子值</p>
<p>使用 -s命令可以重复执行之前的伪随机操作。本身每次执行伪随机事件操作也会默认生成一个seed值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey -s &lt;seed&gt; &lt;event-count&gt;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">$ adb shell monkey -s 666 100</span><br></pre></td></tr></table></figure>

<p>3.设置间隔 如果你希望在每一个指令之间加上固定的间隔时间，可以用–throttle（注意，前面是–）命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --throttle &lt;milliseconds&gt;</span><br><span class="line">eg:</span><br><span class="line">$ adb shell monkey --throttle 3000  5</span><br></pre></td></tr></table></figure>

<p>–throttle：后面接时间，单位为ms（<milliseconds>），表示事件之间的固定延迟（即执行每一个指令间隔的时间），若不接该选项，monkey将不会延迟。</p>
<p>4.调整触摸事件百分比</p>
<p>如果你希望调整触摸事件的百分比，记住使用–pct-touch。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --pct-touch</span><br><span class="line">eg:</span><br><span class="line">$ adb shell monkey -v -v --pct-touch 100 200</span><br></pre></td></tr></table></figure>

<p> <percent>–pct-touch：后面接触摸事件百分比</p>
<p><strong>注意</strong>：触摸事件不单单是按键，它泛指发生在某一位置的一个down-up事件。</p>
<p>5.调整手势事件百分比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --pct-motion</span><br><span class="line">eg:</span><br><span class="line">$ adb shell monkey -v -v --pct-motion 100 200</span><br></pre></td></tr></table></figure>

<p>6.调整应用启动事件的百分比</p>
<p>如果你希望调整应用启动事件的百分比，记住使用–pct-app-switch。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --pct-appswtich &lt;percent&gt;</span><br></pre></td></tr></table></figure>

<p>–pct-appswitch：后面接应用启动事件百分比。</p>
<p>应用启动事件（即activity launches）俗称打开应用，通过调用startActivity()方法最大限度地开启该package下的所有应用。</p>
<p>7.调整屏幕旋转事件百分比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --pct-rotation &lt;percent&gt;</span><br></pre></td></tr></table></figure>

<p>–pct-rotation 后面接屏幕旋转事件的比例值。</p>
<p>8.其他参数</p>
<img src="https://pic.imgdb.cn/item/613770de44eaada739338427.jpg">

<h3 id="4-约束类参数"><a href="#4-约束类参数" class="headerlink" title="4. 约束类参数"></a>4. <strong>约束类参数</strong></h3><h4 id="1-包约束"><a href="#1-包约束" class="headerlink" title="1.包约束"></a><strong>1.包约束</strong></h4><p>-p：后面接一个或多个包名（<allowed-package-name>），如果应用需要访问其他包里的Activity，那相关的包也需要在此同时指定。如果不指定任何包，monkey将允许系统启动全部包里的Activity。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey -p &lt;allowed-package-name&gt; &lt;event-count&gt;</span><br><span class="line">eg：</span><br><span class="line">$ adb shell monkey -p com.tal.kaoyan 500</span><br><span class="line"></span><br><span class="line">$ adb shell monkey -p com.tal.kaoyan -p com.tencent.mm 500</span><br></pre></td></tr></table></figure>

<h4 id="2-activity类约束"><a href="#2-activity类约束" class="headerlink" title="2.activity类约束"></a><strong>2.activity类约束</strong></h4><p>如果你希望将monkey限制在一个或几个类别中，使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey -c &lt;main-category&gt; &lt;event-count&gt;</span><br></pre></td></tr></table></figure>

<p>以下命令表示运行Intent.CATEGORY_LAUNCHER类别的Activity并发送1000个随机事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey -c Intent.CATEGORY_LAUNCHER  1000</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/6137710244eaada73933e3bf.jpg">

<h3 id="5-调试类参数"><a href="#5-调试类参数" class="headerlink" title="5. 调试类参数"></a>5. <strong>调试类参数</strong></h3><h4 id="1-应用程序崩溃后继续发送事件"><a href="#1-应用程序崩溃后继续发送事件" class="headerlink" title="1.应用程序崩溃后继续发送事件"></a><strong>1.应用程序崩溃后继续发送事件</strong></h4><p>如果你希望monkey在应用程序崩溃后继续发送事件，则需要用到–ignore-crashes命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --ignore-crashes &lt;event-count&gt; </span><br></pre></td></tr></table></figure>

<p>在设置此选项后，当应用程序崩溃或发生失控异常时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到上述崩溃或异常将停止运行。</p>
<h4 id="2-超时错误继续发送事件"><a href="#2-超时错误继续发送事件" class="headerlink" title="2.超时错误继续发送事件"></a><strong>2.超时错误继续发送事件</strong></h4><p>如果你希望monkey在任何超时错误发生后继续发送事件，则需要用到–ignore-timeouts命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --ignore-timeouts</span><br></pre></td></tr></table></figure>

<p><event-count>–ignore-timeouts：在设置此选项后，当应用程序发生任何超时错误（如ANR，即Application Not Responding）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类超时对话框将停止运行。</p>
<h4 id="3-应用程序权限错误发生后继续发送事件"><a href="#3-应用程序权限错误发生后继续发送事件" class="headerlink" title="3.应用程序权限错误发生后继续发送事件"></a><strong>3.应用程序权限错误发生后继续发送事件</strong></h4><p>如果你希望monkey在应用程序权限错误发生后继续发送事件，则需要用到–ignore-security-exceptions命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey --ignore-security-exceptions</span><br></pre></td></tr></table></figure>

<p><event-count>–ignore-security-exceptions：在设置此选项后，当应用程序发生任何权限错误（如启动一个需要某些权限的Activity）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类权限错误将停止运行。 </p>
<h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a><strong>4.其他</strong></h4><img src="https://pic.imgdb.cn/item/6137711644eaada7393416cc.jpg">



<h2 id="九、Monkey参数应用综合案例"><a href="#九、Monkey参数应用综合案例" class="headerlink" title="九、Monkey参数应用综合案例"></a>九、<strong>Monkey参数应用综合案例</strong></h2><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a><strong>测试场景</strong></h3><p>测试考研帮app Android版。测试希望通过Monkey来模拟用户的随机操作，检查被测应用是否会出现异常（应用崩溃或者无响应）。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h3><p>1、测试是指定应用，因此需要使用-p指定被测app包名：com.tal.kaoyan</p>
<p>2、这个测试的目的是希望模拟用户操作，因此需要让Monkey执行的事件尽可能地接近用户的常规操作，这样才可以最大限度地发现用户使用过程中可能出现的问题。因此需要对Monkey执行的事件百分比做一些调整:</p>
<p>触摸事件和手势事件是用户最常见的操作，所以通过**–pct-touch<strong>和-</strong>-pct-motion<strong>将这两个事件的占比调整到40%与25%；目标应用包含了多个Activity，为了能覆盖大部分的Activity，所以通过</strong>–pct-appswitch<strong>将Activity切换的事件占比调整到10%；被测应用在测试中出现过不少横竖屏之间切换的问题，这个场景也必须关注，因此通过</strong>–pct-rotation**把横竖屏切换事件调整到10%。</p>
<p>3、使用-s参数来指定命令执行的seed值 Monkey会根据seed值来生成对应事件流，同一个seed生成的事件流是完全相同的。这里指定了seed值，是为了测试发现问题时，便于进行问题复现。</p>
<p>4、使用–throttle参数来控制Monkey每个操作之间的时间间隔 指定操作之间的时间间隔，一方面是希望能更接近用户的操作场景，正常用户操作都会有一定的时间间隔；另一方面也是不希望因为过于频繁的操作而导致系统崩溃，尤其是在比较低端的手机上执行测试时。因此通过–throttle设置Monkey每个操作固定延迟0.4秒。</p>
<p>5、使用**–ignore-crashs<strong>和-</strong>-ignore-timeouts**参数使Monkey遇到意外时能继续执行 在执行Monkey测试时，会因为应用的崩溃或没有响应而意外终止，所以需要在命令中增加限制参数–ignore-crash和–ignore-timeouts，让Monkey在遇到崩溃或没有响应的时候，能在日志中记录相关信息，并继续执行后续的测试。</p>
<p>6、使用-v指定log的详细级别 Monkey的日志输出有3个级别：日志的级别越高，其详细程度也越高。为了方便问题的定位，这里将日志设为 -v -v.</p>
<h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a><strong>测试命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p com.tal.kaoyan</span><br><span class="line"></span><br><span class="line">--pct-touch 40 --pct-motion 25 </span><br><span class="line"></span><br><span class="line">--pct-appswitch 10</span><br><span class="line"></span><br><span class="line">--pct-rotation 5</span><br><span class="line"></span><br><span class="line">-s 1666 --throttle 400</span><br><span class="line"></span><br><span class="line">--ignore-crashes</span><br><span class="line"></span><br><span class="line">--ignore-timeouts</span><br><span class="line"></span><br><span class="line">-v -v  200</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>接口测试之postman工具</title>
    <url>/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B9%8Bpostman%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="一、postman-的概述"><a href="#一、postman-的概述" class="headerlink" title="一、postman 的概述"></a>一、postman <strong>的概述</strong></h1><h2 id="1-为什么使用-postman？"><a href="#1-为什么使用-postman？" class="headerlink" title="1. 为什么使用 postman？"></a><strong>1.</strong> <strong>为什么使用</strong> postman？</h2><p>一般简单的接口测试我们可以直接在浏览器里面进行调试，但是涉及到一些权限设置的 就无法操作了，因此我们需 要接口测试的相关工具；Postman 是一个接口测试和 http 请 求的工具。<span id="more"></span> </p>
<h2 id="2-Postman-的下载、安装"><a href="#2-Postman-的下载、安装" class="headerlink" title="2. Postman 的下载、安装"></a><strong>2. Postman</strong> <strong>的下载、安装</strong></h2><p>Postman 有 windows,Mac、Liunx 以及 Chrome 插件版本。这里主要介绍 Win 平 台软件版本的使用。 </p>
<p>软件下载地址：<a href="https://dl.pstmn.io/download/latest/win64">https://dl.pstmn.io/download/latest/win64</a> </p>
<img src="https://pic.imgdb.cn/item/6137859044eaada7396522f0.png">

<p>当然这软件不能支持设置中文，如果对想看中文的，可以下载这款国产高仿的接口</p>
<p>软件：apipost </p>
<img src="https://pic.imgdb.cn/item/613785ca44eaada73965a582.png">

<p>软件官网：<a href="https://www.apipost.cn/#">https://www.apipost.cn/#</a> </p>
<p>软件手册：<a href="https://doc.apipost.cn/4a77c87f97fb686b">https://doc.apipost.cn/4a77c87f97fb686b</a> </p>
<p><strong>3. Postman</strong> <strong>的优缺点</strong> </p>
<ol>
<li>支持各种的请求类型: get、post、put、patch、delete 等 </li>
<li>支持在线存储数据，通过账号就可以进行迁移数据 </li>
<li>很方便的支持请求 header 和请求参数的设置 </li>
<li>支持不同的认证机制，如 Basic Auth，Digest Auth，OAuth 1.0，OAuth 2.0 等 </li>
<li>响应数据是自动按照语法格式高亮的，包括 HTML，JSON 和 XML</li>
</ol>
<p><strong>Postman</strong> <strong>的界面介绍</strong> </p>
<p><strong>A.</strong> <strong>Postman</strong> <strong>界面的组成</strong> </p>
<img src="https://pic.imgdb.cn/item/6137865544eaada73966d067.png">

<p><strong>B.</strong> <strong>控制台</strong> </p>
<p>postman 控制台：先打开 console，再点击 send 发送请求</p>
<img src="https://pic.imgdb.cn/item/6137869244eaada739676121.png">

<p>devtools 控制台：view –&gt;developer 下 </p>
<p>快捷键（ctrl+shift+I） </p>
<img src="https://pic.imgdb.cn/item/613786c144eaada73967c5e1.png">

<p><strong>C.</strong> <strong>基本的使用</strong> </p>
<p>new，新建按钮，可以创建：请求、集合、环境变量、文档、Mock 服务器、 监视器、模版、API network </p>
<img src="https://pic.imgdb.cn/item/6137870e44eaada739686cb8.png">

<p>Request：创建一个基本的请求 </p>
<p>Collection：就是请求的集合，里面可放多个请求，这些请求可以组成一组相关的测试场景 </p>
<p>Environment：环境变量，用变量替代 URL 中的参数值 </p>
<p>Monitor：监视器，定时运行接口，并收集、检查性能和相应结果（局域网不能使用，只支 持公网的 ip 请求；免费版使用次数有限制） </p>
<p>API Documemtation：创建接口文档 </p>
<p><strong>5.</strong> <strong>使用</strong> <strong>Postman</strong> <strong>的发送一个请求</strong> </p>
<ol>
<li><p>启动软件后在引导界面点击 Request，给 Request 命名，然后创建文件夹并把该 Request 归属到该文件夹。 </p>
</li>
<li><p>在地址栏输入 postman-echo.com/get 然后点击 Send 按钮，可以看到返回值。 </p>
</li>
</ol>
<p>如下图所示：</p>
<img src="https://pic.imgdb.cn/item/6137877144eaada7396941d2.png">

<h1 id="二、Postman-的工作原理"><a href="#二、Postman-的工作原理" class="headerlink" title="二、Postman 的工作原理"></a>二、Postman 的工作原理</h1><p>如下图所示，当您在 Postman 中输入请求并单击 Send 按钮时，服务器将接收您的 请求并返回 Postman 在接口中显示的响应。 </p>
<img src="https://pic.imgdb.cn/item/6137879b44eaada739699ee2.png">

<p><strong>Request 编辑</strong> </p>
<p>在主界面左侧可以查看、保存、编辑 Request。</p>
<h1 id="三、Postman发送多种请求"><a href="#三、Postman发送多种请求" class="headerlink" title="三、Postman发送多种请求"></a><strong>三、Postman发送多种请求</strong></h1><h2 id="1-发送-get-请求"><a href="#1-发送-get-请求" class="headerlink" title="1. 发送 get 请求"></a><strong>1.</strong> <strong>发送</strong> <strong>get</strong> <strong>请求</strong></h2><p>HTTP GET 请求方法用于从服务器检索数据。 数据由唯一的 URI(统一资源标识符)标 识。 GET 请求可以使用“Query String Parameters”将参数传递给服务器。 例如，在 下面的请求中： </p>
<p>案例：查询快递 100 的接口，下面准备接口地址 </p>
<p><a href="https://www.kuaidi100.com/query?type=yuantong&amp;postid=123456">https://www.kuaidi100.com/query?type=yuantong&amp;postid=123456</a> </p>
<p><strong>说明：</strong></p>
<p>Type、postid 表示发送的参数 </p>
<p>？问号后面连接参数 </p>
<p>&amp;表示连接多个参数 </p>
<p><strong>编辑参数：</strong> </p>
<img src="https://pic.imgdb.cn/item/613787f044eaada7396a54c4.png">

<p>解释：</p>
<p>Type 设置的快递公司名称的拼音 </p>
<p>Postid:表示快递的单号</p>
<h2 id="2-发送-post-请求"><a href="#2-发送-post-请求" class="headerlink" title="2. 发送 post 请求"></a><strong>2.</strong> <strong>发送</strong> <strong>post</strong> <strong>请求</strong></h2><p>HTTP POST 请求方法旨在将数据传输到服务器，返回的数据取决于服务器的实现。 </p>
<p>POST 请求可以使用 Query String Parameters 以及 body 将参数传递给服务器 </p>
<p><strong>案例1：</strong></p>
<p><strong>https</strong>://postman-echo.com/post?param=java </p>
<p>返回值： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&quot;args&quot;: &#123; </span><br><span class="line">&quot;param&quot;: &quot;java&quot; </span><br><span class="line">&#125;,</span><br><span class="line">&quot;data&quot;: &#123;&#125;, </span><br><span class="line">&quot;files&quot;: &#123;&#125;, </span><br><span class="line">&quot;form&quot;: &#123;&#125;, </span><br><span class="line">&quot;headers&quot;: &#123; </span><br><span class="line">&quot;x-forwarded-proto&quot;: &quot;https&quot;, </span><br><span class="line">&quot;x-forwarded-port&quot;: &quot;443&quot;, </span><br><span class="line">&quot;host&quot;: &quot;postman-echo.com&quot;, </span><br><span class="line">&quot;x-amzn-trace-id&quot;: &quot;Root=1-5f297e6e-ff1108001ac45200f71e6e00&quot;, </span><br><span class="line">&quot;content-length&quot;: &quot;0&quot;, </span><br><span class="line">&quot;cache-control&quot;: &quot;no-cache&quot;, </span><br><span class="line">&quot;postman-token&quot;: &quot;69f685b5-96ab-4ca2-83b5-26f4e1c50203&quot;, </span><br><span class="line">&quot;user-agent&quot;: &quot;PostmanRuntime/7.4.0&quot;, </span><br><span class="line">&quot;accept&quot;: &quot;*/*&quot;, </span><br><span class="line">&quot;cookie&quot;: &quot;sails.sid=s%3AwSs2NC8SufYRF_X8JSeoRRYm2S8zld8-.0lM9TgljEowpovt7s9T4jobFlIbPoF5e6gaYBSiw758&quot;, </span><br><span class="line">&quot;accept-encoding&quot;: &quot;gzip, deflate&quot; </span><br><span class="line">&#125;,</span><br><span class="line">&quot;json&quot;: null, </span><br><span class="line">&quot;url&quot;: &quot;https://postman-echo.com/post?param=java&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例 2：</strong></p>
<p>发送一个 Request，其中 body 为 application/x-www-form-urlencoded 类型，别为 param1=wulibobo 和 param2=888 </p>
<p>请 求 URL 如下： </p>
<p><a href="https://postman-echo.com/post">https://postman-echo.com/post</a> </p>
<img src="https://pic.imgdb.cn/item/6137881f44eaada7396abdef.png">

<p><strong>Postman Body 数据类型说明：</strong> </p>
<p>• <strong>form-data</strong> multipart/form-data 是 Web 表单用于传输数据的默认编码。这模拟了在 网站上填写表单并提 交它。表单数据编辑器允许我们为数据设置键-值对。我们也可以为文 件设置一个键，文件本身作为值进行 设置。 </p>
<p>• <strong>x-www-form-urlencoded</strong> 该编码与 URL 参数中使用的编码相同。我们只需输入键- 值对，Postman 会 正确编码键和值。请注意，我们无法通过此编码模式上传文件。表单 数据和 urlencoded 之间可能存在一些差异，因此请务必首先检查 API 的编码实现，确定 是否可以使用这种方式发送请求。 </p>
<p>• <strong>raw</strong> 请求可以包含任何内容。除了替换环境变量之外，Postman 不触碰在编辑器中输入 的字符串。无论你 在编辑区输入什么内容，都会随请求一起发送到服务器。编辑器允许我 们设置格式类型以及使用原始主体 发送的正确请求头。我们也可以手动设 Content-Type 标题，这将覆盖 Postman 定义的设置。 </p>
<p>• <strong>binary</strong> 二进制数据可让我们发送 Postman 中无法输入的内容，例如图像，音频或视频 文件。 </p>
<h2 id="3-发送-put-请求"><a href="#3-发送-put-请求" class="headerlink" title="3. 发送 put 请求"></a><strong>3.</strong> <strong>发送</strong> <strong>put</strong> <strong>请求</strong></h2><p>HTTP PUT 请求主要是从客户端向服务器传送的数据取代指定的文档的内容。 </p>
<p>PUT 请求可以使用 Query String Parameters 以及 body 请求体将参数传递给服务器。 </p>
<p><strong>案例：发送 put 请求，并传递字符串参数“xxxx”</strong></p>
<img src="https://pic.imgdb.cn/item/613788b544eaada7396bfb44.png">

<p><strong>4.</strong> <strong>发送</strong> <strong>delete</strong> <strong>请求</strong> </p>
<p>HTTP DELETE 方法用于删除服务器上的资源，DELETE </p>
<p>请求可以使用 Query String </p>
<p>Parameters 以及 body 请求体将 参数传递给服务器。 </p>
<p>准备接口参数：</p>
<p><a href="https://postman-echo.com/delete">https://postman-echo.com/delete</a></p>
<img src="https://pic.imgdb.cn/item/613788d744eaada7396c4599.png">

<p><strong>5.</strong> <strong>请求头</strong> </p>
<p>Request Header（请求头）用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、User-Agent 等。在 Postman 中可以在请求下方的 Headers 栏目来 设置，如下如图所示： </p>
<p><strong>准备接口参数：</strong> </p>
<p><a href="https://postman-echo.com/post?param=java&amp;m=C#">https://postman-echo.com/post?param=java&amp;m=C#</a> </p>
<p>如图：</p>
<img src="https://pic.imgdb.cn/item/6137894044eaada7396d1fdd.png">

<p><strong>6.</strong> <strong>响应头</strong> </p>
<p>Response Header(响应头)其中包含了服务器对请求的应答信息，如 </p>
<p>Content-Type、Server、Set-Cookie 等， 在 Postman 主界面下方 Headers 或者 Postman Console 界面都可以查看 Response Header 信息。 </p>
<img src="https://pic.imgdb.cn/item/6137897244eaada7396d874b.png">

<h1 id="四、授权设置"><a href="#四、授权设置" class="headerlink" title="四、授权设置"></a><strong>四、授权设置</strong></h1><p>很多时候，出于安全考虑我们的接口并不希望对外公开。这个时候就需要使用授权 (Authorization)机制 授权过程 验证您是否具有访问服务器所需数据的权限。 </p>
<p>当您发送请求时，您通常必须包含参数，以确保请求具有访问和返 回所需数据的权限。 </p>
<p>Postman 提供授权类型，可以轻松地在 Postman 本地应用程序中处理身份验证协 议。</p>
<p><strong>Postman 支持的授权协议类型如下：</strong> </p>
<p>• No Auth• Bearer Token</p>
<p>• Basic auth</p>
<p>• Digest Auth</p>
<p>• OAuth 1.0</p>
<p>• OAuth 2.0 </p>
<p>• Hawk Authentication</p>
<p>• AWS Signature </p>
<p>• NTLM Authentication [Beta] </p>
<p>这里主要介绍以上加粗标红的授权协议。</p>
<h2 id="1-如何打开授权界面"><a href="#1-如何打开授权界面" class="headerlink" title="1. 如何打开授权界面"></a><strong>1.</strong> <strong>如何打开授权界面</strong></h2><p><strong>下方演示如何打开授权界面</strong> </p>
<img src="https://pic.imgdb.cn/item/61378a1944eaada7396eed20.png">

<h2 id="2-Basic-auth-授权"><a href="#2-Basic-auth-授权" class="headerlink" title="2. Basic auth 授权"></a><strong>2. Basic auth</strong> <strong>授权</strong></h2><p>基本身份验证是一种比较简单的授权类型，需要经过验证的用户名和密码才能访问数据资 源。这就需要我们输入用 户名和对应的密码。</p>
<p><strong>案例：请求 URL 如下，授权账号为：</strong> </p>
<p>• 用户名: postman </p>
<p>• 密码: password </p>
<p>• 授权协议为：Basic auth </p>
<p><strong>准备的 URL：</strong>[<a href="https://postman-echo.com/basic-auth">https://postman-echo.com/basic-auth</a></p>
<p><strong>注意：</strong> </p>
<p>• 如果不输入用户名密码，直接使用 GET 请求，则会返回提示：Unauthorized </p>
<p><a href="https://pic.imgdb.cn/item/6138ad7c44eaada7393fbe46.png"><img src="https://pic.imgdb.cn/item/6138ad7c44eaada7393fbe46.png"></a></p>
<p>• 输入用户名密码，选择 Basic auth 授权类型，则返回如下结果：</p>
<p><a href="https://pic.imgdb.cn/item/6138adb544eaada7394020b1.png"><img src="https://pic.imgdb.cn/item/6138adb544eaada7394020b1.png"></a></p>
<h2 id="3-Digest-Auth-授权"><a href="#3-Digest-Auth-授权" class="headerlink" title="3. Digest Auth 授权"></a><strong>3. Digest Auth</strong> <strong>授权</strong></h2><p>Digest auth 是一个简单的认证机制，最初是为 HTTP 协议开发的，因此也常叫做 HTTP 摘要。 </p>
<p>其身份验证机制非 常简单，它采用哈希加密方法，以避免用明文传输用户的口令。摘 要认证就是要核实參与通信的两方都知道双方共 享的一个口令。 当 server 想要查证用户的身份，它产生一个摘要盘问（digest challenge），并发送 给用户。典型的摘要盘问例如 以下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Digest realm=&quot;iptel.org&quot;, qop=&quot;auth,auth-int&quot;, </span><br><span class="line"></span><br><span class="line">nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;, opaque=&quot;&quot;, algorithm=MD5 </span><br></pre></td></tr></table></figure>

<p>这里包含了一组参数，也要发送给用户。用户使用这些參数，来产生正确的摘要回答，并发 送给 server。各个參数意义如下： </p>
<p><strong>realm（领域</strong>）：领域參数是强制的，在全部的盘问中都必须有。它是目的是鉴别 SIP 消 息中的机密。在 SIP 实际应用中，它通常设置为 SIP 代理 server 所负责的域名。 </p>
<p><strong>nonce（现时）</strong>：这是由 server 规定的数据字符串，在 server 每次产生一个摘要盘问时， 这个參数都是不一样的 （与前面所产生的不会雷同）。“现时”一般是由一些数据通过 md5 杂凑运算构造的。 这种数据通常包含时间标 识和 server 的机密短语。这确保每一个“现 时”都有一个有限的生命期（也就是过了一些时间后会失效，并且以后再也不会使用），并 且是独一无二的 （即不论什么其他的 server 都不能产生一个同样的“现时”）。 </p>
<p><strong>algorithm（算法）</strong>：这是用来计算的算法。当前仅仅支持 MD5 算法。 </p>
<p><strong>qop（保护的质量）</strong>。这个參数规定 server 支持哪种保护方案。client 能够从列表中选择 一个。值 auth 表示仅仅 进行身份查验， auth-int 表示进行查验外，另一些完整性保护。</p>
<p>须要看更具体的描写叙述，请參阅 RFC2617。 </p>
<p>参考链接：<a href="https://blog.csdn.net/guobailu/article/details/82775459">https://blog.csdn.net/guobailu/article/details/82775459</a> </p>
<p>案例： </p>
<p>准备 URL： </p>
<p><a href="https://postman-echo.com/digest-auth">https://postman-echo.com/digest-auth</a></p>
<p>配置： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Digest username=&quot;postman&quot;, realm=&quot;Users&quot;, nonce=&quot;ni1LiL0O37PRRhofWdCLmwFsnEtH1lew&quot;, </span><br><span class="line"></span><br><span class="line">uri=&quot;/digest-auth&quot;, </span><br><span class="line">response=&quot;254679099562cf07df9b6f5d8d15db44&quot;, opaque=&quot;&quot; </span><br></pre></td></tr></table></figure>

<p><a href="https://pic.imgdb.cn/item/6138ae9044eaada739418709.png"><img src="https://pic.imgdb.cn/item/6138ae9044eaada739418709.png"></a></p>
<p>一切都正确，结果如下：</p>
<p><a href="https://pic.imgdb.cn/item/6138aecc44eaada73941e757.png"><img src="https://pic.imgdb.cn/item/6138aecc44eaada73941e757.png"></a></p>
<h2 id="4-Hawk-Auth"><a href="#4-Hawk-Auth" class="headerlink" title="4. Hawk Auth"></a><strong>4. Hawk Auth</strong></h2><p>Hawk Auth 是一个 HTTP 认证方案，使用 MAC(Message Authentication Code， 消息认证码算法)算法，它提供 了对请求进行部分加密验证的认证 HTTP 请求的方法。 hawk 方案要求提供一个共享对称密匙在服务器与客户端之 间，通常这个共享的凭证 在初始 TLS（安全传输层协议）保护阶段建立的，或者是从客户端和服务器都可用的其他 一些共享机密信息中获得的。 </p>
<h3 id="1-准备参数"><a href="#1-准备参数" class="headerlink" title="1) 准备参数"></a><strong>1)</strong> <strong>准备参数</strong></h3><p>请求的 URL：<a href="https://postman-echo.com/auth/hawk">https://postman-echo.com/auth/hawk</a></p>
<p><strong>秘钥信息：</strong> </p>
<p>Hawk Auth ID: </p>
<p>dh37fgj492je </p>
<p>Hawk Auth Key: </p>
<p>werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn </p>
<p>Algorithm: sha256</p>
<h3 id="2-步骤截图"><a href="#2-步骤截图" class="headerlink" title="2) 步骤截图"></a><strong>2) 步骤截图</strong></h3><p><a href="https://pic.imgdb.cn/item/6138af0644eaada7394241a4.png"><img src="https://pic.imgdb.cn/item/6138af0644eaada7394241a4.png"></a></p>
<h3 id="3-执行结果"><a href="#3-执行结果" class="headerlink" title="3) 执行结果"></a><strong>3)</strong> <strong>执行结果</strong></h3><p><img src="https://pic.imgdb.cn/item/6138af3e44eaada739429f28.png"></p>
<p>如果将 key 改为其他任意的字符则返回如下结果：</p>
<p><a href="https://pic.imgdb.cn/item/6138af7044eaada73942f034.png"><img src="https://pic.imgdb.cn/item/6138af7044eaada73942f034.png"></a></p>
<p><a href="https://pic.imgdb.cn/item/6138affc44eaada73943d56e.png"><img src="https://pic.imgdb.cn/item/6138affc44eaada73943d56e.png"></a></p>
<ol start="5">
<li>OAuth 1.0 OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站 上存储的私密的资源（如照片， 视频，联系人列表），而无需将用户名和密码提供给第三 方应用。 </li>
</ol>
<p>扩展资料： <a href="https://blog.huoding.com/2010/10/10/8">https://blog.huoding.com/2010/10/10/8</a></p>
<h4 id="1-准备参数-1"><a href="#1-准备参数-1" class="headerlink" title="1) 准备参数"></a><strong>1</strong>) 准备参数</h4><p>请求 URL 如下：请求方式为 GET，Add authorization data to </p>
<p>设置 Request Headers 为：<a href="https://postman-echo.com/oauth1">https://postman-echo.com/oauth1</a> </p>
<p><strong>配置参数：</strong> </p>
<p>Consumer Key: RKCGzna7bv9YD57c </p>
<p>Consumer Secret: D+EdQ-gs$-%@2Nu7 </p>
<h4 id="2-步骤截图-1"><a href="#2-步骤截图-1" class="headerlink" title="2) 步骤截图"></a><strong>2) 步骤截图</strong></h4><p><a href="https://pic.imgdb.cn/item/6138b2f744eaada73948adca.png"><img src="https://pic.imgdb.cn/item/6138b2f744eaada73948adca.png"></a></p>
<h4 id="3-执行结果-1"><a href="#3-执行结果-1" class="headerlink" title="3) 执行结果"></a><strong>3)</strong> <strong>执行结果</strong></h4><p>正确结果：</p>
<p><a href="https://pic.imgdb.cn/item/6138b3b144eaada73949f5f8.png"><img src="https://pic.imgdb.cn/item/6138b3b144eaada73949f5f8.png"></a></p>
<p>异常结果： </p>
<p><a href="https://pic.imgdb.cn/item/6138b3be44eaada7394a0ee7.png"><img src="https://pic.imgdb.cn/item/6138b3be44eaada7394a0ee7.png"></a></p>
<p>如果 Consumer Secret 错误则返回如下结果： </p>
<h1 id="五、Cookie设置"><a href="#五、Cookie设置" class="headerlink" title="五、Cookie设置"></a><strong>五、Cookie设置</strong></h1><h2 id="1-什么是-cookie"><a href="#1-什么是-cookie" class="headerlink" title="1. 什么是 cookie"></a><strong>1.</strong> <strong>什么是</strong> <strong>cookie</strong></h2><p>cookie 是存储在浏览器中的小片段信息，每次请求后都将其发送回服务器，以便在请 求之间存储有用的信息。比如很多网站登录界面都有保留账号密码，以便下次登录。 由于 HTTP 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办 呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样 服务器就能从通行证上确认客户身份了。这就是 Cookie 的工作原理。 </p>
<p>Cookie 是由服务端生成，存储在响应头中，返回给客户端，客户端会将 cookie 存储下来，在客户端发送请求时， user-agent 会自动获取本地存储的 cookie，将 cookie 信息存储在请求头中，并发送给服务端。 </p>
<p>postman 也可以设置、获取、删除 Cookie。 </p>
<h2 id="2-设置-cookie"><a href="#2-设置-cookie" class="headerlink" title="2. 设置 cookie"></a><strong>2.</strong> <strong>设置</strong> <strong>cookie</strong></h2><p>在 Send 按钮下方点击 Cookies 文字菜单，弹出如下界面，然后可以设置 Cookie。 </p>
<p><a href="https://pic.imgdb.cn/item/6138b3fb44eaada7394a8ea1.png"><img src="https://pic.imgdb.cn/item/6138b3fb44eaada7394a8ea1.png"></a></p>
<h3 id="1-准备参数："><a href="#1-准备参数：" class="headerlink" title="1) 准备参数："></a><strong>1)</strong> <strong>准备参数：</strong></h3><p>请求 URL：<a href="https://www.baidu.com/">https://www.baidu.com</a> </p>
<p>请求方式：GET 请求 </p>
<p>设置 cookie 为：username:wu</p>
<p><strong>点击下方</strong> <strong>cookie</strong> </p>
<p><a href="https://pic.imgdb.cn/item/6138b40d44eaada7394aaf61.png"><img src="https://pic.imgdb.cn/item/6138b40d44eaada7394aaf61.png"></a></p>
<p><strong>添加参数进去</strong></p>
<p><a href="https://pic.imgdb.cn/item/6138b49144eaada7394b9e2d.png"><img src="https://pic.imgdb.cn/item/6138b49144eaada7394b9e2d.png"></a></p>
<p><strong>点击控制台</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6138b4f344eaada7394c4b64.png"></p>
<p><strong>点击发送</strong></p>
<p><img src="https://pic.imgdb.cn/item/6138b50d44eaada7394c78db.png"></p>
<h3 id="3-查看结果："><a href="#3-查看结果：" class="headerlink" title="3) 查看结果："></a><strong>3)</strong> <strong>查看结果：</strong></h3><p><img src="https://pic.imgdb.cn/item/6138b57544eaada7394d2e3e.png"></p>
<h2 id="3-获取-cookie"><a href="#3-获取-cookie" class="headerlink" title="3. 获取 cookie"></a><strong>3.</strong> <strong>获取</strong> <strong>cookie</strong></h2><p>Cookie 获取比较简单，直接获取 Response Headers 里面的 set-cookie 值即 可，或者在主界面下方 Cookie 菜单 栏里面也可以查看。</p>
<p><img src="https://pic.imgdb.cn/item/6138b59d44eaada7394d72c5.png"></p>
<h3 id="4-删除-cookie"><a href="#4-删除-cookie" class="headerlink" title="4. 删除 cookie"></a><strong>4.</strong> <strong>删除</strong> <strong>cookie</strong></h3><p>点击 Cookies 文字菜单,然后可以根据需求去清除对应的 Cookie。 </p>
<h1 id="六、变量"><a href="#六、变量" class="headerlink" title="六、变量"></a><strong>六、变量</strong></h1><h2 id="1．为什么需要变量？"><a href="#1．为什么需要变量？" class="headerlink" title="1．为什么需要变量？"></a>1．为什么需要变量？</h2><p>在开发不同阶段可能存在不同的环境,比如测试环境和生产环境。 </p>
<p>测试环境 API 如下： </p>
<p><a href="https://dev.postman.com/get">https://dev.postman.com/get</a> </p>
<p><a href="https://dev.postman.com/post">https://dev.postman.com/post</a> </p>
<p><a href="https://dev.postman.com/put">https://dev.postman.com/put</a> </p>
<p>生产环境 API 如下： </p>
<p><a href="https://postman-echo.com/get">https://postman-echo.com/get</a> </p>
<p><a href="https://postman-echo.com/post">https://postman-echo.com/post</a> </p>
<p><a href="https://postman-echo.com/put">https://postman-echo.com/put</a></p>
<p>在这么情况下，按照常规思路要么你需要维护两套环境的 API，要么每次都手动一个 个去修改 URL，不管哪种选择 都比较麻烦且低效，那么有没有比较的好的方法来解决这个 问题呢？</p>
<p>通过比较我们可以发现，以上两组 API 主要是除了 host 不同之外其他都一样，其实 把 Host 用<strong>变量</strong>替换，这样就可以灵活切换环境。</p>
<h2 id="2．Postman-的变量类型"><a href="#2．Postman-的变量类型" class="headerlink" title="2．Postman 的变量类型"></a>2．Postman <strong>的变量类型</strong></h2><p><strong>Postman 提供了变量设置，有 4 种变量类型。</strong> </p>
<ul>
<li><p>本地变量(LocalVariable ) </p>
</li>
<li><p>全局变量(Global Variable) </p>
</li>
<li><p>环境变量(Environment Variable) </p>
</li>
<li><p>数据变量(Data Variable) </p>
</li>
</ul>
<h2 id="3-Postman的变量详解"><a href="#3-Postman的变量详解" class="headerlink" title="3.Postman的变量详解"></a>3.Postman<strong>的变量详解</strong></h2><h3 id="1-环境变量-Environment-Variable"><a href="#1-环境变量-Environment-Variable" class="headerlink" title="1) 环境变量(Environment Variable)"></a><strong>1)</strong> 环境变量(Environment Variable)</h3><p>环境变量指在不同环境，同一个变量值随着环境不同而变化，比如我们上面举例场景就 可以使用环境变量，当在测试环境时，host 值为: dev.postman.com ,当切换到生产环境 时，host 值变为：postman-echo.com 。 环境变量设置： 在 postman 界面点击右上角眼睛图标，即可开始设置环境变量和全 局变量。环境变量设置过程如下图所示： </p>
<p>我们可以设置两种环境 dev 和 release, </p>
<p><strong>dev</strong> <strong>是开发测试环境；</strong> </p>
<p><strong>release</strong> <strong>是正式的生产环境。</strong> </p>
<p><strong>host</strong> <strong>环境变量， 根据不同的环境值不一样。</strong></p>
<p><img src="https://pic.imgdb.cn/item/6138b5b144eaada7394d9428.png"></p>
<p>同样的步骤，再来添加生产环境 </p>
<p><img src="https://pic.imgdb.cn/item/6138b6f844eaada7394fe875.png"></p>
<p>变量引用格式为,如下图所示：</p>
<p> <img src="https://pic.imgdb.cn/item/6138b70a44eaada73950090e.png"></p>
<p>列如：生产环境</p>
<p>完整参考：<a href="https://jingyan.baidu.com/article/948f59247349c0980ff5f9c3.html">https://jingyan.baidu.com/article/948f59247349c0980ff5f9c3.html</a> </p>
<h3 id="2-本地变量-LocalVariable"><a href="#2-本地变量-LocalVariable" class="headerlink" title="2) 本地变量(LocalVariable )"></a><strong>2)</strong> 本地变量(LocalVariable )</h3><p>本地变量主要是针对单个 URL 请求设置的变量，作用域只是局限在请求范围内。如 请求 URL 如下，设置两个本地变量（user,passwd）作为参数。请求方式为 POST准备参数：<a href="https://postman-echo.com/post">https://postman-echo.com/post</a> </p>
<p><img src="https://pic.imgdb.cn/item/6138b72d44eaada739504dde.png"></p>
<p>上面通过环境变量知道，设置变量的格式为： </p>
<p>变量设置好之后需要赋值，在 Pre-request-Script 里面编写如下代码： </p>
<p>pm.variables.set(“user”,”wu”); </p>
<p>pm.variables.set(“passwd”,”123456”);</p>
<p><img src="https://pic.imgdb.cn/item/6138b74844eaada739507a6f.png"></p>
<p>点击 send 执行之后的返回值如下，可以看到我们定义的变量已经发送。</p>
<p> <img src="https://pic.imgdb.cn/item/6138b74844eaada739507a6f.png"></p>
<h3 id="3-全局变量-Global-Variable"><a href="#3-全局变量-Global-Variable" class="headerlink" title="3) 全局变量(Global Variable)"></a><strong>3)</strong> 全局变量(Global Variable)</h3><p>全局变量是指在所有的环境里面，变量值都是一样的，全局变量的作用域是所有请求。 </p>
<p>全局变量设置有两种方式： </p>
<h4 id="1-点击界面里设置"><a href="#1-点击界面里设置" class="headerlink" title="1. 点击界面里设置"></a><strong>1. 点击界面里设置</strong></h4><p>点击眼睛图标后，在 Global 选项菜单点击 Edit 菜单即可设置全局变量，如下图所示。 </p>
<p><img src="https://pic.imgdb.cn/item/6138b78a44eaada73950f46b.png"></p>
<p>全局变量的引用格式和环境 变量一样， </p>
<p>注意：当环境变量和全局变量名称一样时，切换到某个环境时，环境变量会覆盖全局变量。</p>
<h4 id="2-在脚本里设置"><a href="#2-在脚本里设置" class="headerlink" title="2.在脚本里设置"></a><strong>2.在脚本里设置</strong></h4><p>使用如下脚本可以设置全局变量：variable_key 表示变量名称， variable_value 表示 变量值。 </p>
<p>pm.globals.set(“variable_key”, “variable_value”); </p>
<h3 id="4-实践案例："><a href="#4-实践案例：" class="headerlink" title="4) 实践案例："></a><strong>4)</strong> <strong>实践案例：</strong></h3><p>在实际接口测试过程中，接口经常会有关联。比如需要取上一个接口的某个返回值，然 后作为参数传递到下一个接 口作为参数。 </p>
<p><strong>假设我们要获取 A 接口返回的 userid 值作为 B 接口的请求参数</strong>。 </p>
<p>A 接口请求 URL 如下： </p>
<p><a href="https://postman-echo.com/post">https://postman-echo.com/post</a> </p>
<p>• 请求方式为 Post </p>
<p>• 请求参数：userid(这里自己定义，接口会返回对应的 id 值)</p>
<p><img src="https://pic.imgdb.cn/item/6138b7b344eaada739513ead.png"></p>
<p>根据返回值我们需要从返回值中提取 userid 值。</p>
<p><img src="https://pic.imgdb.cn/item/6138b7ef44eaada73951ab1a.png"></p>
<p>在 Test 标签栏下编写如下脚本获 取 userid 值 B 接口请求 URL 如下：请求方式为 GET </p>
<p>postman-<strong>echo</strong>.<strong>com</strong>/get?userid= </p>
<p>先执行 A 接口的，然后在执行 B 接口，此时 B 接口通过全局变量 userid 可以获得 A 接口的返回值。</p>
<p><img src="https://pic.imgdb.cn/item/6138b80944eaada73951da25.png"></p>
<h1 id="七、断言："><a href="#七、断言：" class="headerlink" title="七、断言："></a><strong>七、断言：</strong></h1><h2 id="1-什么是断言？"><a href="#1-什么是断言？" class="headerlink" title="1) 什么是断言？"></a><strong>1)</strong> <strong>什么是断言？</strong></h2><p>一般来说执行完测试，我们需要对测试结果来进行校验，判断结果是是否符合我们的预 期，也就是断言。在接口测试中一般会根据响应状态码或者响应返回的数据来进行断言。 </p>
<p>Postman 提供一个测试沙箱（Postman Sandbox） 测试沙箱是一个 JavaScript 执 行环境，可以通过 JS 脚本来编 写 pre-request Script 和 test Script。 </p>
<p>pre-request Script（预置脚本）可以用来修改一些默认参数,在请求发送之前执行。 </p>
<p>test Script（测试脚本）当接收到响应之后，再执行测试脚本。 </p>
<h2 id="2-断言的案例"><a href="#2-断言的案例" class="headerlink" title="2) 断言的案例"></a><strong>2)</strong> <strong>断言的案例</strong></h2><h4 id="1-准备的-URL"><a href="#1-准备的-URL" class="headerlink" title="(1) 准备的 URL:"></a><strong>(1)</strong> <strong>准备的</strong> <strong>URL:</strong></h4><p>postman-echo.com/post </p>
<h4 id="2-断言的规则"><a href="#2-断言的规则" class="headerlink" title="(2) 断言的规则"></a><strong>(2)</strong> <strong>断言的规则</strong></h4><p>• 响应状态码：200 </p>
<p>• 响应内容：返回的 user 参数值与定义的一致 </p>
<p>• 响应时间：小于 0.5s </p>
<h4 id="3-准备的脚本"><a href="#3-准备的脚本" class="headerlink" title="(3) 准备的脚本"></a><strong>(3)</strong> <strong>准备的脚本</strong></h4><p><strong>在</strong> <strong>pre-request Script</strong> <strong>定义变量</strong> <strong>user</strong></p>
<p>pm.variables.set(“user”,’wulibobo’); </p>
<p><img src="https://pic.imgdb.cn/item/6138b88f44eaada73952d8bb.png"></p>
<p><strong>在</strong> <strong>Test</strong> <strong>栏下面编写如下脚本</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断响应状态码 </span><br><span class="line">pm.test(&quot;Status code is 200&quot;, function () &#123; pm.response.to.have.status(200); &#125;); </span><br><span class="line"></span><br><span class="line">//获取发送的参数值 </span><br><span class="line">username=pm.variables.get(&quot;user&quot;); </span><br><span class="line">console.log(username); </span><br><span class="line"></span><br><span class="line">//校验响应内容是否和请求的一致 </span><br><span class="line">pm.test(&quot;Check username&quot;, function () &#123; var jsonData = pm.response.json(); pm.expect(jsonData.json[&#x27;user&#x27;]).to.eql(username); &#125;);</span><br><span class="line"></span><br><span class="line">//检测响应时间是否小于 0.5s </span><br><span class="line">pm.test(&quot;Response time is less than 500ms&quot;, function () &#123; pm.expect(pm.response.responseTime).to.be.below(500);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/6138b8b844eaada7395321bf.png"></p>
<h4 id="4-断言的结果"><a href="#4-断言的结果" class="headerlink" title="(4) 断言的结果"></a><strong>(4)</strong> <strong>断言的结果</strong></h4><p><img src="https://pic.imgdb.cn/item/6138b8cc44eaada7395344ce.png"></p>
<p>Postman 测试脚本的官方文档： </p>
<p><a href="https://learning.postman.com/docs/writing-scripts/intro-to-scripts/">https://learning.postman.com/docs/writing-scripts/intro-to-scripts/</a></p>
]]></content>
  </entry>
  <entry>
    <title>接口测试基础</title>
    <url>/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、接口测试的概述"><a href="#一、接口测试的概述" class="headerlink" title="一、接口测试的概述"></a><strong>一、接口测试的概述</strong></h1><h2 id="1-什么是接口？"><a href="#1-什么是接口？" class="headerlink" title="1. 什么是接口？"></a><strong>1.</strong> <strong>什么是接口？</strong></h2><p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的<strong>函</strong> <strong>数</strong>，目的是提供应用程序与 开发人员基于某<strong>软件或硬件</strong>得以访问一组例程的能力，而又无 需访问源码，或理解内部工作机制的细节。 <span id="more"></span></p>
<p><strong>举例说明：</strong> </p>
<p>笔记本电脑上提供了各种物理硬件接口，比如 USB 接口，耳机接口、麦克风接口、电 源接口等…. 这些不 同的接口有不同的功能：比如通过 USB 接口插入 U 盘就可以拷贝电 脑数据，插入耳机接口可以听音乐，我 们无需关心这些接口的工作原理，只需通过这些接 口满足我们的使用需求即可。 </p>
<p>在中国天气网网上查询某个城市天气，主要输入城市名称，即可获取到对应的天气。查 询背后的本质也是 调用了网站后台接口来获取数据，这里的接口是 Web 服务软件接口。 </p>
<p>用户不需要关注数据在网站后台是怎 么查询的，只需要返回一个结果即可。 </p>
<h2 id="2-什么是接口测试？"><a href="#2-什么是接口测试？" class="headerlink" title="2. 什么是接口测试？"></a><strong>2.</strong> <strong>什么是接口测试？</strong></h2><p>接口测试是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管 理过程，以及相互逻辑依赖 关系。其中接口协议分为 HTTP,WebService,Dubbo,Thrift,Socket 等类型。</p>
<h2 id="3-为什么要做接口测试？"><a href="#3-为什么要做接口测试？" class="headerlink" title="3. 为什么要做接口测试？"></a><strong>3.</strong> <strong>为什么要做接口测试？</strong></h2><p>接口测试实施在多系统的平台架构下，有着极为高效的成本收益比（当然，单元测试收 益更高，但实施单元测试的 成本投入更大，技术要求更高）。 </p>
<p>接口测试天生为高复杂性的平台带来高效的缺陷检测和质量监督能力，平台复杂，系统 越庞大，接口测试的效果越 明显。 </p>
<h3 id="接口测试优势主要体现在如下三个方面："><a href="#接口测试优势主要体现在如下三个方面：" class="headerlink" title="接口测试优势主要体现在如下三个方面："></a><strong>接口测试优势主要体现在如下三个方面：</strong></h3><h4 id="1、节省了测试成本"><a href="#1、节省了测试成本" class="headerlink" title="1、节省了测试成本"></a><strong>1、节省了测试成本</strong></h4><p>根据数据模型推算，底层的一个程序 BUG 可能引发 UI 层的 8 个左右 BUG，而且 底层的 BUG 更容易引起全网的死 机；接口测试能够提供系统复杂度上升情况下的低成本 高效率的解决方案。 </p>
<h4 id="2、接口测试门槛相对较低"><a href="#2、接口测试门槛相对较低" class="headerlink" title="2、接口测试门槛相对较低"></a><strong>2、接口测试门槛相对较低</strong></h4><p>接口测试不同于单元测试，接口测试是站在用户的角度对系统接口进行全面高效持续的 检测。 </p>
<h4 id="3、效益更高"><a href="#3、效益更高" class="headerlink" title="3、效益更高"></a><strong>3、效益更高</strong></h4><p>将接口测试实现为自动化和持续集成，当系统复杂度和体积越大，接口测试的成本就越 低,相对应的，效益产出就 越高。 </p>
<h4 id="4-怎么样去做接口测试？"><a href="#4-怎么样去做接口测试？" class="headerlink" title="4. 怎么样去做接口测试？"></a><strong>4.</strong> <strong>怎么样去做接口测试？</strong></h4><p><strong>基本的接口功能自动化测试流程如下：</strong> </p>
<p>需求分析 -&gt; 用例设计 -&gt; 脚本开发 -&gt; 测试执行 -&gt; 结果分析</p>
<h1 id="二、HTTP-协议基础"><a href="#二、HTTP-协议基础" class="headerlink" title="二、HTTP 协议基础"></a>二、HTTP <strong>协议基础</strong></h1><h3 id="1-http协议的简介"><a href="#1-http协议的简介" class="headerlink" title="1.http协议的简介"></a><strong>1.http协议的简介</strong></h3><p><strong>1) http</strong> <strong>协议简介</strong> </p>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的 一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了 提供一种发布和接收 HTML 页面的方法。 </p>
<p>HTTP 协议在网络 OSI 模型中属于应用层协议，应用层协议除了 HTTP 还有：FTP， SMTP，DNS，RIP，Telnet 等。 </p>
<p>HTTP 协议工作于<strong>客户端—服务端</strong>架构上。浏览器作为 HTTP 客户端通过 <strong>URL</strong> 向 HTTP 服务端（即 Web 服务器） 发送请求。 </p>
<p><strong>2)</strong> <strong>什么是超文本？</strong> </p>
<p>超文本英文名称叫做 Hypertext，我们在浏览器里面看到的网页就是超文本解析而成的， </p>
<p>其网页源代码是一系 列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显 示段落等，浏览器解析这些标签后便形成了我们平常看到的网页，而这网页的源代码 HTML 就可以称作超文本。 </p>
<p>例如我们在 Chrome 浏览器里面打开如百度页面，右键点击”查看源代码”，这些源代 码都是超文本。</p>
<p><strong>3)</strong> <strong>什么是 URL？</strong></p>
<p>我们在浏览器的地址栏里输入的网站地址叫做 <strong>URL</strong> (Uniform Resource Locator，统 一资源定位符)。就像每家每 户都有一个门牌地址一样，每个网页也都有一个 Internet 地 址（如：<a href="http://www.baidu.com)./">http://www.baidu.com）。</a> </p>
<p>当你在浏览器的 地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏 览的地址。浏览器通过超文本传输协议(HTTP)， 将 Web 服务器上站点的网页代码提取出 来，并翻译成漂亮的网页。 </p>
<p><strong>4) http</strong> <strong>功能</strong> </p>
<p>HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从服务器传输 超文本到本地浏览器的传输协议。 </p>
<p>它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本 文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 </p>
<p><strong>5) http</strong> <strong>的特点</strong> </p>
<p><strong>无连接：</strong>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到 客户的应答后， 即断开连接。采用这种方式可以节省传输时间。 </p>
<p><strong>媒体独立：</strong>这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可 以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 来传输。</p>
<p><strong>无状态：</strong>HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果服务 器不需要先前信 息，那么它的应答就比较快。但是缺少状态意味着如果后续处理需要前面 的信息，则它必须重传，这样可 能导致每次连接传送的数据量增大，此时可以设置缓存。 </p>
<p><strong>6). http</strong> <strong>与</strong> <strong>https</strong> <strong>的区别？</strong> </p>
<p>现在在浏览很多网站时，通过浏览器地址栏可以看到有的网站是 https 开头 (<a href="https://www.baidu.com/">https://www.baidu.com/</a> ）, 但是 有的是 http 开头（如： </p>
<p><a href="http://www.weather.com.cn/">http://www.weather.com.cn</a> ）这两种有什么区别呢？难道加了 s 就是复数吗？ </p>
<p>HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以 安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层（Secure Sockets Layer 安全套接层），简称为 HTTPS。 </p>
<p><strong>S</strong> <strong>其实是 Security 单词的首字母。</strong> </p>
<p><strong>HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用</strong> </p>
<p><strong>可以分为两种：</strong> </p>
<ol>
<li><p>是建立一个信息安全通道，来保证数据传输的安全。 </p>
</li>
<li><p>确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标 志来查看网站认证之 后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。</p>
</li>
</ol>
<p>现在越来越多的网站和 APP 都已经向 HTTPS 方向发展。例如：谷歌从 2017 年 1 月推出的 Chrome 56 开始， 对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户“此 网页不安全”。 </p>
<p><strong>7).http</strong> <strong>与</strong> <strong>TCP/IP</strong> <strong>的特点：</strong> </p>
<p>TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协 议，主要解决如何包装数据。</p>
<p> 关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输 数据时，可以只使用（传输层） TCP/IP 协议，但是那样的话，如果没有应用层，便无法 识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很 </p>
<p>多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。 </p>
<p>WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做 传输层协议将它发到网络上。</p>
<h3 id="2-http的请求"><a href="#2-http的请求" class="headerlink" title="2.http的请求"></a><strong>2.http的请求</strong></h3><p>我们在浏览器输入百度首页的地址：<a href="https://www.baidu.com/">https://www.baidu.com/</a> 输入之后浏览器会给 我们打开百度首页。 </p>
<p>实际上这 个过程是浏览器向网站所在的服务器发送了一个 Request，即请求，网站服 务器接收到这个 Request 之后进行处 理和解析，然后返回对应的一个 Response，即响 应，然后传回给浏览器，Response 里面就包含了页面的源代码 等内容，浏览器再对其进行解析便将网页呈现了出来。 </p>
<img src="https://pic.imgdb.cn/item/61377d5644eaada7395198df.png">

<p>列如，使用火狐浏览器，打开百度，查看页面的请求过程。 </p>
<p>需要详细步骤，点击这边： </p>
<p><a href="https://zhidao.baidu.com/question/428894531624967852.html">https://zhidao.baidu.com/question/428894531624967852.html</a></p>
<img src="https://pic.imgdb.cn/item/61377da244eaada7395254e7.png">

<p><strong>1)</strong> <strong>请求的四部分</strong> </p>
<p>•Request Method: 请求方式 </p>
<p>•Request URL: 请求链接 </p>
<p>•Request Headers: 请求头 </p>
<p>•Request Body: 请求体 </p>
<p><strong>2)</strong> <strong>请求方式—抓用户名和密码</strong> </p>
<p><strong>请求方式，请求方式常见的有两种类型，GET 和 POST。</strong> </p>
<p>GET 用于信息获取，而且应该是安全的和幂等的(幂等的的意思就是一个操作不会修改 状态信息，并且每次操作的时候都返回同样的结果。) 从发送请求的角度，GET 请求相当 于我们在数据库中做了查询的操作， 这样的操作不影响数据库本身的数据。 </p>
<p>POST 表示可能会修改服务器上资源的请求，也相当于在数据库中做了修改的操作， 会影响数据库本身的数据（比如：注册了账户，发了帖子，做了评论，得到了积分等。这种 情况下，资源状态被改变了）。 </p>
<p><strong>案例：</strong> </p>
<p><strong>Get 请求：</strong> </p>
<p>在浏览器地址栏输入：<a href="https://www.baidu.com/s?wd=appium">https://www.baidu.com/s?wd=appium</a> 并回车，这个其实就是在百度搜 索 appium 这个关键词。</p>
<p>URL 中 包含了请求的参数信息，这里参数 wd 就是要搜寻的关键字。</p>
<img src="https://pic.imgdb.cn/item/61377e2244eaada73953981b.png">

<p><strong>POST 请求：</strong> </p>
<p>一般来说，网站登录验证的时候，需要提交用户名密码，这里包含了敏感信息，使用 GET 方式请求的话密码就会 暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方 式发送。文件的上传时，由于文件内容比较大，也会 选用 POST 方式。比如百度账户登 录， </p>
<p>列如：使用火狐浏览器抓用户名和密码 </p>
<img src="https://pic.imgdb.cn/item/61377e6044eaada7395434c2.png">

<p>当然你也可以是用 fiddler 来抓包</p>
<img src="https://pic.imgdb.cn/item/61377e8044eaada73954888a.png">

<p><strong>3) 请求网址(URL)</strong></p>
<p>Request URL </p>
<p>就是请求的网址，即统一资源定位符，用 URL 可以唯一确定我们想请 </p>
<p>求的资源。比如： <a href="https://www.baidu.com/">https://www.baidu.com/</a> </p>
<p><strong>4) 请求头（Request Headers）</strong></p>
<p>请求头，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、 </p>
<ul>
<li><p><strong>User-Agent</strong> 等，下面将一些 常用的头信息说明如下： </p>
</li>
<li><p><strong>Accept</strong>，请求报头域，用于指定客户端可接受哪些类型的信息。 </p>
</li>
<li><p><strong>Accept-Language</strong>，指定客户端可接受的语言类型。 </p>
</li>
<li><p> <strong>Accept-Encoding</strong>，指定客户端可接受的内容编码。 </p>
</li>
<li><p><strong>Host</strong>,用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关 的位置。从 HTTP 1.1 版本开始，Request 必须包含此内容。 </p>
</li>
<li><p> <strong>Cookie</strong>，也常用复数形式 Cookies，是网站为了辨别用户进行 Session 跟踪而储存在 用户本地的数据。</p>
</li>
<li><p><strong>Cookies</strong> 的主要功能就是维持当前访问会话。 </p>
</li>
<li><p><strong>Referer</strong>,此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做 相应的处理，如 做来源统计、做防盗链处理等。 </p>
</li>
<li><p><strong>User-Agent</strong>，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统 及版本、浏览器 及版本等信息。 </p>
</li>
<li><p><strong>Content-Type</strong>，即 Internet Media Type，互联网媒体类型，也叫做 MIME 类型，在 HTTP 协议消息头 中，使用它来表示具体请求中的媒体类型信息。例如 </p>
</li>
<li><p><strong>application/x-www-form-urlencoded</strong>表示表单数 据， text/html 代表 HTML 格式， image/gif 代表 GIF 图片，application/json </p>
</li>
</ul>
<p><strong>5)</strong> <strong>请求体</strong> </p>
<p>即请求体，一般用于 POST 请求中，主要定义向服务器提交的数据类型，而对于 GET 请求 Request Body 则为 空。 </p>
<p>比如在登录之前我们填写了用户名和密码信息，提交时就这些内容就会以 Form Data 的形式提交给服务器，此时注意 Request Headers 中指定了 Content-Type 为 application/x-www-form-urlencoded。</p>
<p>只有设 置 Content-Type 为 application/x-www-form-urlencoded 才会以 Form Data 形式提交，另外我们也可以 将 Content-Type 设置为 application/json 来 提交 Json 数据，或者设置为 multipart/form-data 来上传文件。 </p>
<p>常用 Content-Type 和 POST 提交数据方式的关系： </p>
<p><strong>Content-Type</strong> :提交数据方式</p>
<p>application/x-www-form-urlencoded :Form 表单提交 </p>
<p>multipart/form-data :表单文件上传提交 </p>
<p>application/json :序列化 Json 数据提交 </p>
<p>text/xml :XML 数据提交 </p>
<h3 id="3-http-的响应"><a href="#3-http-的响应" class="headerlink" title="3.http 的响应"></a>3.http 的响应</h3><p>1).响应的三部分</p>
<p>上述内容讲述的 http 协议的请求，接着描述 http 协议的响应。 </p>
<p><strong>Response，即响应，由服务端返回给客户端。Response 可以划分为三部分:</strong> </p>
<p>•Response Status Code </p>
<p>• Response Headers </p>
<p>• Response Body </p>
<p><strong>Response Status Code</strong></p>
<p>响应状态码，此状态码表示了服务器的响应状态，如 200 则代表服务器正常响应，404 则代表页面未找到，500 则 代表服务器内部发生错误。常用响应状态码如下： </p>
<p>可以参考完整的 http 协议的响应状态码： </p>
<p><strong><a href="https://tool.oschina.net/commons?type=5">https://tool.oschina.net/commons?type=5</a></strong> </p>
<p><strong>2.</strong> <strong>响应头</strong> </p>
<p>响应头，其中包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等，下面将一些常用的头信息说明如下： </p>
<p><strong>Date</strong>，标识 Response 产生的时间。 </p>
<p><strong>Last-Modified</strong>，指定资源的最后修改时间。 </p>
<p><strong>Content-Encoding，</strong>指定 Response 内容的编码。 </p>
<p><strong>Server</strong>，包含了服务器的信息，名称，版本号等。 </p>
<p><strong>Content-Type</strong>，文档类型，指定了返回的数据类型是什么，如text/html 则代表返回 HTML 文档， application/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则 代表返回了图片。 </p>
<p><strong>Set-Cookie</strong>，设置 Cookie，Response Headers 中的 Set-Cookie 即告诉浏览器需要 将此内容放在 Cookies 中，下次请求携带 Cookies 内容。 </p>
<p><strong>Expires</strong>,指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更 新到缓存中，如果再 次访问时，直接从缓存中加载，降低服务器负载，缩短加载时间。</p>
<p><strong>3.</strong> <strong>响应体</strong> </p>
<p>即响应体，响应的正文数据都是在响应体中，如请求一个网页，它的响应体就是网页的 HTML 代码，请求一张图 片，它的响应体就是图片的二进制数据。一般在接口的响应内容 大多都是 Json 数据内容. </p>
<img src="https://pic.imgdb.cn/item/61377ed644eaada73955689e.png">

<h1 id="三、JSON-数据格式"><a href="#三、JSON-数据格式" class="headerlink" title="**三、JSON **数据格式"></a>**三、JSON **数据格式</h1><p><strong>1. Json</strong> <strong>简介</strong> </p>
<p>JSON（JavaScript Object Notation，即 JavaScript 对象表示法）是一种轻量级的 数据交换格式。它独立于语言 和平台，JSON 解析器和 JSON 库支持不同的编程语言。</p>
<p>JSON 具有自我描述性，很容易理解。目前大多数接口返 回的数据格式为 JSON,因此进行 接口测试必须掌握 JSON。 </p>
<p><strong>2. Json</strong> <strong>语法特点</strong> </p>
<p>记住下面四点： </p>
<p>1 数据在键/值对中 </p>
<p>2 数据由逗号分隔 </p>
<p>3 {花括号}保存对象 </p>
<p>4 [方括号]保存数组 </p>
<p>JSON 数据的书写格式是：key:value 键值对。比如： “name”:”Tom” </p>
<p>解释：name 是 key，Tom 是 value </p>
<p><strong>JSON 值可以是：</strong> </p>
<p>a. 数字（整数或浮点数） </p>
<p>b. 字符串（在双引号中） </p>
<p>c. 逻辑值（true 或 false） </p>
<p>d. 数组（在方括号中） </p>
<p>e. 对象（在花括号中） </p>
<p><strong>案列代码：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*1.json 的值是数字*/ </span><br><span class="line">&quot;age&quot;:18</span><br><span class="line">/*2.json 的值为字符串*/ </span><br><span class="line">&quot;name&quot;:&quot;Tom&quot;</span><br><span class="line">/*3.json 的值为逻辑值*/ </span><br><span class="line">&quot;result&quot;:true </span><br><span class="line">/*4.json 的值为数组*/ </span><br><span class="line">&quot;city&quot;:[&quot;长沙&quot;,&quot;上海&quot;,&quot;北京&quot;] </span><br><span class="line">/*5.json 的值为对象 JSON 对象在花括号中书写： 对象可以包含多个键/值对： </span><br><span class="line">* */ </span><br><span class="line">&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:在接口测试过程中，一般都是返回 JSON 对象类型。</strong> </p>
<p>比如在数组中含多个对象： </p>
<p>{</p>
<p>“employees”: [ </p>
<p>{ “firstName”:”John” , “lastName”:”Doe” }, </p>
<p>{ “firstName”:”Anna” , “lastName”:”Smith” }, </p>
<p>{ “firstName”:”Peter” , “lastName”:”Jones” } </p>
<p>]</p>
<p>} </p>
<p>在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于 某人（有姓和名）的记录。</p>
<p><strong>3. Json</strong> <strong>数据解析</strong> </p>
<p>Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个方法： </p>
<p>json.dumps(): 将 python 数据转化为 Json 数据 </p>
<p>json.loads(): 将 json 数据类型转为 Python 数据类型 </p>
<p>JSON 库官方文档 <a href="https://docs.python.org/3/library/json.htm">https://docs.python.org/3/library/json.htm</a> </p>
<p><strong>案列</strong> <strong>1：将</strong> <strong>python</strong> <strong>数据转化为</strong> <strong>Json</strong> <strong>数据</strong> </p>
<p>准备代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json #</span><br><span class="line">1 准备字典 </span><br><span class="line">data=&#123;&#x27;id&#x27;:1,&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;password&#x27;:&#x27;66666&#x27;&#125;</span><br><span class="line"></span><br><span class="line">2 检测类型 --dict </span><br><span class="line">print(type(data)) </span><br><span class="line"></span><br><span class="line">3 通过 json.dumps()方法来转换 </span><br><span class="line">json_str=json.dumps(data) </span><br><span class="line"></span><br><span class="line">4.检测类型为 str </span><br><span class="line">print(type(json_str)) </span><br><span class="line"></span><br><span class="line">5.输出的格式就是一个 json 格式 </span><br><span class="line">print(json_str)</span><br></pre></td></tr></table></figure>

<p>输出效果：</p>
<img src="https://pic.imgdb.cn/item/6137828e44eaada7395e3a4a.png">

<p><strong>案例</strong> <strong>2：将</strong> <strong>json</strong> <strong>数据类型转为</strong> <strong>Python</strong> <strong>数据类型</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json </span><br><span class="line"></span><br><span class="line">#1 准备 json 数据--字符串 </span><br><span class="line">json_str=&#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;zhangsan&quot;,&quot;password&quot;:&quot;66666&quot;&#125;&#x27; </span><br><span class="line"></span><br><span class="line">#2 把字符串转 dict </span><br><span class="line">data=json.loads(json_str) </span><br><span class="line"></span><br><span class="line">#3 字符串 </span><br><span class="line">print(type(json_str)) </span><br><span class="line"></span><br><span class="line">#4.dict </span><br><span class="line">print(type(data)) </span><br><span class="line">print(data) </span><br><span class="line">print(data[&#x27;id&#x27;]) </span><br><span class="line">print(data[&#x27;name&#x27;]) </span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<img src="https://pic.imgdb.cn/item/613782e644eaada7395efffa.png">

<h3 id="4-Json-文件处理"><a href="#4-Json-文件处理" class="headerlink" title="4. Json 文件处理"></a><strong>4. Json</strong> <strong>文件处理</strong></h3><p><strong>案例</strong> <strong>1：使用</strong> <strong>Python</strong> <strong>从</strong> <strong>json</strong> <strong>中读取文件</strong> </p>
<p>准备条件</p>
<p>1—json 文件： </p>
<p>2—Python 代码 </p>
<p>代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Json 代码： </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;employees&quot;: [ </span><br><span class="line"></span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;, </span><br><span class="line"></span><br><span class="line">&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;, </span><br><span class="line"></span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125; </span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Python 代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json </span><br><span class="line"></span><br><span class="line">with open(&#x27;data.json&#x27;, &#x27;r&#x27;) as f: </span><br><span class="line"></span><br><span class="line">data = json.load(f) </span><br><span class="line"></span><br><span class="line">print(data) </span><br></pre></td></tr></table></figure>

<p>代码路径截图：放同一个文件夹里面</p>
<img src="https://pic.imgdb.cn/item/6137836044eaada73960107c.png">

<p><strong>案例</strong> <strong>2：使用</strong> <strong>Python</strong> <strong>写入数据到</strong> <strong>json</strong> <strong>文件中</strong> </p>
<p>import json </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.准备一个字符串 </span><br><span class="line"></span><br><span class="line">data=&#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;zhangsan&quot;,&quot;password&quot;:&quot;66666&quot;&#125;&#x27; </span><br><span class="line"></span><br><span class="line">#2.写入 json 文件 </span><br><span class="line"></span><br><span class="line">with open(&#x27;data.json&#x27;, &#x27;w&#x27;) as f: </span><br><span class="line"></span><br><span class="line">json.dump(data, f) </span><br><span class="line"></span><br><span class="line">#3.可以查看 json 文件或者读取出来 </span><br><span class="line"></span><br><span class="line">with open(&#x27;data.json&#x27;, &#x27;r&#x27;) as f: </span><br><span class="line"></span><br><span class="line">data = json.load(f) </span><br><span class="line"></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
